"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[324],{2829:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"error-handling","title":"Error Handling in Rust Ruby Extensions","description":"This guide covers how to handle errors in Rust and map them to appropriate Ruby exceptions.","source":"@site/docs/error-handling.mdx","sourceDirName":".","slug":"/error-handling","permalink":"/docs/error-handling","draft":false,"unlisted":false,"editUrl":"https://github.com/oxidize-rb/rb-sys/tree/main/docsite/docs/error-handling.mdx","tags":[],"version":"current","lastUpdatedBy":"Ian Ker-Seymer","lastUpdatedAt":1762927424000,"sidebarPosition":11,"frontMatter":{"id":"error-handling","title":"Error Handling in Rust Ruby Extensions","sidebar_position":11},"sidebar":"docsSidebar","previous":{"title":"Ruby Classes and Modules","permalink":"/docs/classes-and-modules"},"next":{"title":"Memory Management & Safety","permalink":"/docs/memory-management"}}');var s=n(4848),t=n(8453),o=n(3779);const a={id:"error-handling",title:"Error Handling in Rust Ruby Extensions",sidebar_position:11},l="Error Handling in Rust Ruby Extensions",c={},d=[{value:"Overview of Error Handling Approaches",id:"overview-of-error-handling-approaches",level:2},{value:"The Result Type and Magnus::Error",id:"the-result-type-and-magnuserror",level:2},{value:"Mapping Rust Errors to Ruby Exceptions",id:"mapping-rust-errors-to-ruby-exceptions",level:2},{value:"Standard Ruby Exception Types",id:"standard-ruby-exception-types",level:3},{value:"Creating Custom Exception Classes",id:"creating-custom-exception-classes",level:3},{value:"Passing and Re-raising Ruby Exceptions",id:"passing-and-re-raising-ruby-exceptions",level:3},{value:"Handling Rust Panics",id:"handling-rust-panics",level:2},{value:"Error Handling Patterns",id:"error-handling-patterns",level:2},{value:"The Question Mark Operator",id:"the-question-mark-operator",level:3},{value:"Pattern Matching on Errors",id:"pattern-matching-on-errors",level:3},{value:"Context Managers / RAII Pattern",id:"context-managers--raii-pattern",level:3},{value:"Best Practices for Error Handling",id:"best-practices-for-error-handling",level:2},{value:"1. Be Specific with Exception Types",id:"1-be-specific-with-exception-types",level:3},{value:"2. Provide Clear Error Messages",id:"2-provide-clear-error-messages",level:3},{value:"3. Maintain Ruby Error Hierarchies",id:"3-maintain-ruby-error-hierarchies",level:3},{value:"4. Avoid Panicking",id:"4-avoid-panicking",level:3},{value:"5. Catch All Ruby Exceptions",id:"5-catch-all-ruby-exceptions",level:3},{value:"Error Handling with RefCell",id:"error-handling-with-refcell",level:2},{value:"Conclusion",id:"conclusion",level:2}];function u(e){const r={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"error-handling-in-rust-ruby-extensions",children:"Error Handling in Rust Ruby Extensions"})}),"\n",(0,s.jsx)(r.p,{children:"This guide covers how to handle errors in Rust and map them to appropriate Ruby exceptions."}),"\n",(0,s.jsxs)(r.admonition,{title:"Improper error handling can lead to crashes that take down the entire Ruby VM. Learn how to properly raise",type:"warning",children:[(0,s.jsx)(r.p,{children:"and handle exceptions in your Rust extensions. :::"}),(0,s.jsx)(r.h2,{id:"overview-of-error-handling-approaches",children:"Overview of Error Handling Approaches"}),(0,s.jsx)(r.p,{children:"When building Ruby extensions with Rust, you'll typically use one of these error handling patterns:"}),(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Result-based error handling"}),": Using Rust's ",(0,s.jsx)(r.code,{children:"Result<T, E>"})," type to return errors"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Ruby exception raising"}),": Converting Rust errors into Ruby exceptions"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Panic catching"}),": Handling unexpected Rust panics and converting them to Ruby exceptions"]}),"\n"]}),(0,s.jsxs)(r.admonition,{type:"note",children:[(0,s.jsxs)(r.mdxAdmonitionTitle,{children:["In rb-sys extensions, Rust's ",(0,s.jsx)(r.code,{children:"Result<T, magnus::Error>"})," type is typically used, where the ",(0,s.jsx)(r.code,{children:"Error"})," type"]}),(0,s.jsx)(r.p,{children:"represents a Ruby exception. :::"}),(0,s.jsx)(r.h2,{id:"the-result-type-and-magnuserror",children:"The Result Type and Magnus::Error"}),(0,s.jsxs)(r.p,{children:["Magnus uses ",(0,s.jsx)(r.code,{children:"Result&lt;T, Error&gt;"})," as the standard way to handle errors. The ",(0,s.jsx)(r.code,{children:"Error"})," type represents a Ruby exception\nthat can be raised:"]}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use magnus::{Error, Ruby};\n\nfn might_fail(ruby: &Ruby, value: i64) -> Result<i64, Error> {\n    if value < 0 {\n        return Err(Error::new(\n            ruby.exception_arg_error(),\n            "Value must be positive"\n        ));\n    }\n    Ok(value * 2)\n}\n'})}),(0,s.jsxs)(r.p,{children:["The ",(0,s.jsx)(r.code,{children:"Error"})," type:"]}),(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Contains a reference to a Ruby exception class"}),"\n",(0,s.jsx)(r.li,{children:"Includes an error message"}),"\n",(0,s.jsx)(r.li,{children:"Can be created from an existing Ruby exception"}),"\n"]}),(0,s.jsx)(r.h2,{id:"mapping-rust-errors-to-ruby-exceptions",children:"Mapping Rust Errors to Ruby Exceptions"}),(0,s.jsx)(r.h3,{id:"standard-ruby-exception-types",children:"Standard Ruby Exception Types"}),(0,s.jsx)(r.p,{children:"Magnus provides access to all standard Ruby exception types:"}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use magnus::{Error, Ruby, RArray, Value};\n\nfn divide(ruby: &Ruby, a: f64, b: f64) -> Result<f64, Error> {\n    if b == 0.0 {\n        return Err(Error::new(\n            ruby.exception_zero_div_error(),\n            "Division by zero"\n        ));\n    }\n    Ok(a / b)\n}\n\nfn process_array(ruby: &Ruby, index: isize, array: RArray) -> Result<Value, Error> {\n    if index < 0 || index >= array.len() as isize {\n        return Err(Error::new(\n            ruby.exception_index_error(),\n            format!("Index {} out of bounds (0..{})", index, array.len() - 1)\n        ));\n    }\n    array.entry(index)\n}\n\nfn parse_number(ruby: &Ruby, input: &str) -> Result<i64, Error> {\n    match input.parse::<i64>() {\n        Ok(num) => Ok(num),\n        Err(_) => Err(Error::new(\n            ruby.exception_arg_error(),\n            format!("Cannot parse \'{}\' as a number", input)\n        )),\n    }\n}\n'})}),(0,s.jsx)(r.p,{children:"Common Ruby exception types available through the Ruby API:"}),(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Method"}),(0,s.jsx)(r.th,{children:"Exception Class"}),(0,s.jsx)(r.th,{children:"Typical Use Case"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ruby.exception_arg_error()"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ArgumentError"})}),(0,s.jsx)(r.td,{children:"Invalid argument value or type"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ruby.exception_index_error()"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"IndexError"})}),(0,s.jsx)(r.td,{children:"Array/string index out of bounds"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ruby.exception_key_error()"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"KeyError"})}),(0,s.jsx)(r.td,{children:"Hash key not found"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ruby.exception_name_error()"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"NameError"})}),(0,s.jsx)(r.td,{children:"Reference to undefined name"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ruby.exception_no_memory_error()"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"NoMemoryError"})}),(0,s.jsx)(r.td,{children:"Memory allocation failure"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ruby.exception_not_imp_error()"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"NotImplementedError"})}),(0,s.jsx)(r.td,{children:"Feature not implemented"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ruby.exception_range_error()"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"RangeError"})}),(0,s.jsx)(r.td,{children:"Value outside valid range"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ruby.exception_regexp_error()"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"RegexpError"})}),(0,s.jsx)(r.td,{children:"Invalid regular expression"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ruby.exception_runtime_error()"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"RuntimeError"})}),(0,s.jsx)(r.td,{children:"General runtime error"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ruby.exception_script_error()"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ScriptError"})}),(0,s.jsx)(r.td,{children:"Problem in script execution"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ruby.exception_syntax_error()"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"SyntaxError"})}),(0,s.jsx)(r.td,{children:"Invalid syntax"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ruby.exception_type_error()"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"TypeError"})}),(0,s.jsx)(r.td,{children:"Type mismatch"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ruby.exception_zero_div_error()"})}),(0,s.jsx)(r.td,{children:(0,s.jsx)(r.code,{children:"ZeroDivisionError"})}),(0,s.jsx)(r.td,{children:"Division by zero"})]})]})]}),(0,s.jsx)(r.h3,{id:"creating-custom-exception-classes",children:"Creating Custom Exception Classes"}),(0,s.jsx)(r.p,{children:"You can define custom exception classes for your extension:"}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use magnus::{Error, Ruby, exception};\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let module = ruby.define_module("MyExtension")?;\n\n    // Create custom exception classes\n    let custom_error = magnus::define_error("CustomError", exception::standard_error())?;\n    let validation_error = magnus::define_error("ValidationError", custom_error)?;\n\n    // Register them as constants for easier access\n    ruby.define_global_const("MY_CUSTOM_ERROR", custom_error)?;\n\n    Ok(())\n}\n\n// Using the custom exception\nfn validate(ruby: &Ruby, value: &str) -> Result<(), Error> {\n    if value.is_empty() {\n        return Err(Error::new(\n            ruby.exception_standard_error(), // Use a standard error for now\n            "Validation failed: value cannot be empty"\n        ));\n    }\n    Ok(())\n}\n'})}),(0,s.jsx)(r.h3,{id:"passing-and-re-raising-ruby-exceptions",children:"Passing and Re-raising Ruby Exceptions"}),(0,s.jsx)(r.p,{children:"You can pass along existing Ruby exceptions:"}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use magnus::{Error, Ruby, Value};\nuse magnus::value::ReprValue;\n\nfn process_data(ruby: &Ruby, input: Value) -> Result<Value, Error> {\n    // Call a method that might raise\n    let result = match input.funcall::<_, _, Value>("process", ()) {\n        Ok(val) => val,\n        Err(err) => return Err(err), // Pass along the original error\n    };\n\n    // Or with the ? operator\n    let result = input.funcall::<_, _, Value>("process", ())?;\n\n    Ok(result)\n}\n'})}),(0,s.jsx)(r.p,{children:"For wrapping and adding context to errors:"}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use magnus::{Error, Ruby, Value};\n\n// Mock function for the example\nfn complex_operation(ruby: &Ruby, input: Value) -> Result<Value, Error> {\n    // Placeholder implementation\n    Ok(input)\n}\n\nfn compute_with_context(ruby: &Ruby, input: Value) -> Result<Value, Error> {\n    match complex_operation(ruby, input) {\n        Ok(result) => Ok(result),\n        Err(err) => {\n            // Create a new error with additional context\n            Err(Error::new(\n                ruby.exception_runtime_error(),\n                format!("Computation failed: {:?}", err)\n            ))\n        }\n    }\n}\n'})}),(0,s.jsx)(r.h2,{id:"handling-rust-panics",children:"Handling Rust Panics"}),(0,s.jsx)(r.p,{children:"Rust panics should be caught and converted to Ruby exceptions to prevent crashing the Ruby VM:"}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use magnus::{Error, Ruby};\nuse std::panic::catch_unwind;\n\nfn dangerous_operation(ruby: &Ruby, input: i64) -> Result<i64, Error> {\n    // Catch any potential panics\n    let result = catch_unwind(|| {\n        // Code that might panic\n        if input == 0 {\n            panic!("Unexpected zero value");\n        }\n        input * 2\n    });\n\n    match result {\n        Ok(value) => Ok(value),\n        Err(_) => Err(Error::new(\n            ruby.exception_runtime_error(),\n            "Internal error: Rust panic occurred"\n        )),\n    }\n}\n'})}),(0,s.jsx)(r.h2,{id:"error-handling-patterns",children:"Error Handling Patterns"}),(0,s.jsx)(r.h3,{id:"the-question-mark-operator",children:"The Question Mark Operator"}),(0,s.jsxs)(r.p,{children:["The ",(0,s.jsx)(r.code,{children:"?"})," operator simplifies error handling by automatically propagating errors:"]}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use magnus::{Error, Ruby};\n\n// Mock functions for the example\nfn validate_input(ruby: &Ruby, value: i64) -> Result<i64, Error> {\n    if value < 0 {\n        Err(Error::new(ruby.exception_arg_error(), "Value must be positive"))\n    } else {\n        Ok(value)\n    }\n}\n\nfn transform_data(ruby: &Ruby, value: i64) -> Result<i64, Error> {\n    Ok(value * 2)\n}\n\nfn final_calculation(ruby: &Ruby, value: i64) -> Result<i64, Error> {\n    Ok(value + 10)\n}\n\nfn multi_step_operation(ruby: &Ruby, value: i64) -> Result<i64, Error> {\n    // Each operation can fail, ? will return early on error\n    let step1 = validate_input(ruby, value)?;\n    let step2 = transform_data(ruby, step1)?;\n    let step3 = final_calculation(ruby, step2)?;\n\n    Ok(step3)\n}\n'})}),(0,s.jsx)(r.h3,{id:"pattern-matching-on-errors",children:"Pattern Matching on Errors"}),(0,s.jsx)(r.p,{children:"For more sophisticated error handling, pattern match on error types:"}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use magnus::{Ruby, Value, Error};\nuse magnus::value::ReprValue;\n\nfn handle_specific_errors(ruby: &Ruby, value: Value) -> Result<Value, Error> {\n    let result = value.funcall::<_, _, Value>("some_method", ());\n\n    match result {\n        Ok(val) => Ok(val),\n        Err(err) => {\n            // In Magnus 0.6, we can\'t use is_kind_of, so we handle all errors generically\n            // You could inspect the error message to determine type if needed\n            Err(err)\n        }\n    }\n}\n'})}),(0,s.jsx)(r.h3,{id:"context-managers--raii-pattern",children:"Context Managers / RAII Pattern"}),(0,s.jsx)(o.A,{language:"rust",title:"Cleanup with RAII",children:(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use magnus::{Error, Ruby, Value, RArray, value::ReprValue};\nuse std::fs::File;\nuse std::io::{self, Read};\n\nstruct TempResource { data: Vec<u8>, }\n\nimpl TempResource { fn new() -> Self { // Allocate resource TempResource { data: Vec::new() } } }\n\nimpl Drop for TempResource { fn drop(&mut self) { // Clean up will happen automatically, even if an error occurs\nprintln!("Cleaning up resource"); } }\n\nfn process_with_resource(ruby: &Ruby) -> Result<Value, Error> { // Resource is created let mut resource =\nTempResource::new();\n\n    // If an error occurs here, resource will still be cleaned up\n    let file_result = File::open("data.txt");\n    let mut file = match file_result {\n        Ok(f) => f,\n        Err(e) => return Err(Error::new(\n            ruby.exception_io_error(),\n            format!("Could not open file: {}", e)\n        )),\n    };\n\n    // Resource will be dropped at the end of this scope\n    let arr = RArray::new();\n    arr.push(1)?;\n    arr.push(2)?;\n    arr.push(3)?;\n    Ok(arr.as_value())\n\n}\n\n'})})}),(0,s.jsx)(r.h2,{id:"best-practices-for-error-handling",children:"Best Practices for Error Handling"}),(0,s.jsx)(r.admonition,{type:"tip",children:(0,s.jsx)(r.p,{children:"These practices help create more robust extensions and improve user experience."})})]})]}),"\n",(0,s.jsx)(r.h3,{id:"1-be-specific-with-exception-types",children:"1. Be Specific with Exception Types"}),"\n",(0,s.jsx)(r.p,{children:"Choose the most appropriate Ruby exception type:"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use magnus::{Error, Ruby};\n\nfn example(ruby: &Ruby, index: usize, array: &[i32]) -> Result<i32, Error> {\n    // \u2705 GOOD: Specific exception type\n    if index >= array.len() {\n        return Err(Error::new(\n            ruby.exception_index_error(),\n            format!("Index {} out of bounds (0..{})", index, array.len() - 1)\n        ));\n    }\n\n    Ok(array[index])\n}\n'})}),"\n",(0,s.jsxs)(r.admonition,{title:"Ruby has a rich hierarchy of exception types. Using the specific exception type helps users handle errors",type:"note",children:[(0,s.jsx)(r.p,{children:"properly in their Ruby code. :::"}),(0,s.jsx)(r.h3,{id:"2-provide-clear-error-messages",children:"2. Provide Clear Error Messages"}),(0,s.jsx)(r.p,{children:"Include relevant details in error messages:"}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'fn dummy() {\n    // \u2705 GOOD: Descriptive error with context\n    let err_msg = format!(\n        "Cannot parse \'{}\' as a number in range {}-{}",\n        "input", 0, 100\n    );\n\n    // \u274c BAD: Vague error message\n    let err_msg = "Invalid input";\n}\n'})}),(0,s.jsx)(r.h3,{id:"3-maintain-ruby-error-hierarchies",children:"3. Maintain Ruby Error Hierarchies"}),(0,s.jsx)(r.p,{children:"Respect Ruby's exception hierarchy:"}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use magnus::{Error, Ruby, Module, exception};\n\nfn dummy(ruby: &Ruby) -> Result<(), Error> {\n    let module = ruby.define_module("MyExtension")?;\n    // \u2705 GOOD: Proper exception hierarchy\n    let file_error = magnus::define_error("FileError", exception::io_error())?;\n    let format_error = magnus::define_error("FormatError", file_error)?;\n\n    // \u274c BAD: Improper exception hierarchy\n    let format_error = module.define_class("FormatError", ruby.class_object())?; // Not inheriting from StandardError\n    Ok(())\n}\n'})}),(0,s.jsx)(r.h3,{id:"4-avoid-panicking",children:"4. Avoid Panicking"}),(0,s.jsxs)(r.p,{children:["Use ",(0,s.jsx)(r.code,{children:"Result"})," instead of panic:"]}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use magnus::{Error, Ruby};\n\n// \u2705 GOOD: Return Result for expected error conditions\nfn process(ruby: &Ruby, value: i64) -> Result<i64, Error> {\n    if value < 0 {\n        return Err(Error::new(\n            ruby.exception_arg_error(),\n            "Value must be positive"\n        ));\n    }\n    Ok(value * 2)\n}\n\n// \u274c BAD: Panicking on expected error condition\nfn process_bad(value: i64) -> i64 {\n    if value < 0 {\n        panic!("Value must be positive"); // Will crash the Ruby VM!\n    }\n    value * 2\n}\n'})}),(0,s.jsx)(r.h3,{id:"5-catch-all-ruby-exceptions",children:"5. Catch All Ruby Exceptions"}),(0,s.jsx)(r.p,{children:"When calling Ruby methods, always handle exceptions:"}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use magnus::{Error, Ruby, Value, value::ReprValue};\n\nfn catch_exception(ruby: &Ruby, obj: Value) -> Result<Value, Error> {\n    // \u2705 GOOD: Catch exceptions from Ruby method calls\n    let result = match obj.funcall::<_, _, Value>("some_method", ()) {\n        Ok(val) => val,\n        Err(err) => {\n            // Handle or re-raise the error\n            return Err(err);\n        }\n    };\n    Ok(result)\n}\n\nfn unhandled_exception(ruby: &Ruby, obj: Value) {\n    // \u274c BAD: Not handling potential Ruby exceptions\n    let result: Value = obj.funcall::<_, _, Value>("some_method", ()).unwrap_or_else(|_| ruby.qnil().as_value()); // Better: handle error\n}\n'})}),(0,s.jsx)(r.h2,{id:"error-handling-with-refcell",children:"Error Handling with RefCell"}),(0,s.jsxs)(r.p,{children:["When using ",(0,s.jsx)(r.code,{children:"RefCell"})," for interior mutability, handle borrow errors gracefully:"]}),(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-rust",children:'use std::cell::RefCell;\nuse magnus::{Error, Ruby};\n\n#[magnus::wrap(class = "Counter")]\nstruct MutCounter(RefCell<u64>);\n\nimpl MutCounter {\n    fn new() -> Self {\n        MutCounter(RefCell::new(0))\n    }\n\n    fn increment(ruby: &Ruby, self_: &Self) -> Result<u64, Error> {\n        match self_.0.try_borrow_mut() {\n            Ok(mut value) => {\n                *value += 1;\n                Ok(*value)\n            },\n            Err(_) => Err(Error::new(\n                ruby.exception_runtime_error(),\n                "Cannot modify counter: already borrowed"\n            )),\n        }\n    }\n\n    // Better approach: complete borrows before starting new ones\n    fn safe_increment(&self) -> u64 {\n        let mut value = self.0.borrow_mut();\n        *value += 1;\n        *value\n    }\n}\n'})}),(0,s.jsx)(r.h2,{id:"conclusion",children:"Conclusion"}),(0,s.jsxs)(r.admonition,{type:"warning",children:[(0,s.jsxs)(r.mdxAdmonitionTitle,{children:["Never use ",(0,s.jsx)(r.code,{children:"unwrap()"})," or ",(0,s.jsx)(r.code,{children:"expect()"})," in production code for your Ruby extensions. These can cause panics that"]}),(0,s.jsxs)(r.p,{children:["will crash the Ruby VM. Always use proper error handling with ",(0,s.jsx)(r.code,{children:"Result"})," and ",(0,s.jsx)(r.code,{children:"Error"})," types. :::"]}),(0,s.jsx)(r.p,{children:"Effective error handling makes your Ruby extensions more robust and user-friendly. By using the right exception types\nand providing clear error messages, you create a better experience for users of your extension."}),(0,s.jsx)(r.p,{children:"Remember these key points:"}),(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["Use ",(0,s.jsx)(r.code,{children:"Result&lt;T, Error&gt;"})," for functions that can fail"]}),"\n",(0,s.jsx)(r.li,{children:"Choose appropriate Ruby exception types"}),"\n",(0,s.jsx)(r.li,{children:"Provide clear, detailed error messages"}),"\n",(0,s.jsx)(r.li,{children:"Handle Rust panics to prevent VM crashes"}),"\n",(0,s.jsx)(r.li,{children:"Respect Ruby's exception hierarchy"}),"\n"]}),(0,s.jsx)(r.admonition,{title:"Test your extension with invalid inputs to ensure it throws appropriate Ruby exceptions instead of crashing. :::",type:"tip"})]})]})]})}function h(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},3779:(e,r,n)=>{n.d(r,{A:()=>o});n(6540);const i={languageCallout:"languageCallout_VNpC",ruby:"ruby_iFYN",rust:"rust_PB7z",header:"header_itAP",icon:"icon_vHP_",title:"title_Bire",content:"content_ZrzH"};var s=n(4164),t=n(4848);function o({language:e,icon:r=!0,title:n,children:o}){const a=n||("ruby"===e?"Ruby":"Rust");return(0,t.jsxs)("div",{className:(0,s.A)(i.languageCallout,i[e]),children:[(0,t.jsxs)("div",{className:i.header,children:[r&&(0,t.jsx)("div",{className:i.icon,children:"ruby"===e?(0,t.jsxs)("svg",{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"1.5",height:"20",width:"20",children:[(0,t.jsx)("path",{d:"M6 3h12l4 6-10 12L2 9l4-6z",strokeLinejoin:"round"}),(0,t.jsx)("path",{d:"M12 21L2 9h20",strokeLinejoin:"round"})]}):(0,t.jsxs)("svg",{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"1.5",height:"20",width:"20",children:[(0,t.jsx)("circle",{cx:"12",cy:"12",r:"8"}),(0,t.jsx)("path",{d:"M12 4v2M12 18v2M4 12H6M18 12h2M6.34 6.34l1.42 1.42M16.24 16.24l1.42 1.42M6.34 17.66l1.42-1.42M16.24 7.76l1.42-1.42"}),(0,t.jsx)("path",{d:"M9 12a3 3 0 1 0 6 0 3 3 0 0 0-6 0z"})]})}),(0,t.jsx)("div",{className:i.title,children:a})]}),(0,t.jsx)("div",{className:i.content,children:o})]})}},8453:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>a});var i=n(6540);const s={},t=i.createContext(s);function o(e){const r=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(t.Provider,{value:r},e.children)}}}]);