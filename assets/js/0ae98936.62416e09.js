"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[2338],{3011:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"classes-and-modules","title":"Classes & Modules","description":"This guide explains how to define and structure your code using Ruby\'s object model, including modules, classes, and inheritance.","source":"@site/docs/classes-and-modules.mdx","sourceDirName":".","slug":"/classes-and-modules","permalink":"/docs/classes-and-modules","draft":false,"unlisted":false,"editUrl":"https://github.com/oxidize-rb/rb-sys/tree/main/docsite/docs/classes-and-modules.mdx","tags":[],"version":"current","lastUpdatedBy":"Garen Torikian","lastUpdatedAt":1771615209000,"frontMatter":{"id":"classes-and-modules","title":"Classes & Modules"},"sidebar":"docsSidebar","previous":{"title":"Working with Ruby Objects","permalink":"/docs/working-with-ruby-objects"},"next":{"title":"Error Handling","permalink":"/docs/error-handling"}}');var i=s(4848),a=s(8453);const l={id:"classes-and-modules",title:"Classes & Modules"},r="Classes and Modules",o={},d=[{value:"Defining Modules",id:"defining-modules",level:2},{value:"Key Points",id:"key-points",level:3},{value:"Example: Module with State",id:"example-module-with-state",level:3},{value:"Creating Classes from Rust Structs",id:"creating-classes-from-rust-structs",level:2},{value:"Key Points",id:"key-points-1",level:3},{value:"Example: A Wrapped Struct with Mutable State",id:"example-a-wrapped-struct-with-mutable-state",level:3},{value:"Class Inheritance and Mixins",id:"class-inheritance-and-mixins",level:2},{value:"Key Points",id:"key-points-2",level:3},{value:"Example: Subclassing and Including a Module",id:"example-subclassing-and-including-a-module",level:3},{value:"Singleton Methods",id:"singleton-methods",level:2},{value:"Key Points",id:"key-points-3",level:3},{value:"Example: Class and Instance Methods",id:"example-class-and-instance-methods",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"classes-and-modules",children:"Classes and Modules"})}),"\n",(0,i.jsx)(n.p,{children:"This guide explains how to define and structure your code using Ruby's object model, including modules, classes, and inheritance."}),"\n",(0,i.jsx)(n.h2,{id:"defining-modules",children:"Defining Modules"}),"\n",(0,i.jsx)(n.h3,{id:"key-points",children:"Key Points"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use modules to namespace related functionality."}),"\n",(0,i.jsx)(n.li,{children:"Define constants and module-level methods."}),"\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"static"})," variables with ",(0,i.jsx)(n.code,{children:"Atomic"})," types to maintain thread-safe state within a module."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-module-with-state",children:"Example: Module with State"}),"\n",(0,i.jsxs)(n.p,{children:["This example creates an ",(0,i.jsx)(n.code,{children:"Lz4Flex"})," module that uses ",(0,i.jsx)(n.code,{children:"Lazy"})," static variables\nto safely initialize shared data like the module itself and custom error classes.\nThis is a common and robust pattern for managing global state in a Rust extension."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use magnus::{\n    function, prelude::*, value::{InnerValue, Lazy}, Error, ExceptionClass, RModule,\n    Ruby,\n};\n\n// Using a `Lazy` static to define a module is a great way to ensure that\n// the module is only defined once, and that it is thread-safe.\nstatic LZ4_FLEX: Lazy<RModule> =\n    Lazy::new(|ruby| match ruby.define_module("Lz4Flex") {\n        Ok(m) => m,\n        Err(e) => panic!("Failed to define Lz4Flex module: {}", e),\n    });\n\n// We can also use `Lazy` to define error classes, which can be used\n// across our extension.\nfn base_error_class() -> ExceptionClass {\n    static BASE_ERROR_CLASS: Lazy<ExceptionClass> = Lazy::new(|ruby| {\n        let parent_module = LZ4_FLEX.get_inner_with(ruby);\n        let standard_error = ruby.exception_standard_error();\n        match parent_module.define_error("Error", standard_error) {\n            Ok(e) => e,\n            Err(err) => panic!("Failed to define Error class: {}", err),\n        }\n    });\n    // The `unsafe` block is necessary because `get_unchecked` is the only way\n    // to get a `&Ruby` handle in this context. It is safe because we know\n    // the Ruby VM is running when this code is called.\n    unsafe { BASE_ERROR_CLASS.get_inner_with(&Ruby::get_unchecked()) }\n}\n\n// A placeholder function for our example.\nfn compress(input: String) -> Result<String, Error> {\n    // In a real-world scenario, you would have your compression logic here.\n    Ok(format!("compressed:{}", input))\n}\n\n// Another placeholder function.\nfn decompress(input: String) -> Result<String, Error> {\n    // In a real-world scenario, you would have your decompression logic here.\n    if let Some(original) = input.strip_prefix("compressed:") {\n        Ok(original.to_string())\n    } else {\n        Err(Error::new(base_error_class(), "invalid input".to_string()))\n    }\n}\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let module = LZ4_FLEX.get_inner_with(ruby);\n    // This call ensures the error class is defined and available to Ruby\n    // when the module is loaded.\n    base_error_class();\n\n    module.define_singleton_method("compress", function!(compress, 1))?;\n    module.define_singleton_method("decompress", function!(decompress, 1))?;\n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"creating-classes-from-rust-structs",children:"Creating Classes from Rust Structs"}),"\n",(0,i.jsx)(n.h3,{id:"key-points-1",children:"Key Points"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"#[magnus::wrap]"})," to expose a Rust ",(0,i.jsx)(n.code,{children:"struct"})," as a Ruby class."]}),"\n",(0,i.jsxs)(n.li,{children:["The wrapped ",(0,i.jsx)(n.code,{children:"struct"})," holds the instance data for each Ruby object."]}),"\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"RefCell"})," for interior mutability when instance data needs to be modified through an immutable (",(0,i.jsx)(n.code,{children:"&self"}),") reference."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-a-wrapped-struct-with-mutable-state",children:"Example: A Wrapped Struct with Mutable State"}),"\n",(0,i.jsxs)(n.p,{children:["This example defines a ",(0,i.jsx)(n.code,{children:"Tokenizer"})," class in Rust that can be instantiated and modified from Ruby. It's inspired by real-world tokenizers but simplified for clarity."]}),"\n",(0,i.jsxs)(n.p,{children:["It uses ",(0,i.jsx)(n.code,{children:"#[magnus::wrap]"})," to expose the Rust ",(0,i.jsx)(n.code,{children:"Tokenizer"})," struct as a Ruby class. The struct holds the instance data for each Ruby object, and we use ",(0,i.jsx)(n.code,{children:"RefCell"})," for interior mutability, allowing us to modify data from ",(0,i.jsx)(n.code,{children:"&self"})," methods (which is how Magnus exposes Ruby instance methods)."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use magnus::{class, function, method, prelude::*, Error, Ruby};\nuse std::cell::RefCell;\nuse std::collections::HashMap;\n\n// This struct is wrapped and exposed to Ruby as the `Tokenizer` class.\n#[magnus::wrap(class = "Tokenizer")]\nstruct Tokenizer {\n    // In a real-world scenario, this would be a more complex struct.\n    // Here, we use a `RefCell` around a `HashMap` to represent a vocabulary\n    // that can be modified.\n    vocab: RefCell<HashMap<String, i64>>,\n    next_id: RefCell<i64>,\n}\n\nimpl Tokenizer {\n    // The constructor, exposed to Ruby as `Tokenizer.new`.\n    fn new() -> Self {\n        Self {\n            vocab: RefCell::new(HashMap::new()),\n            next_id: RefCell::new(0),\n        }\n    }\n\n    // An instance method, exposed as `tokenizer.add_token("hello")`.\n    // It modifies the internal state.\n    fn add_token(&self, token: String) -> i64 {\n        let mut vocab = self.vocab.borrow_mut();\n        let mut next_id = self.next_id.borrow_mut();\n\n        // Return existing token ID if it\'s already in the vocab.\n        if let Some(id) = vocab.get(&token) {\n            return *id;\n        }\n\n        let id = *next_id;\n        vocab.insert(token, id);\n        *next_id += 1;\n        id\n    }\n\n    // An accessor method to get the vocabulary size.\n    fn vocab_size(&self) -> usize {\n        self.vocab.borrow().len()\n    }\n}\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let class = ruby.define_class("Tokenizer", ruby.class_object())?;\n    class.define_singleton_method("new", function!(Tokenizer::new, 0))?;\n    class.define_method("add_token", method!(Tokenizer::add_token, 1))?;\n    class.define_method("vocab_size", method!(Tokenizer::vocab_size, 0))?;\n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"class-inheritance-and-mixins",children:"Class Inheritance and Mixins"}),"\n",(0,i.jsx)(n.h3,{id:"key-points-2",children:"Key Points"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["You can subclass existing Ruby classes (e.g., ",(0,i.jsx)(n.code,{children:"Array"}),", ",(0,i.jsx)(n.code,{children:"String"}),")."]}),"\n",(0,i.jsx)(n.li,{children:"Define a module in Rust and include it into a class as a mixin."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-subclassing-and-including-a-module",children:"Example: Subclassing and Including a Module"}),"\n",(0,i.jsxs)(n.p,{children:["This example creates a custom ",(0,i.jsx)(n.code,{children:"SortedArray"})," that subclasses Ruby's ",(0,i.jsx)(n.code,{children:"Array"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use magnus::{method, prelude::*, Error, Ruby, RArray, Value};\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    // 1. Get the parent class (Array).\n    let array_class = ruby.class_array();\n\n    // 2. Define a subclass of Array.\n    let sorted_array = ruby.define_class("SortedArray", array_class)?;\n\n    // 3. Override a method.\n    sorted_array.define_method("<<", method!(|rb_self: RArray, item: Value| {\n        rb_self.push(item)?;\n        rb_self.funcall::<_, _, Value>("sort!", ())?; // Call sort! on self\n        Ok::<magnus::RArray, magnus::Error>(rb_self)\n    }, 1))?;\n\n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"singleton-methods",children:"Singleton Methods"}),"\n",(0,i.jsx)(n.h3,{id:"key-points-3",children:"Key Points"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:'"Class methods" in Ruby are singleton methods on the class object.'}),"\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"define_singleton_method"})," to define class methods."]}),"\n",(0,i.jsx)(n.li,{children:"Singleton methods can also be defined on any specific object instance."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-class-and-instance-methods",children:"Example: Class and Instance Methods"}),"\n",(0,i.jsxs)(n.p,{children:["This example defines a ",(0,i.jsx)(n.code,{children:"Logger"})," class with both instance methods (",(0,i.jsx)(n.code,{children:"log"}),") and class methods (",(0,i.jsx)(n.code,{children:"default_level"}),")."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use magnus::{function, method, prelude::*, Error, Ruby};\n\n#[magnus::wrap(class = "Logger")]\nstruct Logger {\n    level: String,\n}\n\nimpl Logger {\n    fn new(level: String) -> Self { Self { level } }\n    fn log(&self, message: String) { println!("[{}] {}", self.level, message); }\n    fn default_level() -> &\'static str { "INFO" }\n}\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let class = ruby.define_class("Logger", ruby.class_object())?;\n    class.define_singleton_method("new", function!(Logger::new, 1))?; // Constructor\n    class.define_singleton_method("default_level", function!(Logger::default_level, 0))?; // Class method\n    class.define_method("log", method!(Logger::log, 1))?; // Instance method\n    Ok(())\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>r});var t=s(6540);const i={},a=t.createContext(i);function l(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);