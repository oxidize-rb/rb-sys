"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[6564],{2117:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"basic-patterns","title":"Basic Patterns","description":"This page covers the essential patterns for defining functions, converting types, and handling errors when building a Ruby extension in Rust.","source":"@site/docs/basic-patterns.mdx","sourceDirName":".","slug":"/basic-patterns","permalink":"/docs/basic-patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/oxidize-rb/rb-sys/tree/main/docsite/docs/basic-patterns.mdx","tags":[],"version":"current","lastUpdatedBy":"Garen Torikian","lastUpdatedAt":1770941528000,"sidebarPosition":5,"frontMatter":{"id":"basic-patterns","title":"Basic Patterns","sidebar_position":5},"sidebar":"docsSidebar","previous":{"title":"Project Setup & Structure","permalink":"/docs/project-setup"},"next":{"title":"Working with Ruby Objects","permalink":"/docs/working-with-ruby-objects"}}');var i=r(4848),t=r(8453);const o={id:"basic-patterns",title:"Basic Patterns",sidebar_position:5},l=void 0,a={},c=[{value:"Core Principles",id:"core-principles",level:3},{value:"Functions &amp; Methods",id:"functions--methods",level:2},{value:"Module Functions",id:"module-functions",level:3},{value:"Instance Methods",id:"instance-methods",level:3},{value:"Type Conversions",id:"type-conversions",level:2},{value:"Strings",id:"strings",level:3},{value:"Numbers",id:"numbers",level:3},{value:"Arrays",id:"arrays",level:3},{value:"Hashes",id:"hashes",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Optional Arguments &amp; Blocks",id:"optional-arguments--blocks",level:2},{value:"Optional Arguments",id:"optional-arguments",level:3},{value:"Blocks",id:"blocks",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"This page covers the essential patterns for defining functions, converting types, and handling errors when building a Ruby extension in Rust."}),"\n",(0,i.jsx)(n.h3,{id:"core-principles",children:"Core Principles"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"Result<T, magnus::Error>"})," for any function that can fail. This automatically maps Rust errors to Ruby exceptions."]}),"\n",(0,i.jsxs)(n.li,{children:["Leverage Magnus's automatic type conversions for simple types (",(0,i.jsx)(n.code,{children:"String"}),", ",(0,i.jsx)(n.code,{children:"i64"}),", ",(0,i.jsx)(n.code,{children:"Vec<T>"}),", etc.)."]}),"\n",(0,i.jsxs)(n.li,{children:["For complex types or performance-critical code, work directly with Ruby objects like ",(0,i.jsx)(n.code,{children:"RString"}),", ",(0,i.jsx)(n.code,{children:"RArray"}),", and ",(0,i.jsx)(n.code,{children:"RHash"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Never ",(0,i.jsx)(n.code,{children:"panic!"}),". A panic in your Rust code will crash the entire Ruby process."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"functions--methods",children:"Functions & Methods"}),"\n",(0,i.jsx)(n.h3,{id:"module-functions",children:"Module Functions"}),"\n",(0,i.jsx)(n.p,{children:"Define standalone functions in a Ruby module. Magnus handles the conversion from Rust types to Ruby objects."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use magnus::{function, prelude::*, Error, Ruby};\n\n// A function that can fail.\nfn divide(ruby: &Ruby, a: f64, b: f64) -> Result<f64, Error> {\n    if b == 0.0 {\n        // This becomes a `ZeroDivisionError` in Ruby.\n        Err(Error::new(ruby.exception_zero_div_error(), "divided by 0"))\n    } else {\n        Ok(a / b)\n    }\n}\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let module = ruby.define_module("MathUtils")?;\n    module.define_singleton_method("divide", function!(divide, 2))?;\n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"instance-methods",children:"Instance Methods"}),"\n",(0,i.jsxs)(n.p,{children:["Define a class in Rust and attach instance methods to it. Use ",(0,i.jsx)(n.code,{children:"#[magnus::wrap]"})," to expose a Rust ",(0,i.jsx)(n.code,{children:"struct"})," as a Ruby object."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use magnus::{method, prelude::*, Error, Ruby};\nuse std::cell::RefCell;\n\n#[magnus::wrap(class = "Counter")]\nstruct Counter(RefCell<i64>);\n\nimpl Counter {\n    fn new(initial: i64) -> Self {\n        Self(RefCell::new(initial))\n    }\n\n    fn increment(&self, amount: i64) {\n        *self.0.borrow_mut() += amount;\n    }\n\n    fn value(&self) -> i64 {\n        *self.0.borrow()\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"type-conversions",children:"Type Conversions"}),"\n",(0,i.jsx)(n.h3,{id:"strings",children:"Strings"}),"\n",(0,i.jsxs)(n.p,{children:["Automatic conversion works for ",(0,i.jsx)(n.code,{children:"String"}),". For more control or efficiency, use ",(0,i.jsx)(n.code,{children:"RString"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use magnus::{RString, Error};\n\n// Automatic conversion from Ruby String to Rust String.\nfn get_length(s: String) -> usize {\n    s.len()\n}\n\n// Direct manipulation of a Ruby string, avoiding a full copy.\nfn is_empty(s: RString) -> bool {\n    s.is_empty()\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"numbers",children:"Numbers"}),"\n",(0,i.jsxs)(n.p,{children:["Automatic conversion works for primitives like ",(0,i.jsx)(n.code,{children:"i64"})," and ",(0,i.jsx)(n.code,{children:"f64"}),". A common failure is integer overflow."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use magnus::{Integer, Error, exception, Ruby};\n\nfn safe_multiply(ruby: &Ruby, a: i64, b: i64) -> Result<i64, Error> {\n    a.checked_mul(b).ok_or_else(|| {\n        Error::new(ruby.exception_range_error(), "integer overflow")\n    })\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"arrays",children:"Arrays"}),"\n",(0,i.jsxs)(n.p,{children:["Automatic conversion works for ",(0,i.jsx)(n.code,{children:"Vec<T>"}),". For heterogeneous arrays or large datasets, use ",(0,i.jsx)(n.code,{children:"RArray"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use magnus::{RArray, Error, TryConvert};\n\n// Automatic conversion.\nfn sum_integers(numbers: Vec<i64>) -> i64 {\n    numbers.iter().sum()\n}\n\n// Manual conversion with error handling for mixed types.\nfn first_integer(array: RArray) -> Result<i64, Error> {\n    let first_item = array.entry(0)?;\n    i64::try_convert(first_item)\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"hashes",children:"Hashes"}),"\n",(0,i.jsxs)(n.p,{children:["Automatic conversion works for ",(0,i.jsx)(n.code,{children:"HashMap<K, V>"}),". For symbol keys or mixed value types, use ",(0,i.jsx)(n.code,{children:"RHash"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use magnus::{RHash, Symbol, Error, Ruby, TryConvert};\nuse std::collections::HashMap;\n\n// Automatic conversion.\nfn get_keys(hash: HashMap<String, i64>) -> Vec<String> {\n    hash.keys().cloned().collect()\n}\n\n// Manual lookup with a symbol key.\nfn get_id(ruby: &Ruby, hash: RHash) -> Result<i64, Error> {\n    match hash.get(ruby.to_symbol("id")) {\n        Some(val) => i64::try_convert(val),\n        None => Err(Error::new(ruby.exception_arg_error(), "missing :id key")),\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsxs)(n.p,{children:["Define custom Rust error types and convert them into Ruby exceptions. See the ",(0,i.jsx)(n.a,{href:"/docs/error-handling",children:"Error Handling"})," guide for more advanced patterns."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use magnus::{Error, prelude::*};\nuse std::fmt;\n\n#[derive(Debug)]\nstruct MyError(String);\n\nimpl fmt::Display for MyError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, "{}", self.0)\n    }\n}\n\n// Use it in a function.\nfn might_fail(should_fail: bool) -> Result<(), MyError> {\n    if should_fail {\n        Err(MyError("Something went wrong".to_string()))\n    } else {\n        Ok(())\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"optional-arguments--blocks",children:"Optional Arguments & Blocks"}),"\n",(0,i.jsx)(n.h3,{id:"optional-arguments",children:"Optional Arguments"}),"\n",(0,i.jsxs)(n.p,{children:["Use ",(0,i.jsx)(n.code,{children:"Option<T>"})," for optional arguments. For keyword arguments, accept an ",(0,i.jsx)(n.code,{children:"RHash"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use magnus::{RHash, Error, TryConvert};\n\n// `greeting` will be `None` if the argument is omitted or `nil`.\nfn greet(name: String, greeting: Option<String>) -> String {\n    format!("{}, {}!", greeting.unwrap_or_else(|| "Hello".to_string()), name)\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"blocks",children:"Blocks"}),"\n",(0,i.jsxs)(n.p,{children:["Accept a Ruby block as a ",(0,i.jsx)(n.code,{children:"Proc"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use magnus::{block::Proc, Value, Error};\n\nfn call_the_block(block: Proc) -> Result<Value, Error> {\n    block.call(("Hello from Rust!",))\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>l});var s=r(6540);const i={},t=s.createContext(i);function o(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);