"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[1011],{6280:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"faq","title":"Frequently Asked Questions","description":"Answers to frequently asked questions about building Ruby extensions with Rust using rb-sys.","source":"@site/docs/faq.mdx","sourceDirName":".","slug":"/faq","permalink":"/docs/faq","draft":false,"unlisted":false,"editUrl":"https://github.com/oxidize-rb/rb-sys/tree/main/docsite/docs/faq.mdx","tags":[],"version":"current","lastUpdatedBy":"Xiaoxi Pang","lastUpdatedAt":1762877000000,"sidebarPosition":20,"frontMatter":{"id":"faq","title":"Frequently Asked Questions","sidebar_position":20,"keywords":["faq","questions","troubleshooting","help","common issues"],"description":"Answers to frequently asked questions about building Ruby extensions with Rust using rb-sys."},"sidebar":"docsSidebar","previous":{"title":"Cookbook","permalink":"/docs/cookbook"},"next":{"title":"Glossary","permalink":"/docs/glossary"}}');var i=s(4848),t=s(8453);const l={id:"faq",title:"Frequently Asked Questions",sidebar_position:20,keywords:["faq","questions","troubleshooting","help","common issues"],description:"Answers to frequently asked questions about building Ruby extensions with Rust using rb-sys."},o="Frequently Asked Questions",a={},d=[{value:"General Questions",id:"general-questions",level:2},{value:"Q: When should I use Rust for Ruby extensions?",id:"q-when-should-i-use-rust-for-ruby-extensions",level:3},{value:"Q: Is Rust harder to learn than C?",id:"q-is-rust-harder-to-learn-than-c",level:3},{value:"Q: How much faster will my code be?",id:"q-how-much-faster-will-my-code-be",level:3},{value:"Q: Will this work with Rails?",id:"q-will-this-work-with-rails",level:3},{value:"Technical Questions",id:"technical-questions",level:2},{value:"Q: How do I debug Rust extensions?",id:"q-how-do-i-debug-rust-extensions",level:3},{value:"Q: How do I handle Ruby version compatibility?",id:"q-how-do-i-handle-ruby-version-compatibility",level:3},{value:"Q: Can I use async/await in Ruby extensions?",id:"q-can-i-use-asyncawait-in-ruby-extensions",level:3},{value:"Q: How do I distribute my gem?",id:"q-how-do-i-distribute-my-gem",level:3},{value:"Performance Questions",id:"performance-questions",level:2},{value:"Q: Why is my extension slower than expected?",id:"q-why-is-my-extension-slower-than-expected",level:3},{value:"Q: How do I profile my extension?",id:"q-how-do-i-profile-my-extension",level:3},{value:"Memory Questions",id:"memory-questions",level:2},{value:"Q: How do I prevent memory leaks?",id:"q-how-do-i-prevent-memory-leaks",level:3},{value:"Q: Can I share memory between Ruby and Rust?",id:"q-can-i-share-memory-between-ruby-and-rust",level:3},{value:"Error Handling Questions",id:"error-handling-questions",level:2},{value:"Q: How should I handle panics?",id:"q-how-should-i-handle-panics",level:3},{value:"Deployment Questions",id:"deployment-questions",level:2},{value:"Q: Do users need Rust installed?",id:"q-do-users-need-rust-installed",level:3},{value:"Q: How do I support multiple platforms?",id:"q-how-do-i-support-multiple-platforms",level:3},{value:"Q: What about Ruby version compatibility?",id:"q-what-about-ruby-version-compatibility",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Q: &quot;undefined symbol&quot; errors?",id:"q-undefined-symbol-errors",level:3},{value:"Q: &quot;libclang not found&quot; during installation?",id:"q-libclang-not-found-during-installation",level:3},{value:"Q: Extension works locally but fails in production?",id:"q-extension-works-locally-but-fails-in-production",level:3},{value:"Getting Help",id:"getting-help",level:2},{value:"Q: Where can I get help?",id:"q-where-can-i-get-help",level:3},{value:"Q: How can I contribute?",id:"q-how-can-i-contribute",level:3},{value:"Still Have Questions?",id:"still-have-questions",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"frequently-asked-questions",children:"Frequently Asked Questions"})}),"\n",(0,i.jsx)(n.p,{children:"Find answers to common questions about building Ruby extensions with Rust."}),"\n",(0,i.jsx)(n.h2,{id:"general-questions",children:"General Questions"}),"\n",(0,i.jsx)(n.h3,{id:"q-when-should-i-use-rust-for-ruby-extensions",children:"Q: When should I use Rust for Ruby extensions?"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"A:"})," Consider Rust when you need:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"CPU-intensive algorithms (parsing, compression, cryptography)"}),"\n",(0,i.jsx)(n.li,{children:"Memory-intensive operations (image processing, data transformation)"}),"\n",(0,i.jsx)(n.li,{children:"System-level integration (OS APIs, hardware access)"}),"\n",(0,i.jsx)(n.li,{children:"Concurrent/parallel processing"}),"\n",(0,i.jsx)(n.li,{children:"Security-critical code"}),"\n",(0,i.jsx)(n.li,{children:"Wrapping existing Rust libraries"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"q-is-rust-harder-to-learn-than-c",children:"Q: Is Rust harder to learn than C?"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"A:"})," Different, not necessarily harder:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Rust challenges:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Ownership and borrowing concepts"}),"\n",(0,i.jsx)(n.li,{children:"Stricter compiler"}),"\n",(0,i.jsx)(n.li,{children:"More complex type system"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Rust advantages:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"No segfaults or memory leaks"}),"\n",(0,i.jsx)(n.li,{children:"Better error messages"}),"\n",(0,i.jsx)(n.li,{children:"Modern tooling (Cargo, rustfmt, clippy)"}),"\n",(0,i.jsx)(n.li,{children:"Comprehensive standard library"}),"\n",(0,i.jsx)(n.li,{children:"Good documentation"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Most developers find Rust's learning curve worth it for the safety guarantees."}),"\n",(0,i.jsx)(n.h3,{id:"q-how-much-faster-will-my-code-be",children:"Q: How much faster will my code be?"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"A:"})," It depends on what you're doing."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"CPU-bound operations"}),": Often 10-100x faster"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory allocation heavy"}),": 5-20x faster"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"String processing"}),": 5-50x faster"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Simple operations"}),": May be slower due to FFI overhead"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"With Ruby's YJIT, pure Ruby is faster than ever. Profile first."}),"\n",(0,i.jsx)(n.h3,{id:"q-will-this-work-with-rails",children:"Q: Will this work with Rails?"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"A:"})," Yes, rb-sys extensions work with Rails."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# Gemfile\ngem 'your_rust_extension'\n\n# In your Rails code\nclass DataProcessor\n  def process(data)\n    # Calls your Rust extension\n    YourRustExtension.process(data)\n  end\nend\n"})}),"\n",(0,i.jsx)(n.p,{children:"Many production Rails apps use Rust extensions for performance-critical paths."}),"\n",(0,i.jsx)(n.h2,{id:"technical-questions",children:"Technical Questions"}),"\n",(0,i.jsx)(n.h3,{id:"q-how-do-i-debug-rust-extensions",children:"Q: How do I debug Rust extensions?"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"A:"})," There are several approaches:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Print debugging:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use magnus::{Ruby, Value, value::ReprValue};\n\nfn debug_function(value: String) {\n    eprintln!("Debug: value = {:?}", value);\n\n    // Or use Ruby\'s puts\n    let ruby = unsafe { Ruby::get_unchecked() };\n    let _: Value = ruby.eval(&format!("puts \'Debug: {}\'", value))\n        .unwrap_or_else(|_| ruby.qnil().as_value());\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Use a debugger:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# With LLDB on macOS\nlldb -- ruby -r ./lib/my_extension.rb -e "MyExtension.method"\n\n# With GDB on Linux\ngdb --args ruby -r ./lib/my_extension.rb -e "MyExtension.method"\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. Logging:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// Add to Cargo.toml\n// [dependencies]\n// log = "0.4"\n// env_logger = "0.10"\n\n// In your code\n// log::debug!("Processing {} items", items.len());\n'})}),"\n",(0,i.jsx)(n.h3,{id:"q-how-do-i-handle-ruby-version-compatibility",children:"Q: How do I handle Ruby version compatibility?"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"A:"})," rb-sys provides version detection."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"// In build.rs\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // rb-sys automatically handles Ruby version detection during build\n    Ok(())\n}\n\n// In your code\n// rb-sys-env automatically sets Ruby version cfg flags\n#[cfg(ruby_gte_3_0)]\nfn ruby3_only_feature() {\n    // Ruby 3.0+ only code\n}\n\n#[cfg(not(ruby_gte_3_0))]\nfn ruby2_compat() {\n    // Ruby 2.x compatible code\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"q-can-i-use-asyncawait-in-ruby-extensions",children:"Q: Can I use async/await in Ruby extensions?"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"A:"})," Yes, but you need to properly handle async runtimes. Since Ruby extensions are synchronous, you'll need to block on async code."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use magnus::{Error, Ruby};\nuse std::thread;\nuse std::sync::mpsc;\n\n// For CPU-intensive operations, release the GVL\nfn parallel_operation(data: Vec<u8>) -> Result<Vec<u8>, Error> {\n    use rb_sys::rb_thread_call_without_gvl;\n    use std::os::raw::c_void;\n\n    struct ProcessData {\n        input: Vec<u8>,\n        output: Option<Vec<u8>>,\n    }\n\n    extern "C" fn process_without_gvl(data: *mut c_void) -> *mut c_void {\n        unsafe {\n            let process_data = &mut *(data as *mut ProcessData);\n            // Perform CPU-intensive work here\n            let processed = process_data.input.iter()\n                .map(|&b| b.wrapping_add(1))\n                .collect();\n            process_data.output = Some(processed);\n        }\n        std::ptr::null_mut()\n    }\n\n    let mut process_data = ProcessData {\n        input: data,\n        output: None,\n    };\n\n    unsafe {\n        rb_thread_call_without_gvl(\n            Some(process_without_gvl),\n            &mut process_data as *mut _ as *mut c_void,\n            None,\n            std::ptr::null_mut(),\n        );\n    }\n\n    process_data.output.ok_or_else(|| {\n        Error::new(magnus::exception::runtime_error(), "Processing failed")\n    })\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"q-how-do-i-distribute-my-gem",children:"Q: How do I distribute my gem?"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"A:"})," There are multiple strategies:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Source gems (easiest):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:'# In gemspec\n# spec.extensions = ["ext/my_gem/extconf.rb"]\n# spec.files = Dir["ext/**/*.{rs,toml,rb}", "lib/**/*.rb"]\n\n# Users need Rust installed\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Pre-compiled gems (best UX):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Use rake-compiler-dock\nrake gem:native\n\n# Creates platform-specific gems:\n# - my_gem-1.0.0-x86_64-linux.gem\n# - my_gem-1.0.0-x86_64-darwin.gem\n# - my_gem-1.0.0-arm64-darwin.gem\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. GitHub Actions (automated):"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# .github/workflows/release.yml\nname: Release\non:\n  push:\n    tags: ['v*']\n\njobs:\n  release:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: oxidize-rb/actions/setup-ruby-and-rust@v1\n      - uses: oxidize-rb/actions/cross-gem@v1\n"})}),"\n",(0,i.jsx)(n.h2,{id:"performance-questions",children:"Performance Questions"}),"\n",(0,i.jsx)(n.h3,{id:"q-why-is-my-extension-slower-than-expected",children:"Q: Why is my extension slower than expected?"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"A:"})," There are common causes:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Too many conversions:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use magnus::{Error, RArray, TryConvert};\n\n// Bad: Converts entire array upfront\nfn sum(numbers: Vec<i64>) -> i64 {\n    numbers.iter().sum()\n}\n\n// Good: Iterates without conversion\nfn sum_good(array: RArray) -> Result<i64, Error> {\n    let mut total = 0;\n    for item in array.each() {\n        total += i64::try_convert(item?)?;\n    }\n    Ok(total)\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Not releasing the GVL:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"fn release_gvl_example(data: &[u8]) {\n    // Release GVL for operations > 100ms\n    if data.len() > 1_000_000 {\n        // Use rb_thread_call_without_gvl\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. Excessive allocations:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"fn excessive_allocations() {\n    // Bad: Allocates repeatedly\n    for i in 0..1000 {\n        let mut vec: Vec<i32> = Vec::new();\n        // ...\n    }\n\n    // Good: Reuse allocation\n    let mut vec: Vec<i32> = Vec::with_capacity(1000);\n    for i in 0..1000 {\n        vec.clear();\n        // ...\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"q-how-do-i-profile-my-extension",children:"Q: How do I profile my extension?"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"A:"})," Use cargo's built-in profiling."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:'# Add to Cargo.toml\n# [profile.release]\n# debug = true\n\n# Profile with flamegraph\ncargo install flamegraph\n# sudo cargo flamegraph --bin my_extension\n\n# Or use Ruby\'s profiling tools\n# ruby -r profile -r ./lib/my_extension.rb -e "MyExtension.slow_method"\n'})}),"\n",(0,i.jsx)(n.h2,{id:"memory-questions",children:"Memory Questions"}),"\n",(0,i.jsx)(n.h3,{id:"q-how-do-i-prevent-memory-leaks",children:"Q: How do I prevent memory leaks?"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"A:"})," Follow these patterns:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"1. Always mark Ruby references:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use magnus::{RString};\n\n#[magnus::wrap(class = "MyClass")]\nstruct MyClass {\n    // Store the string data instead of Ruby Value\n    string_data: String,\n}\n\nimpl MyClass {\n    fn new(ruby_string: RString) -> Result<Self, magnus::Error> {\n        Ok(MyClass {\n            string_data: ruby_string.to_string()?,\n        })\n    }\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"2. Use RAII patterns:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use std::path::PathBuf;\n\n// Resources are automatically cleaned up\nstruct TempFile {\n    path: PathBuf,\n}\n\nimpl Drop for TempFile {\n    fn drop(&mut self) {\n        let _ = std::fs::remove_file(&self.path);\n    }\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"3. Test with GC stress:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:"# In your tests\n# GC.stress = true\n# YourExtension.method_that_allocates\n# GC.stress = false\n"})}),"\n",(0,i.jsx)(n.h3,{id:"q-can-i-share-memory-between-ruby-and-rust",children:"Q: Can I share memory between Ruby and Rust?"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"A:"})," Yes, but carefully."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use magnus::{Error, RString};\n\n// Zero-copy string access\nfn process_string(ruby_str: RString) -> Result<(), Error> {\n    let bytes = unsafe { ruby_str.as_slice() };\n    // Process bytes without copying\n    Ok(())\n}\n\n// Shared memory with TypedData\nstruct SharedBuffer {\n    data: Vec<u8>,\n}\n\nimpl SharedBuffer {\n    fn get_slice(&self, start: usize, len: usize) -> &[u8] {\n        &self.data[start..start + len]\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"error-handling-questions",children:"Error Handling Questions"}),"\n",(0,i.jsx)(n.h3,{id:"q-how-should-i-handle-panics",children:"Q: How should I handle panics?"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"A:"})," Avoid them entirely."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use magnus::{Error, exception};\n\n// Bad: Panics crash Ruby\nfn bad_function(index: usize, data: Vec<String>) -> String {\n    data[index].clone()  // Panics on out of bounds\n}\n\n// Good: Return errors\nfn good_function(index: usize, data: Vec<String>) -> Result<String, Error> {\n    data.get(index)\n        .cloned()\n        .ok_or_else(|| Error::new(\n            exception::index_error(),\n            format!("index {} out of bounds", index)\n        ))\n}\n\nfn potentially_panicking_code() {}\n\n// If you must use code that might panic\nuse std::panic;\n\nfn safe_wrapper() -> Result<(), Error> {\n    panic::catch_unwind(|| {\n        potentially_panicking_code()\n    }).map_err(|_| Error::new(\n        exception::runtime_error(),\n        "operation failed"\n    ))\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"deployment-questions",children:"Deployment Questions"}),"\n",(0,i.jsx)(n.h3,{id:"q-do-users-need-rust-installed",children:"Q: Do users need Rust installed?"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"A:"})," It depends on the distribution method:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Source gems"}),": Yes, users need Rust"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Pre-compiled gems"}),": No, includes compiled binary"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Bundled with vendored"}),": No, but larger gem size"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"q-how-do-i-support-multiple-platforms",children:"Q: How do I support multiple platforms?"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"A:"})," Use rb-sys's cross-compilation."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# Install cross-compilation tool\ngem install rb_sys\n\n# Build for multiple platforms\n# bundle exec rb-sys-dock --platforms x86_64-linux,aarch64-linux\n\n# Or use GitHub Actions\n# See oxidize-rb/cross-gem-action\n"})}),"\n",(0,i.jsx)(n.h3,{id:"q-what-about-ruby-version-compatibility",children:"Q: What about Ruby version compatibility?"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"A:"})," rb-sys handles most differences."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-toml",children:'# Cargo.toml\n# [dependencies]\n# rb-sys = { version = "0.9", features = ["stable-api-compiled-fallback"] }\n\n# Supports Ruby 2.6 through 3.3+\n'})}),"\n",(0,i.jsx)(n.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,i.jsx)(n.h3,{id:"q-undefined-symbol-errors",children:'Q: "undefined symbol" errors?'}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"A:"})," There are common causes:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Missing rb-sys dependency"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Wrong library type in Cargo.toml"})," - use ",(0,i.jsx)(n.code,{children:'crate-type = ["cdylib"]'})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Name mismatch"})," between Rust and Ruby"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"q-libclang-not-found-during-installation",children:'Q: "libclang not found" during installation?'}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"A:"})," Install libclang."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"# macOS\nbrew install llvm\n\n# Ubuntu/Debian\napt-get install libclang-dev\n\n# Or use the gem\ngem install libclang\n"})}),"\n",(0,i.jsx)(n.h3,{id:"q-extension-works-locally-but-fails-in-production",children:"Q: Extension works locally but fails in production?"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"A:"})," Check the following:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Platform compatibility"})," - build for production architecture"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Ruby version"})," - ensure compatibility"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dependencies"})," - system libraries available?"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Compilation flags"})," - release vs debug build"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"getting-help",children:"Getting Help"}),"\n",(0,i.jsx)(n.h3,{id:"q-where-can-i-get-help",children:"Q: Where can I get help?"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"A:"})," There are multiple resources:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://join.slack.com/t/oxidize-rb/shared_invite/zt-16zv5tqte-Vi7WfzxCesdo2TqF_RYBCw",children:"Oxidize Slack"})})," - Active community"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/oxidize-rb/rb-sys/discussions",children:"GitHub Discussions"})})," - Q&A forum"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/oxidize-rb/rb-sys/issues",children:"GitHub Issues"})})," - Bug reports"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.a,{href:"https://github.com/oxidize-rb/examples",children:"Examples Repository"})})," - Working code"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"q-how-can-i-contribute",children:"Q: How can I contribute?"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"A:"})," We welcome contributions."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Documentation"}),": Fix typos, add examples"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Code"}),": Fix bugs, add features"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Examples"}),": Share your extensions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Community"}),": Help others, share knowledge"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["See our ",(0,i.jsx)(n.a,{href:"contributing",children:"Contributing Guide"})," for details."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)("div",{className:"success-message",children:[(0,i.jsx)(n.h3,{id:"still-have-questions",children:"Still Have Questions?"}),(0,i.jsxs)(n.p,{children:["Join our ",(0,i.jsx)(n.a,{href:"https://join.slack.com/t/oxidize-rb/shared_invite/zt-16zv5tqte-Vi7WfzxCesdo2TqF_RYBCw",children:"Slack community"})," - we are happy to help."]})]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>o});var r=s(6540);const i={},t=r.createContext(i);function l(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);