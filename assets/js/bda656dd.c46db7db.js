"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[4577],{1151:(e,n,s)=>{s.d(n,{A:()=>l});s(6540);const r={codeComparison:"codeComparison_cfCm",codeBlock:"codeBlock_bE1R",languageIndicator:"languageIndicator_Wjf7",rubyIndicator:"rubyIndicator_IEF1",rustIndicator:"rustIndicator_ZrAT"};var t=s(4568),i=s(9365),o=s(1028),a=s(4848);function l({ruby:e,rust:n,rubyTitle:s="Ruby",rustTitle:l="Rust",rubyLanguage:c="ruby",rustLanguage:u="rust"}){return(0,a.jsx)("div",{className:r.codeComparison,children:(0,a.jsxs)(t.A,{children:[(0,a.jsx)(i.A,{value:"ruby",label:s,default:!0,children:(0,a.jsx)("div",{className:r.codeBlock,children:(0,a.jsx)(o.A,{language:c,children:e})})}),(0,a.jsx)(i.A,{value:"rust",label:l,children:(0,a.jsx)("div",{className:r.codeBlock,children:(0,a.jsx)(o.A,{language:u,children:n})})})]})})}},3779:(e,n,s)=>{s.d(n,{A:()=>o});s(6540);const r={languageCallout:"languageCallout_VNpC",ruby:"ruby_iFYN",rust:"rust_PB7z",header:"header_itAP",icon:"icon_vHP_",title:"title_Bire",content:"content_ZrzH"};var t=s(4164),i=s(4848);function o({language:e,icon:n=!0,title:s,children:o}){const a=s||("ruby"===e?"Ruby":"Rust");return(0,i.jsxs)("div",{className:(0,t.A)(r.languageCallout,r[e]),children:[(0,i.jsxs)("div",{className:r.header,children:[n&&(0,i.jsx)("div",{className:r.icon,children:"ruby"===e?(0,i.jsxs)("svg",{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"1.5",height:"20",width:"20",children:[(0,i.jsx)("path",{d:"M6 3h12l4 6-10 12L2 9l4-6z",strokeLinejoin:"round"}),(0,i.jsx)("path",{d:"M12 21L2 9h20",strokeLinejoin:"round"})]}):(0,i.jsxs)("svg",{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"1.5",height:"20",width:"20",children:[(0,i.jsx)("circle",{cx:"12",cy:"12",r:"8"}),(0,i.jsx)("path",{d:"M12 4v2M12 18v2M4 12H6M18 12h2M6.34 6.34l1.42 1.42M16.24 16.24l1.42 1.42M6.34 17.66l1.42-1.42M16.24 7.76l1.42-1.42"}),(0,i.jsx)("path",{d:"M9 12a3 3 0 1 0 6 0 3 3 0 0 0-6 0z"})]})}),(0,i.jsx)("div",{className:r.title,children:a})]}),(0,i.jsx)("div",{className:r.content,children:o})]})}},4568:(e,n,s)=>{s.d(n,{A:()=>h});var r=s(6540),t=s(4164);const i="tabsContainer_MFXm",o="tabList_TRJ7",a="tabItem_hGfb",l="tabItemActive_HPJJ",c="tabContent_vyUe";var u=s(4848);function d(e){const{children:n,className:s,defaultValue:d}=e,h=r.Children.toArray(n).filter((e=>{if(!r.isValidElement(e))return!1;const n=e.props;return"value"in n&&"label"in n})),m=d?h.findIndex((e=>e.props.value===d)):0,[p,_]=(0,r.useState)(-1!==m?h[m].props.value:null),g=h.map((e=>({value:e.props.value,label:e.props.label})));return(0,u.jsxs)("div",{className:(0,t.A)("tabs-container",i,s),children:[(0,u.jsx)("div",{role:"tablist","aria-orientation":"horizontal",className:o,children:g.map((({value:e,label:n})=>(0,u.jsx)("button",{role:"tab","aria-selected":p===e,className:(0,t.A)(a,p===e&&l),onClick:()=>(e=>{_(e)})(e),children:n},e)))}),(0,u.jsx)("div",{className:c,children:h.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:p!==e.props.value})))})]})}d.TabItem=function({children:e,hidden:n,className:s}){return(0,u.jsx)("div",{role:"tabpanel",className:(0,t.A)(a,s),hidden:n,children:e})};const h=d},7461:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>u,contentTitle:()=>c,default:()=>m,frontMatter:()=>l,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"development-approaches","title":"Development Approaches","description":"When building Ruby extensions with Rust and rb-sys, you have two main approaches to choose from:","source":"@site/docs/development-approaches.mdx","sourceDirName":".","slug":"/development-approaches","permalink":"/docs/development-approaches","draft":false,"unlisted":false,"editUrl":"https://github.com/oxidize-rb/rb-sys/tree/main/docsite/docs/development-approaches.mdx","tags":[],"version":"current","lastUpdatedBy":"Ian Ker-Seymer","lastUpdatedAt":1752632597000,"sidebarPosition":6,"frontMatter":{"id":"development-approaches","title":"Development Approaches","sidebar_position":6}}');var t=s(4848),i=s(8453),o=s(3779),a=s(1151);const l={id:"development-approaches",title:"Development Approaches",sidebar_position:6},c="Development Approaches",u={},d=[{value:"Direct rb-sys Usage",id:"direct-rb-sys-usage",level:2},{value:"When to Use Direct rb-sys",id:"when-to-use-direct-rb-sys",level:3},{value:"Example: Simple Extension with Direct rb-sys",id:"example-simple-extension-with-direct-rb-sys",level:3},{value:"Using rb_thread_call_without_gvl for Performance",id:"using-rb_thread_call_without_gvl-for-performance",level:3},{value:"How Direct rb-sys Works",id:"how-direct-rb-sys-works",level:3},{value:"Higher-level Wrappers (Magnus)",id:"higher-level-wrappers-magnus",level:2},{value:"When to Use Magnus",id:"when-to-use-magnus",level:3},{value:"Example: Simple Extension with Magnus",id:"example-simple-extension-with-magnus",level:3},{value:"How Magnus Works",id:"how-magnus-works",level:3},{value:"When to Choose Each Approach",id:"when-to-choose-each-approach",level:2},{value:"Mixing Approaches",id:"mixing-approaches",level:2},{value:"Enabling rb-sys Feature in Magnus",id:"enabling-rb-sys-feature-in-magnus",level:3},{value:"Common Mixing Patterns",id:"common-mixing-patterns",level:3},{value:"Real-World Examples",id:"real-world-examples",level:2},{value:"Blake3-Ruby (Direct rb-sys)",id:"blake3-ruby-direct-rb-sys",level:3},{value:"LZ4-Flex-RB (Mixed Approach)",id:"lz4-flex-rb-mixed-approach",level:3}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"development-approaches",children:"Development Approaches"})}),"\n",(0,t.jsx)(n.p,{children:"When building Ruby extensions with Rust and rb-sys, you have two main approaches to choose from:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Direct rb-sys usage"}),": Working directly with Ruby's C API through the rb-sys bindings"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Higher-level wrappers"}),": Using libraries like Magnus that build on top of rb-sys"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This chapter will help you understand when to use each approach and how to mix them when needed."}),"\n",(0,t.jsx)(n.h2,{id:"direct-rb-sys-usage",children:"Direct rb-sys Usage"}),"\n",(0,t.jsx)(n.p,{children:"The rb-sys crate provides low-level bindings to Ruby's C API. This approach gives you complete control over how your\nRust code interacts with Ruby."}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use-direct-rb-sys",children:"When to Use Direct rb-sys"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"When you need maximum control over Ruby VM interaction"}),"\n",(0,t.jsx)(n.li,{children:"For specialized extensions that need access to low-level Ruby internals"}),"\n",(0,t.jsx)(n.li,{children:"When performance is absolutely critical and you need to eliminate any overhead"}),"\n",(0,t.jsx)(n.li,{children:"When implementing functionality not yet covered by higher-level wrappers"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example-simple-extension-with-direct-rb-sys",children:"Example: Simple Extension with Direct rb-sys"}),"\n",(0,t.jsx)(n.p,{children:"Here's a simple example of a Ruby extension using direct rb-sys:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use rb_sys::{\n    rb_define_module, rb_define_module_function, rb_str_new_cstr,\n    rb_string_value_cstr, VALUE\n};\nuse std::ffi::CString;\nuse std::os::raw::c_char;\n\n// Helper macro for creating C strings\nmacro_rules! cstr {\n    ($s:expr) => {\n        concat!($s, "\\0").as_ptr() as *const c_char\n    };\n}\n\n// Reverse a string\nunsafe extern "C" fn reverse(_: VALUE, s: VALUE) -> VALUE {\n    let mut s_copy = s;\n    let c_str = rb_string_value_cstr(&mut s_copy);\n    let rust_str = match std::ffi::CStr::from_ptr(c_str).to_str() {\n        Ok(s) => s,\n        Err(_) => return rb_str_new_cstr(c"".as_ptr()),\n    };\n    let reversed = rust_str.chars().rev().collect::<String>();\n\n    let c_string = match CString::new(reversed) {\n        Ok(s) => s,\n        Err(_) => return rb_str_new_cstr(c"".as_ptr()),\n    };\n    rb_str_new_cstr(c_string.as_ptr())\n}\n\n// Module initialization function\n#[no_mangle]\npub extern "C" fn Init_string_utils() {\n    unsafe {\n        let module = rb_define_module(cstr!("StringUtils"));\n\n        rb_define_module_function(\n            module,\n            cstr!("reverse"),\n            Some(std::mem::transmute::<unsafe extern "C" fn(VALUE, VALUE) -> VALUE, _>(reverse)),\n            1,\n        );\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"using-rb_thread_call_without_gvl-for-performance",children:"Using rb_thread_call_without_gvl for Performance"}),"\n",(0,t.jsxs)(n.p,{children:["When performing computationally intensive operations, it's important to release Ruby's Global VM Lock (GVL) to allow\nother threads to run. The ",(0,t.jsx)(n.code,{children:"rb_thread_call_without_gvl"})," function provides this capability:"]}),"\n",(0,t.jsx)(o.A,{language:"rust",title:"Thread-Safe Operations without the GVL",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use magnus::{Error, Ruby, RString};\nuse rb_sys::rb_thread_call_without_gvl;\nuse std::{ffi::c_void, panic::{self, AssertUnwindSafe}, ptr::null_mut};\n\n/// Execute a function without holding the Global VM Lock (GVL).\n/// This allows other Ruby threads to run while performing CPU-intensive tasks.\n///\n/// # Safety\n///\n/// The passed function must not interact with the Ruby VM or Ruby objects\n/// as it runs without the GVL, which is required for safe Ruby operations.\n///\n/// # Returns\n///\n/// Returns the result of the function or a magnus::Error if the function panics.\npub fn nogvl<F, R>(func: F) -> Result<R, Error>\nwhere\n    F: FnOnce() -> R,\n    R: Send + \'static,\n{\n    struct CallbackData<F, R> {\n        func: Option<F>,\n        result: Option<Result<R, String>>, // Store either the result or a panic message\n    }\n\n    extern "C" fn call_without_gvl<F, R>(data: *mut c_void) -> *mut c_void\n    where\n        F: FnOnce() -> R,\n        R: Send + \'static,\n    {\n        // Safety: We know this pointer is valid because we just created it below\n        let data = unsafe { &mut *(data as *mut CallbackData<F, R>) };\n\n        // Use take() to move out of the Option, ensuring we don\'t try to run the function twice\n        if let Some(func) = data.func.take() {\n            // Use panic::catch_unwind to prevent Ruby process termination if the Rust code panics\n            match panic::catch_unwind(AssertUnwindSafe(func)) {\n                Ok(result) => data.result = Some(Ok(result)),\n                Err(panic_info) => {\n                    // Convert panic info to a string message\n                    let panic_msg = if let Some(s) = panic_info.downcast_ref::<&\'static str>() {\n                        s.to_string()\n                    } else if let Some(s) = panic_info.downcast_ref::<String>() {\n                        s.clone()\n                    } else {\n                        "Unknown panic occurred in Rust code".to_string()\n                    };\n\n                    data.result = Some(Err(panic_msg));\n                }\n            }\n        }\n\n        null_mut()\n    }\n\n    // Create a data structure to pass the function and receive the result\n    let mut data = CallbackData {\n        func: Some(func),\n        result: None,\n    };\n\n    unsafe {\n        // Release the GVL and call our function\n        rb_thread_call_without_gvl(\n            Some(call_without_gvl::<F, R>),\n            &mut data as *mut _ as *mut c_void,\n            None,  // No unblock function\n            null_mut(),\n        );\n    }\n\n    // Extract the result or create an error if the function failed\n    match data.result {\n        Some(Ok(result)) => Ok(result),\n        Some(Err(panic_msg)) => {\n            // Convert the panic message to a Ruby RuntimeError\n            let ruby = unsafe { Ruby::get_unchecked() };\n            Err(Error::new(\n                ruby.exception_runtime_error(),\n                format!("Rust panic in nogvl: {}", panic_msg)\n            ))\n        },\n        None => {\n            // This should never happen if the callback runs, but handle it anyway\n            let ruby = unsafe { Ruby::get_unchecked() };\n            Err(Error::new(\n                ruby.exception_runtime_error(),\n                "nogvl function was not executed"\n            ))\n        }\n    }\n}\n'})})}),"\n",(0,t.jsx)(n.h3,{id:"how-direct-rb-sys-works",children:"How Direct rb-sys Works"}),"\n",(0,t.jsx)(n.p,{children:"When using rb-sys directly:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["You define C-compatible functions with the ",(0,t.jsx)(n.code,{children:'extern "C"'})," calling convention"]}),"\n",(0,t.jsxs)(n.li,{children:["You manually convert between Ruby's ",(0,t.jsx)(n.code,{children:"VALUE"})," type and Rust types"]}),"\n",(0,t.jsx)(n.li,{children:"You're responsible for memory management and type safety"}),"\n",(0,t.jsxs)(n.li,{children:["You must use the ",(0,t.jsx)(n.code,{children:"#[no_mangle]"})," attribute on the initialization function so Ruby can find it"]}),"\n",(0,t.jsx)(n.li,{children:"All interactions with Ruby data happen through raw pointers and unsafe code"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"higher-level-wrappers-magnus",children:"Higher-level Wrappers (Magnus)"}),"\n",(0,t.jsx)(n.p,{children:"Magnus provides a more ergonomic, Rust-like API on top of rb-sys. It handles many of the unsafe aspects of Ruby\nintegration for you."}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use-magnus",children:"When to Use Magnus"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"For most standard Ruby extensions where ease of development is important"}),"\n",(0,t.jsx)(n.li,{children:"When you want to avoid writing unsafe code"}),"\n",(0,t.jsx)(n.li,{children:"When you want idiomatic Rust error handling"}),"\n",(0,t.jsx)(n.li,{children:"For extensions with complex type conversions"}),"\n",(0,t.jsx)(n.li,{children:"When working with Ruby classes and objects in an object-oriented way"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example-simple-extension-with-magnus",children:"Example: Simple Extension with Magnus"}),"\n",(0,t.jsx)(n.p,{children:"Let's look at a simple example using Magnus, based on real-world usage patterns:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use magnus::{function, prelude::*, Error, Ruby};\n\nfn hello(subject: String) -> String {\n    format!("Hello from Rust, {subject}!")\n}\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let module = ruby.define_module("StringUtils")?;\n    module.define_singleton_method("hello", function!(hello, 1))?;\n    Ok(())\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Looking at a more complex example from a real-world project (lz4-flex-rb):"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use magnus::{function, prelude::*, Error, RModule, Ruby, RString};\n\n// Placeholder functions for the example\nfn compress(input: RString) -> Result<RString, Error> {\n    // Compression implementation would go here\n    Ok(input)\n}\n\nfn decompress(input: RString) -> Result<RString, Error> {\n    // Decompression implementation would go here\n    Ok(input)\n}\n\nfn compress_varint(input: RString) -> Result<RString, Error> {\n    // VarInt compression implementation would go here\n    Ok(input)\n}\n\nfn decompress_varint(input: RString) -> Result<RString, Error> {\n    // VarInt decompression implementation would go here\n    Ok(input)\n}\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let module = ruby.define_module("Lz4Flex")?;\n\n    // Define error classes\n    let base_error = module.define_error("Error", magnus::exception::standard_error())?;\n    let _ = module.define_error("EncodeError", base_error)?;\n    let _ = module.define_error("DecodeError", base_error)?;\n\n    // Define methods\n    module.define_singleton_method("compress", function!(compress, 1))?;\n    module.define_singleton_method("decompress", function!(decompress, 1))?;\n\n    // Define aliases\n    module.singleton_class()?.define_alias("deflate", "compress")?;\n    module.singleton_class()?.define_alias("inflate", "decompress")?;\n\n    // Define nested module\n    let varint_module = module.define_module("VarInt")?;\n    varint_module.define_singleton_method("compress", function!(compress_varint, 1))?;\n    varint_module.define_singleton_method("decompress", function!(decompress_varint, 1))?;\n\n    Ok(())\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"how-magnus-works",children:"How Magnus Works"}),"\n",(0,t.jsx)(n.p,{children:"Magnus builds on top of rb-sys and provides:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Automatic type conversions between Ruby and Rust"}),"\n",(0,t.jsxs)(n.li,{children:["Rust-like error handling with ",(0,t.jsx)(n.code,{children:"Result"})," types"]}),"\n",(0,t.jsx)(n.li,{children:"Memory safety through RAII patterns"}),"\n",(0,t.jsx)(n.li,{children:"More ergonomic APIs for defining modules, classes, and methods"}),"\n",(0,t.jsx)(n.li,{children:"A more familiar development experience for Rust programmers"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"when-to-choose-each-approach",children:"When to Choose Each Approach"}),"\n",(0,t.jsx)(a.A,{rubyTitle:"Approaches Comparison",rustTitle:"When to Choose Each",ruby:"\n```\nDirect rb-sys:\n\u2705 Maximum performance\n\u2705 Low-level Ruby VM control\n\u2705 Fine-grained GVL management\n\u2705 Version-specific behavior\n\n\u274c Lots of unsafe code\n\u274c Manual memory management\n\u274c More verbose type conversions\n\u274c Steeper learning curve\n```\n",rust:"\n```\nMagnus Wrapper:\n\u2705 Higher developer productivity\n\u2705 Better memory safety\n\u2705 Ergonomic Ruby class integration\n\u2705 Idiomatic Rust error handling\n\n\u274c Small performance overhead\n\u274c Less control over Ruby internals\n\u274c Slightly higher learning curve for Ruby devs\n\u274c Fewer GVL optimization opportunities\n```\n"}),"\n",(0,t.jsx)(n.h2,{id:"mixing-approaches",children:"Mixing Approaches"}),"\n",(0,t.jsx)(n.p,{children:"You can also mix the two approaches when appropriate. Magnus provides access to the underlying rb-sys functionality when\nneeded:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use magnus::{function, prelude::*, Error, Ruby, value::ReprValue, IntoValue};\nuse std::os::raw::c_char;\n\nfn high_level() -> String {\n    "High level".to_string()\n}\n\n// Helper macro for C strings\nmacro_rules! cstr {\n    ($s:expr) => {\n        concat!($s, "\\0").as_ptr() as *const c_char\n    };\n}\n\nunsafe extern "C" fn low_level(_: rb_sys::VALUE) -> rb_sys::VALUE {\n    // Direct rb-sys implementation\n    let c_string = match std::ffi::CString::new("Low level") {\n        Ok(s) => s,\n        Err(_) => return rb_sys::rb_str_new_cstr(c"".as_ptr()),\n    };\n    rb_sys::rb_str_new_cstr(c_string.as_ptr())\n}\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let module = ruby.define_module("MixedExample")?;\n\n    // Use Magnus for most things\n    module.define_singleton_method("high_level", function!(high_level, 0))?;\n\n    // Use rb-sys directly for special cases\n    unsafe {\n        rb_sys::rb_define_module_function(\n            unsafe { std::mem::transmute::<_, rb_sys::VALUE>(module.as_value()) },\n            cstr!("low_level"),\n            Some(std::mem::transmute::<unsafe extern "C" fn(rb_sys::VALUE) -> rb_sys::VALUE, _>(low_level)),\n            0,\n        );\n    }\n\n    Ok(())\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"enabling-rb-sys-feature-in-magnus",children:"Enabling rb-sys Feature in Magnus"}),"\n",(0,t.jsxs)(n.p,{children:["To access rb-sys through Magnus, enable the ",(0,t.jsx)(n.code,{children:"rb-sys"})," feature:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-toml",children:'# Cargo.toml\n[dependencies]\nmagnus = { version = "0.7", features = ["rb-sys"] }\n'})}),"\n",(0,t.jsx)(n.h3,{id:"common-mixing-patterns",children:"Common Mixing Patterns"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use Magnus for most functionality, rb-sys for specific optimizations"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Define your public API using Magnus for safety and ease"}),"\n",(0,t.jsxs)(n.li,{children:["Drop down to rb-sys in critical performance paths, especially when using ",(0,t.jsx)(n.code,{children:"nogvl"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use rb-sys for core functionality, Magnus for complex conversions"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Build core functionality with rb-sys for maximum control"}),"\n",(0,t.jsx)(n.li,{children:"Use Magnus for handling complex Ruby objects or collections"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Start with Magnus, optimize with rb-sys over time"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Begin development with Magnus for rapid progress"}),"\n",(0,t.jsx)(n.li,{children:"Profile your code and replace hot paths with direct rb-sys"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"real-world-examples",children:"Real-World Examples"}),"\n",(0,t.jsx)(n.p,{children:"Let's look at how real projects decide between these approaches:"}),"\n",(0,t.jsx)(n.h3,{id:"blake3-ruby-direct-rb-sys",children:"Blake3-Ruby (Direct rb-sys)"}),"\n",(0,t.jsx)(n.p,{children:"Blake3-Ruby is a cryptographic hashing library that uses direct rb-sys to achieve maximum performance:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// Based on blake3-ruby - simplified example showing direct rb-sys usage\nuse rb_sys::{\n    rb_define_module, rb_define_module_function,\n    rb_str_new, VALUE, RSTRING_LEN, RSTRING_PTR,\n};\nuse std::os::raw::c_char;\n\n// Helper macro for creating C strings\nmacro_rules! cstr {\n    ($s:expr) => {\n        concat!($s, "\\0").as_ptr() as *const c_char\n    };\n}\n\n#[no_mangle]\npub extern "C" fn Init_digest_ext() {\n    unsafe {\n        // Create module hierarchy\n        let digest_module = rb_define_module(cstr!("Digest"));\n\n        // Define methods directly using rb-sys for maximum performance\n        rb_define_module_function(\n            digest_module,\n            cstr!("simple_hash"),\n            Some(std::mem::transmute::<unsafe extern "C" fn(VALUE, VALUE) -> VALUE, _>(rb_simple_hash)),\n            1,\n        );\n    }\n}\n\nunsafe extern "C" fn rb_simple_hash(_klass: VALUE, string: VALUE) -> VALUE {\n    // Extract data from Ruby VALUE\n    let data_ptr = RSTRING_PTR(string) as *const u8;\n    let data_len = RSTRING_LEN(string) as usize;\n    let data_slice = std::slice::from_raw_parts(data_ptr, data_len);\n\n    // Simple hash calculation (just for demonstration)\n    let mut hash: u32 = 0;\n    for &byte in data_slice {\n        hash = hash.wrapping_mul(31).wrapping_add(byte as u32);\n    }\n    \n    // Convert hash to string\n    let hash_str = format!("{:08x}", hash);\n    let hash_bytes = hash_str.as_bytes();\n\n    // Return result as Ruby string\n    rb_str_new(hash_bytes.as_ptr() as *const c_char, hash_bytes.len() as i64)\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"lz4-flex-rb-mixed-approach",children:"LZ4-Flex-RB (Mixed Approach)"}),"\n",(0,t.jsx)(n.p,{children:"The LZ4-Flex-RB gem demonstrates a more sophisticated approach mixing Magnus with direct rb-sys calls:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// Based on lz4-flex-rb\nuse magnus::{function, prelude::*, Error, RModule, Ruby, RString, value::ReprValue, IntoValue};\nuse rb_sys::{rb_str_locktmp, rb_str_unlocktmp, RSTRING_PTR, RSTRING_LEN};\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let module = ruby.define_module("Lz4Flex")?;\n\n    // High-level API using Magnus\n    module.define_singleton_method("compress", function!(compress, 1))?;\n    module.define_singleton_method("decompress", function!(decompress, 1))?;\n\n    Ok(())\n}\n\n// Functions that mix high-level Magnus with low-level rb-sys\nfn compress(input: RString) -> Result<RString, Error> {\n    let input_locked = LockedRString::new(input);\n    let bufsize = lz4_flex::block::get_maximum_output_size(input_locked.as_slice().len());\n    \n    // Create output buffer\n    let mut output_vec = vec![0u8; bufsize];\n\n    // Compress the data\n    let outsize = lz4_flex::block::compress_into(\n        input_locked.as_slice(), \n        &mut output_vec\n    ).map_err(|e| Error::new(magnus::exception::standard_error(), e.to_string()))?;\n\n    // Resize to actual output size\n    output_vec.truncate(outsize);\n    \n    // Convert to Ruby string\n    let ruby = unsafe { magnus::Ruby::get_unchecked() };\n    Ok(RString::from_slice(&output_vec))\n}\n\nfn decompress(input: RString) -> Result<RString, Error> {\n    let input_locked = LockedRString::new(input);\n    \n    // Decompress the data (need to provide max output size)\n    let max_size = input_locked.as_slice().len() * 20; // Conservative estimate\n    let decompressed = lz4_flex::block::decompress(input_locked.as_slice(), max_size)\n        .map_err(|e| Error::new(magnus::exception::standard_error(), e.to_string()))?;\n    \n    // Convert to Ruby string\n    let ruby = unsafe { magnus::Ruby::get_unchecked() };\n    Ok(RString::from_slice(&decompressed))\n}\n\n// Helper for locked RString (uses rb-sys directly)\nstruct LockedRString(RString);\n\nimpl LockedRString {\n    fn new(string: RString) -> Self {\n        unsafe { rb_str_locktmp(std::mem::transmute::<_, rb_sys::VALUE>(string.as_value())) };\n        Self(string)\n    }\n\n    fn as_slice(&self) -> &[u8] {\n        unsafe {\n            let ptr = RSTRING_PTR(std::mem::transmute::<_, rb_sys::VALUE>(self.0.as_value())) as *const u8;\n            let len = RSTRING_LEN(std::mem::transmute::<_, rb_sys::VALUE>(self.0.as_value())) as usize;\n            std::slice::from_raw_parts(ptr, len)\n        }\n    }\n}\n\nimpl Drop for LockedRString {\n    fn drop(&mut self) {\n        unsafe { rb_str_unlocktmp(std::mem::transmute::<_, rb_sys::VALUE>(self.0.as_value())) };\n    }\n}\n'})})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var r=s(6540);const t={},i=r.createContext(t);function o(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(i.Provider,{value:n},e.children)}},9365:(e,n,s)=>{s.d(n,{A:()=>o});s(6540);var r=s(4164);const t={tabItem:"tabItem_Ymn6"};var i=s(4848);function o({children:e,hidden:n,className:s}){return(0,i.jsx)("div",{role:"tabpanel",className:(0,r.A)(t.tabItem,s),hidden:n,children:e})}}}]);