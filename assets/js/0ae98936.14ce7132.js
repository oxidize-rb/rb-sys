"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[2338],{1151:(e,n,t)=>{t.d(n,{A:()=>a});t(6540);const s={codeComparison:"codeComparison_cfCm",codeBlock:"codeBlock_bE1R",languageIndicator:"languageIndicator_Wjf7",rubyIndicator:"rubyIndicator_IEF1",rustIndicator:"rustIndicator_ZrAT"};var r=t(4568),i=t(9365),l=t(1028),o=t(4848);function a({ruby:e,rust:n,rubyTitle:t="Ruby",rustTitle:a="Rust",rubyLanguage:u="ruby",rustLanguage:d="rust"}){return(0,o.jsx)("div",{className:s.codeComparison,children:(0,o.jsxs)(r.A,{children:[(0,o.jsx)(i.A,{value:"ruby",label:t,default:!0,children:(0,o.jsx)("div",{className:s.codeBlock,children:(0,o.jsx)(l.A,{language:u,children:e})})}),(0,o.jsx)(i.A,{value:"rust",label:a,children:(0,o.jsx)("div",{className:s.codeBlock,children:(0,o.jsx)(l.A,{language:d,children:n})})})]})})}},3011:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>u,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"classes-and-modules","title":"Ruby Classes and Modules","description":"This guide explains how to define and work with Ruby classes and modules from Rust. It covers approaches for creating Ruby objects, defining methods, and organizing code.","source":"@site/docs/classes-and-modules.mdx","sourceDirName":".","slug":"/classes-and-modules","permalink":"/docs/classes-and-modules","draft":false,"unlisted":false,"editUrl":"https://github.com/oxidize-rb/rb-sys/tree/main/docsite/docs/classes-and-modules.mdx","tags":[],"version":"current","lastUpdatedBy":"Xiaoxi Pang","lastUpdatedAt":1762877000000,"sidebarPosition":10,"frontMatter":{"id":"classes-and-modules","title":"Ruby Classes and Modules","sidebar_position":10},"sidebar":"docsSidebar","previous":{"title":"Working with Ruby Objects","permalink":"/docs/working-with-ruby-objects"},"next":{"title":"Error Handling in Rust Ruby Extensions","permalink":"/docs/error-handling"}}');var r=t(4848),i=t(8453),l=t(3779),o=t(1151);const a={id:"classes-and-modules",title:"Ruby Classes and Modules",sidebar_position:10},u="Ruby Classes and Modules",d={},c=[{value:"Defining Modules",id:"defining-modules",level:2},{value:"Creating a Basic Module",id:"creating-a-basic-module",level:3},{value:"Module Constants",id:"module-constants",level:3},{value:"Using Module Attributes",id:"using-module-attributes",level:3},{value:"Creating Ruby Classes from Rust Structs",id:"creating-ruby-classes-from-rust-structs",level:2},{value:"Using the TypedData Trait (Full Control)",id:"using-the-typeddata-trait-full-control",level:3},{value:"Using the Wrap Macro (Simplified Approach)",id:"using-the-wrap-macro-simplified-approach",level:3},{value:"Using RefCell for Mutable Rust Objects",id:"using-refcell-for-mutable-rust-objects",level:3},{value:"Implementing Ruby Methods",id:"implementing-ruby-methods",level:2},{value:"Function vs Method Macros",id:"function-vs-method-macros",level:3},{value:"Method Signature Patterns",id:"method-signature-patterns",level:3},{value:"Class Inheritance and Mixins",id:"class-inheritance-and-mixins",level:2},{value:"Creating a Subclass",id:"creating-a-subclass",level:3},{value:"Including Modules (Mixins)",id:"including-modules-mixins",level:3},{value:"Working with Singleton Methods",id:"working-with-singleton-methods",level:2},{value:"Defining a Class with Both Instance and Singleton Methods",id:"defining-a-class-with-both-instance-and-singleton-methods",level:3},{value:"Attaching Methods to a Specific Object (True Singleton Methods)",id:"attaching-methods-to-a-specific-object-true-singleton-methods",level:3},{value:"Best Practices",id:"best-practices",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"ruby-classes-and-modules",children:"Ruby Classes and Modules"})}),"\n",(0,r.jsx)(n.p,{children:"This guide explains how to define and work with Ruby classes and modules from Rust. It covers approaches for creating Ruby objects, defining methods, and organizing code."}),"\n",(0,r.jsx)(n.h2,{id:"defining-modules",children:"Defining Modules"}),"\n",(0,r.jsx)(n.p,{children:"Modules in Ruby are used to namespace functionality and define mixins. Here's how to create and use modules in your Rust\nextension:"}),"\n",(0,r.jsx)(n.h3,{id:"creating-a-basic-module",children:"Creating a Basic Module"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use magnus::{function, prelude::*, Error, Ruby};\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    // Create a top-level module\n    let module = ruby.define_module("MyExtension")?;\n\n    // Define a method on the module\n    module.define_singleton_method("version", function!(|| "1.0.0", 0))?;\n\n    // Create a nested module\n    let utils = module.define_module("Utils")?;\n    utils.define_singleton_method("helper", function!(|| "Helper function", 0))?;\n\n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"This creates a module structure that would look like this in Ruby:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",children:'module MyExtension\n  def self.version\n    "1.0.0"\n  end\n\n  module Utils\n    def self.helper\n      "Helper function"\n    end\n  end\nend\n'})}),"\n",(0,r.jsx)(n.h3,{id:"module-constants",children:"Module Constants"}),"\n",(0,r.jsx)(n.p,{children:"You can define constants in your modules:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use magnus::{Module, Ruby, Error, Symbol};\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let module = ruby.define_module("Config")?;\n\n    // Define constants\n    module.const_set("VERSION", "1.0.0")?;\n    module.const_set("MAX_CONNECTIONS", 100)?;\n    module.const_set("DEFAULT_MODE", Symbol::new("production"))?;\n\n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"using-module-attributes",children:"Using Module Attributes"}),"\n",(0,r.jsx)(n.p,{children:"To maintain module state, a common pattern is storing attributes in the module itself:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use magnus::{function, prelude::*, Error, Ruby};\nuse std::sync::Mutex;\nuse std::sync::atomic::{AtomicUsize, Ordering};\n\n// Store a counter in a static atomic\nstatic REQUEST_COUNT: AtomicUsize = AtomicUsize::new(0);\n\n// Store configuration in a mutex\nstatic CONFIG: Mutex<Option<String>> = Mutex::new(None);\n\nfn increment_counter() -> usize {\n    REQUEST_COUNT.fetch_add(1, Ordering::SeqCst)\n}\n\nfn get_config() -> Result<String, Error> {\n    match CONFIG.lock()\n        .map_err(|_| Error::new(magnus::exception::runtime_error(), "Failed to acquire lock"))?\n        .clone() {\n        Some(config) => Ok(config),\n        None => Ok("default".to_string()),\n    }\n}\n\nfn set_config(value: String) -> Result<String, Error> {\n    let mut config = CONFIG.lock()\n        .map_err(|_| Error::new(magnus::exception::runtime_error(), "Failed to acquire lock"))?;\n    *config = Some(value.clone());\n    Ok(value)\n}\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let module = ruby.define_module("Stats")?;\n\n    module.define_singleton_method("increment", function!(increment_counter, 0))?;\n    module.define_singleton_method("count", function!(|| REQUEST_COUNT.load(Ordering::SeqCst), 0))?;\n\n    // Configuration methods\n    module.define_singleton_method("config", function!(get_config, 0))?;\n    module.define_singleton_method("config=", function!(set_config, 1))?;\n\n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"creating-ruby-classes-from-rust-structs",children:"Creating Ruby Classes from Rust Structs"}),"\n",(0,r.jsx)(n.p,{children:"Magnus provides several ways to define Ruby classes that wrap Rust structures. The approach you choose depends on your\nspecific needs."}),"\n",(0,r.jsx)(n.h3,{id:"using-the-typeddata-trait-full-control",children:"Using the TypedData Trait (Full Control)"}),"\n",(0,r.jsx)(n.p,{children:"For full control over memory management and Ruby integration:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use magnus::{function, method, prelude::*, DataTypeFunctions, TypedData, Error, Ruby};\n\n// Define a Rust struct\n#[derive(Debug, TypedData)]\n#[magnus(class = "MyExtension::Point", free_immediately, size)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\n// Implement required trait\nimpl DataTypeFunctions for Point {}\n\n// Implement methods\nimpl Point {\n    fn new(x: f64, y: f64) -> Self {\n        Point { x, y }\n    }\n\n    fn x(&self) -> f64 {\n        self.x\n    }\n\n    fn y(&self) -> f64 {\n        self.y\n    }\n\n    fn distance(&self, other: &Point) -> f64 {\n        ((self.x - other.x).powi(2) + (self.y - other.y).powi(2)).sqrt()\n    }\n\n    fn to_s(&self) -> String {\n        format!("Point({}, {})", self.x, self.y)\n    }\n}\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let module = ruby.define_module("MyExtension")?;\n    let class = module.define_class("Point", ruby.class_object())?;\n\n    // Define the constructor\n    class.define_singleton_method("new", function!(|x: f64, y: f64| {\n        Point::new(x, y)\n    }, 2))?;\n\n    // Define instance methods\n    class.define_method("x", method!(Point::x, 0))?;\n    class.define_method("y", method!(Point::y, 0))?;\n    class.define_method("distance", method!(Point::distance, 1))?;\n    class.define_method("to_s", method!(Point::to_s, 0))?;\n\n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"using-the-wrap-macro-simplified-approach",children:"Using the Wrap Macro (Simplified Approach)"}),"\n",(0,r.jsx)(n.p,{children:"For a simpler approach with less boilerplate:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use magnus::{function, method, prelude::*, Error, Ruby};\n\n// Define a Rust struct\n#[magnus::wrap(class = "MyExtension::Rectangle")]\nstruct Rectangle {\n    width: f64,\n    height: f64,\n}\n\n// Use the wrap macro to handle the Ruby class mapping\nimpl Rectangle {\n    // Constructor\n    fn new(width: f64, height: f64) -> Self {\n        Rectangle { width, height }\n    }\n\n    // Instance methods\n    fn width(&self) -> f64 {\n        self.width\n    }\n\n    fn height(&self) -> f64 {\n        self.height\n    }\n\n    fn area(&self) -> f64 {\n        self.width * self.height\n    }\n\n    fn perimeter(&self) -> f64 {\n        2.0 * (self.width + self.height)\n    }\n}\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let module = ruby.define_module("MyExtension")?;\n    let class = module.define_class("Rectangle", ruby.class_object())?;\n\n    // Register class methods and instance methods\n    class.define_singleton_method("new", function!(Rectangle::new, 2))?;\n    class.define_method("width", method!(Rectangle::width, 0))?;\n    class.define_method("height", method!(Rectangle::height, 0))?;\n    class.define_method("area", method!(Rectangle::area, 0))?;\n    class.define_method("perimeter", method!(Rectangle::perimeter, 0))?;\n\n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"using-refcell-for-mutable-rust-objects",children:"Using RefCell for Mutable Rust Objects"}),"\n",(0,r.jsx)(n.p,{children:"For Ruby objects that need interior mutability:"}),"\n",(0,r.jsx)(l.A,{language:"rust",title:"Interior Mutability with RefCell",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use std::cell::RefCell;\nuse magnus::{Error};\n\nstruct Counter {\n    count: usize,\n}\n\n#[magnus::wrap(class = "MyExtension::Counter")]\nstruct MutCounter(RefCell<Counter>);\n\nimpl MutCounter {\n    fn new(initial: usize) -> Self {\n        MutCounter(RefCell::new(Counter { count: initial }))\n    }\n\n    fn count(&self) -> usize {\n        self.0.borrow().count\n    }\n\n    fn increment(&self) -> usize {\n        let mut counter = self.0.borrow_mut();\n        counter.count += 1;\n        counter.count\n    }\n\n    fn increment_by(&self, n: usize) -> usize {\n        let mut counter = self.0.borrow_mut();\n        counter.count += n;\n        counter.count\n    }\n\n    // CORRECT pattern - complete the first borrow before starting the second\n    fn good_increment_method(&self) -> Result<usize, Error> {\n        // Copy the value first\n        let current_count = self.0.borrow().count;\n\n        // Then the first borrow is dropped and we can borrow_mut safely\n        if current_count > 10 {\n            self.0.borrow_mut().count += 100;\n        } else {\n            self.0.borrow_mut().count += 1;\n        }\n\n        Ok(self.0.borrow().count)\n    }\n}\n'})})}),"\n",(0,r.jsx)(n.h2,{id:"implementing-ruby-methods",children:"Implementing Ruby Methods"}),"\n",(0,r.jsx)(n.p,{children:"Magnus provides flexible macros to help define methods with various signatures."}),"\n",(0,r.jsx)(n.h3,{id:"function-vs-method-macros",children:"Function vs Method Macros"}),"\n",(0,r.jsx)(n.p,{children:"Magnus provides two primary macros for defining callable Ruby code:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"function!"})," - For singleton/class methods and module functions"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"method!"})," - For instance methods when you need access to the Rust object (",(0,r.jsx)(n.code,{children:"&self"}),")"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Here's how to use each:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use magnus::{function, method, prelude::*, Error, Ruby};\n\n#[magnus::wrap(class = "Calculator")]\nstruct Calculator {}\n\nimpl Calculator {\n    // Constructor - a class method\n    fn new() -> Self {\n        Calculator {}\n    }\n\n    // Regular instance method that doesn\'t raise exceptions\n    fn add(&self, a: i64, b: i64) -> i64 {\n        a + b\n    }\n\n    // Method that needs the Ruby interpreter to raise an exception\n    fn divide(ruby: &Ruby, _rb_self: &Self, a: i64, b: i64) -> Result<i64, Error> {\n        if b == 0 {\n            return Err(Error::new(\n                ruby.exception_zero_div_error(),\n                "Division by zero"\n            ));\n        }\n        Ok(a / b)\n    }\n\n    // Class method that doesn\'t need a Calculator instance\n    fn version() -> &\'static str {\n        "1.0.0"\n    }\n}\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let class = ruby.define_class("Calculator", ruby.class_object())?;\n\n    // Register the constructor with function!\n    class.define_singleton_method("new", function!(Calculator::new, 0))?;\n\n    // Register a class method with function!\n    class.define_singleton_method("version", function!(Calculator::version, 0))?;\n\n    // Register instance methods with method!\n    class.define_method("add", method!(Calculator::add, 2))?;\n    class.define_method("divide", method!(Calculator::divide, 2))?;\n\n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"method-signature-patterns",children:"Method Signature Patterns"}),"\n",(0,r.jsx)(n.p,{children:"There are several common method signature patterns depending on what your method needs to do:"}),"\n",(0,r.jsx)(o.A,{rubyTitle:"Ruby Method Interface",rustTitle:"Rust Implementation",ruby:'\n```ruby\n# Basic method with no exceptions\ndef add(a, b)\na + b\nend\n\n# Method that raises exceptions\ndef divide(a, b)\nraise ZeroDivisionError, "Division by zero" if b == 0\na / b\nend\n\n# Method that takes a block\ndef with_retries(max_retries)\nretries = 0\nbegin\n  yield\nrescue => e\n  if retries < max_retries\n    retries += 1\n    retry\n  else\n    raise e\n  end\nend\nend\n```\n',rust:'\n```rust\n// Basic Method (no Ruby access, no exceptions)\nfn add(&self, a: i64, b: i64) -> i64 {\n  a + b\n}\n\n// Method that Raises Exceptions\nfn divide(ruby: &Ruby, _rb_self: &Self, a: i64, b: i64) -> Result<i64, Error> {\n  if b == 0 {\n      return Err(Error::new(\n          ruby.exception_zero_div_error(),\n          "Division by zero"\n      ));\n  }\n  Ok(a / b)\n}\n\n// Method with Ruby Block\nfn with_retries(ruby: &Ruby, _rb_self: &Self, max_retries: usize, block: Proc) -> Result<Value, Error> {\n  let mut retries = 0;\n  loop {\n      match block.call(ruby, ()) {\n          Ok(result) => return Ok(result),\n          Err(e) if retries < max_retries => {\n              retries += 1;\n              // Maybe backoff or log error\n          },\n          Err(e) => return Err(e),\n      }\n  }\n}\n```\n'}),"\n",(0,r.jsx)(n.h2,{id:"class-inheritance-and-mixins",children:"Class Inheritance and Mixins"}),"\n",(0,r.jsx)(n.p,{children:"Ruby supports a rich object model with single inheritance and multiple module inclusion. Magnus allows you to replicate\nthis model in your Rust extension."}),"\n",(0,r.jsx)(n.h3,{id:"creating-a-subclass",children:"Creating a Subclass"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use magnus::{method, prelude::*, Error, Ruby, RArray, Value};\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    // Get the parent class (Ruby\'s built-in Array)\n    let array_class = ruby.class_array();\n\n    // Create a subclass\n    let sorted_array = ruby.define_class("SortedArray", array_class)?;\n\n    // Override the << (push) method to keep the array sorted\n    sorted_array.define_method("<<", method!(|rb_self: Value, item: Value| {\n        let array = RArray::from_value(rb_self)\n            .ok_or_else(|| Error::new(magnus::exception::type_error(), "not an array"))?;\n        array.push(item)?;\n\n        // Call sort! to keep the array sorted\n        let _: Value = array.funcall("sort!", ())?;\n\n        Ok(rb_self) // Return self for method chaining\n    }, 1))?;\n\n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"including-modules-mixins",children:"Including Modules (Mixins)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use magnus::{RModule, method, function, prelude::*, Error, Ruby, Value, RObject, TryConvert, value::ReprValue};\nuse std::cmp::Ordering;\n\nfn make_comparable(ruby: &Ruby) -> Result<RModule, Error> {\n    let module = ruby.define_module("MyComparable")?;\n\n    // Define methods for the module\n    module.define_method("<=>", method!(|ruby: &Ruby, rb_self: Value, other: Value| -> Result<Value, Error> {\n        // Implementation of the spaceship operator for comparison\n        let self_num: Result<i64, _> = TryConvert::try_convert(rb_self);\n        let other_num: Result<i64, _> = TryConvert::try_convert(other);\n\n        match (self_num, other_num) {\n            (Ok(a), Ok(b)) => Ok(ruby.integer_from_i64(match a.cmp(&b) {\n                Ordering::Less => -1,\n                Ordering::Equal => 0,\n                Ordering::Greater => 1,\n            }).as_value()),\n            _ => Ok(ruby.qnil().as_value()),\n        }\n    }, 1))?;\n\n    // Define methods that depend on <=>\n    module.define_method("==", method!(|_ruby: &Ruby, rb_self: Value, other: Value| -> Result<bool, Error> {\n        let result: Value = rb_self.funcall("<=>", (other,))?;\n        if result.is_nil() {\n            Ok(false)\n        } else {\n            let num: i64 = TryConvert::try_convert(result)?;\n            Ok(num == 0)\n        }\n    }, 1))?;\n\n    module.define_method(">", method!(|_ruby: &Ruby, rb_self: Value, other: Value| -> Result<bool, Error> {\n        let result: Value = rb_self.funcall("<=>", (other,))?;\n        if result.is_nil() {\n            Ok(false)\n        } else {\n            let num: i64 = TryConvert::try_convert(result)?;\n            Ok(num > 0)\n        }\n    }, 1))?;\n\n    module.define_method("<", method!(|_ruby: &Ruby, rb_self: Value, other: Value| -> Result<bool, Error> {\n        let result: Value = rb_self.funcall("<=>", (other,))?;\n        if result.is_nil() {\n            Ok(false)\n        } else {\n            let num: i64 = TryConvert::try_convert(result)?;\n            Ok(num < 0)\n        }\n    }, 1))?;\n\n    Ok(module)\n}\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    // Create our module\n    let module = make_comparable(ruby)?;\n\n    // Create a class\n    let score = ruby.define_class("Score", ruby.class_object())?;\n\n    // Define methods\n    score.define_singleton_method("new", function!(|ruby: &Ruby, value: i64| -> Result<Value, Error> {\n        let score_class = ruby.class_object().const_get::<_, Value>("Score")?;\n        let obj = RObject::try_convert(score_class.funcall("new", ())?)?;\n        obj.ivar_set("@value", value)?;\n        Ok(obj.as_value())\n    }, 1))?;\n\n    score.define_method("value", method!(|ruby: &Ruby, rb_self: Value| -> Result<i64, Error> {\n        let obj = RObject::try_convert(rb_self)?;\n        obj.ivar_get::<_, i64>("@value")\n    }, 0))?;\n\n    // Define <=> for Score instances\n    score.define_method("<=>", method!(|ruby: &Ruby, rb_self: Value, other: Value| -> Result<Value, Error> {\n        let self_obj = RObject::try_convert(rb_self)?;\n        let self_value: i64 = self_obj.ivar_get::<_, i64>("@value")?;\n        \n        // Try to get value from other if it\'s a Score\n        if let Ok(other_score) = RObject::try_convert(other) {\n            if let Ok(other_value) = other_score.ivar_get::<_, i64>("@value") {\n                return Ok(ruby.integer_from_i64(match self_value.cmp(&other_value) {\n                    Ordering::Less => -1,\n                    Ordering::Equal => 0,\n                    Ordering::Greater => 1,\n                }).as_value());\n            }\n        }\n        \n        Ok(ruby.qnil().as_value())\n    }, 1))?;\n\n    // Include our module\n    score.include_module(module)?;\n\n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"working-with-singleton-methods",children:"Working with Singleton Methods"}),"\n",(0,r.jsx)(n.p,{children:"Singleton methods in Ruby are methods attached to individual objects, not to their class. The most common use is\ndefining class methods, but they can be applied to any object."}),"\n",(0,r.jsx)(n.h3,{id:"defining-a-class-with-both-instance-and-singleton-methods",children:"Defining a Class with Both Instance and Singleton Methods"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use magnus::{function, method, prelude::*, Error, Ruby, Value};\n\n#[magnus::wrap(class = "Logger")]\nstruct Logger {\n    level: String,\n}\n\nimpl Logger {\n    fn new(level: String) -> Self {\n        Logger { level }\n    }\n\n    fn log(&self, message: String) -> String {\n        format!("[{}] {}", self.level, message)\n    }\n\n    // Class methods (singleton methods)\n    fn default_level() -> &\'static str {\n        "INFO"\n    }\n\n    fn create_default(ruby: &Ruby) -> Result<Value, Error> {\n        let class = ruby.class_object().const_get::<_, Value>("Logger")?;\n        let default_level = Self::default_level();\n        class.funcall("new", (default_level,))\n    }\n}\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let class = ruby.define_class("Logger", ruby.class_object())?;\n\n    // Instance methods\n    class.define_singleton_method("new", function!(Logger::new, 1))?;\n    class.define_method("log", method!(Logger::log, 1))?;\n\n    // Class methods using function! macro\n    class.define_singleton_method("default_level", function!(Logger::default_level, 0))?;\n    class.define_singleton_method("create_default", function!(Logger::create_default, 0))?;\n\n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"attaching-methods-to-a-specific-object-true-singleton-methods",children:"Attaching Methods to a Specific Object (True Singleton Methods)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use magnus::{function, prelude::*, Error, Ruby, RObject};\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    // Create a single object\n    let config = ruby.eval::<RObject>("Object.new")?;\n\n    // Get the singleton class of the object\n    let singleton_class = config.singleton_class()?;\n\n    // Define singleton methods on the singleton class\n    singleton_class.define_method("get", function!(|| {\n        "Configuration value"\n    }, 0))?;\n\n    singleton_class.define_method("enabled?", function!(|| {\n        true\n    }, 0))?;\n\n    // Make it globally accessible\n    ruby.define_global_const("CONFIG", config)?;\n\n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"This creates an object that can be used in Ruby like:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",children:'CONFIG.get          # => "Configuration value"\nCONFIG.enabled?     # => true\nCONFIG.class        # => Object\n'})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use magnus macros for class definition"}),": The ",(0,r.jsx)(n.code,{children:"wrap"})," and ",(0,r.jsx)(n.code,{children:"TypedData"})," macros simplify class definition\nsignificantly."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Consistent naming"}),": Keep Ruby and Rust naming conventions consistent within their domains (snake_case for Ruby\nmethods, CamelCase for Ruby classes)."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Layer your API"}),": Consider providing both low-level and high-level APIs for complex functionality."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Document method signatures"}),": When using methods that can raise exceptions, document which exceptions can be\nraised."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"RefCell borrowing pattern"}),": Always release a ",(0,r.jsx)(n.code,{children:"borrow()"})," before calling ",(0,r.jsx)(n.code,{children:"borrow_mut()"})," by copying any needed\nvalues."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Method macro selection"}),": Use ",(0,r.jsx)(n.code,{children:"function!"})," for singleton methods and ",(0,r.jsx)(n.code,{children:"method!"})," for instance methods."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Include the Ruby parameter"}),": Always include ",(0,r.jsx)(n.code,{children:"ruby: &Ruby"})," in your method signature if your method might raise\nexceptions or interact with the Ruby runtime."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Reuse existing Ruby patterns"}),": When designing your API, follow existing Ruby conventions that users will already\nunderstand."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cache Ruby classes and modules"}),": Use ",(0,r.jsx)(n.code,{children:"Lazy"})," to cache frequently accessed classes and modules."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Maintain object hierarchy"}),": Properly use Ruby's inheritance and module system to organize your code."]}),"\n"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},3779:(e,n,t)=>{t.d(n,{A:()=>l});t(6540);const s={languageCallout:"languageCallout_VNpC",ruby:"ruby_iFYN",rust:"rust_PB7z",header:"header_itAP",icon:"icon_vHP_",title:"title_Bire",content:"content_ZrzH"};var r=t(4164),i=t(4848);function l({language:e,icon:n=!0,title:t,children:l}){const o=t||("ruby"===e?"Ruby":"Rust");return(0,i.jsxs)("div",{className:(0,r.A)(s.languageCallout,s[e]),children:[(0,i.jsxs)("div",{className:s.header,children:[n&&(0,i.jsx)("div",{className:s.icon,children:"ruby"===e?(0,i.jsxs)("svg",{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"1.5",height:"20",width:"20",children:[(0,i.jsx)("path",{d:"M6 3h12l4 6-10 12L2 9l4-6z",strokeLinejoin:"round"}),(0,i.jsx)("path",{d:"M12 21L2 9h20",strokeLinejoin:"round"})]}):(0,i.jsxs)("svg",{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"1.5",height:"20",width:"20",children:[(0,i.jsx)("circle",{cx:"12",cy:"12",r:"8"}),(0,i.jsx)("path",{d:"M12 4v2M12 18v2M4 12H6M18 12h2M6.34 6.34l1.42 1.42M16.24 16.24l1.42 1.42M6.34 17.66l1.42-1.42M16.24 7.76l1.42-1.42"}),(0,i.jsx)("path",{d:"M9 12a3 3 0 1 0 6 0 3 3 0 0 0-6 0z"})]})}),(0,i.jsx)("div",{className:s.title,children:o})]}),(0,i.jsx)("div",{className:s.content,children:l})]})}},4568:(e,n,t)=>{t.d(n,{A:()=>h});var s=t(6540),r=t(4164);const i="tabsContainer_MFXm",l="tabList_TRJ7",o="tabItem_hGfb",a="tabItemActive_HPJJ",u="tabContent_vyUe";var d=t(4848);function c(e){const{children:n,className:t,defaultValue:c}=e,h=s.Children.toArray(n).filter((e=>{if(!s.isValidElement(e))return!1;const n=e.props;return"value"in n&&"label"in n})),m=c?h.findIndex((e=>e.props.value===c)):0,[f,g]=(0,s.useState)(-1!==m?h[m].props.value:null),b=h.map((e=>({value:e.props.value,label:e.props.label})));return(0,d.jsxs)("div",{className:(0,r.A)("tabs-container",i,t),children:[(0,d.jsx)("div",{role:"tablist","aria-orientation":"horizontal",className:l,children:b.map((({value:e,label:n})=>(0,d.jsx)("button",{role:"tab","aria-selected":f===e,className:(0,r.A)(o,f===e&&a),onClick:()=>(e=>{g(e)})(e),children:n},e)))}),(0,d.jsx)("div",{className:u,children:h.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:f!==e.props.value})))})]})}c.TabItem=function({children:e,hidden:n,className:t}){return(0,d.jsx)("div",{role:"tabpanel",className:(0,r.A)(o,t),hidden:n,children:e})};const h=c},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>o});var s=t(6540);const r={},i=s.createContext(r);function l(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(i.Provider,{value:n},e.children)}},9365:(e,n,t)=>{t.d(n,{A:()=>l});t(6540);var s=t(4164);const r={tabItem:"tabItem_Ymn6"};var i=t(4848);function l({children:e,hidden:n,className:t}){return(0,i.jsx)("div",{role:"tabpanel",className:(0,s.A)(r.tabItem,t),hidden:n,children:e})}}}]);