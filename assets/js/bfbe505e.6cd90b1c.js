"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[505],{3355:(e,s,t)=>{t.d(s,{A:()=>o});t(6540);const n={languageCallout:"languageCallout_VNpC",ruby:"ruby_iFYN",rust:"rust_PB7z",header:"header_itAP",icon:"icon_vHP_",title:"title_Bire",content:"content_ZrzH"};var r=t(4164),i=t(4848);function o(e){let{language:s,icon:t=!0,title:o,children:l}=e;const a=o||("ruby"===s?"Ruby":"Rust");return(0,i.jsxs)("div",{className:(0,r.A)(n.languageCallout,n[s]),children:[(0,i.jsxs)("div",{className:n.header,children:[t&&(0,i.jsx)("div",{className:n.icon,children:"ruby"===s?(0,i.jsxs)("svg",{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"1.5",height:"20",width:"20",children:[(0,i.jsx)("path",{d:"M6 3h12l4 6-10 12L2 9l4-6z",strokeLinejoin:"round"}),(0,i.jsx)("path",{d:"M12 21L2 9h20",strokeLinejoin:"round"})]}):(0,i.jsxs)("svg",{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"1.5",height:"20",width:"20",children:[(0,i.jsx)("circle",{cx:"12",cy:"12",r:"8"}),(0,i.jsx)("path",{d:"M12 4v2M12 18v2M4 12H6M18 12h2M6.34 6.34l1.42 1.42M16.24 16.24l1.42 1.42M6.34 17.66l1.42-1.42M16.24 7.76l1.42-1.42"}),(0,i.jsx)("path",{d:"M9 12a3 3 0 1 0 6 0 3 3 0 0 0-6 0z"})]})}),(0,i.jsx)("div",{className:n.title,children:a})]}),(0,i.jsx)("div",{className:n.content,children:l})]})}},3474:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>a,contentTitle:()=>l,default:()=>d,frontMatter:()=>o,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"api-reference/test-helpers","title":"rb-sys-test-helpers","description":"The rb-sys-test-helpers crate provides utilities for testing Ruby extensions from Rust. It makes it easy to run tests","source":"@site/docs/api-reference/test-helpers.mdx","sourceDirName":"api-reference","slug":"/api-reference/test-helpers","permalink":"/docs/api-reference/test-helpers","draft":false,"unlisted":false,"editUrl":"https://github.com/oxidize-rb/rb-sys/tree/main/docsite/docs/api-reference/test-helpers.mdx","tags":[],"version":"current","frontMatter":{"id":"test-helpers","title":"rb-sys-test-helpers"},"sidebar":"docsSidebar","previous":{"title":"rb_sys Gem Configuration","permalink":"/docs/api-reference/rb-sys-gem-config"},"next":{"title":"Cookbook","permalink":"/docs/cookbook"}}');var r=t(4848),i=t(8453);t(3355);const o={id:"test-helpers",title:"rb-sys-test-helpers"},l="rb-sys-test-helpers",a={},c=[{value:"Usage",id:"usage",level:2},{value:"How It Works",id:"how-it-works",level:2},{value:"Testing Multiple Ruby Versions",id:"testing-multiple-ruby-versions",level:2}];function u(e){const s={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"rb-sys-test-helpers",children:"rb-sys-test-helpers"})}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"rb-sys-test-helpers"})," crate provides utilities for testing Ruby extensions from Rust. It makes it easy to run tests\nwith a valid Ruby VM."]}),"\n",(0,r.jsx)(s.h2,{id:"usage",children:"Usage"}),"\n",(0,r.jsxs)(s.p,{children:["Add this to your ",(0,r.jsx)(s.code,{children:"Cargo.toml"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-toml",children:'[dev-dependencies]\nrb-sys-env = { version = "0.1" }\nrb-sys-test-helpers = { version = "0.2" }\n'})}),"\n",(0,r.jsxs)(s.p,{children:["Then, in your crate's ",(0,r.jsx)(s.code,{children:"build.rs"}),":"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust,ignore",children:"pub fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let _ = rb_sys::activate()?;\n\n    Ok(())\n}\n"})}),"\n",(0,r.jsxs)(s.p,{children:["Then, you can use the ",(0,r.jsx)(s.code,{children:"ruby_test"})," attribute macro in your tests. All of your tests can be placed in a single ",(0,r.jsx)(s.code,{children:"mod tests"})," block, with all the necessary imports at the top."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-rust",children:'#[cfg(test)]\nmod tests {\n    use rb_sys_test_helpers::ruby_test;\n    use rb_sys::{\n        rb_num2fix, rb_int2big, FIXNUM_P, rb_cObject, rb_funcall, rb_str_new_cstr, rb_iv_set, rb_intern\n    };\n    use magnus::{Ruby, RString};\n    use proptest::prelude::*;\n    use std::ffi::CString;\n\n    #[ruby_test]\n    fn test_something() {\n        let int = unsafe { rb_num2fix(1) };\n        let big = unsafe { rb_int2big(9999999) };\n\n        assert!(FIXNUM_P(int));\n        assert!(!FIXNUM_P(big));\n    }\n\n    #[ruby_test]\n    fn test_value_conversion() {\n        unsafe {\n            let obj = rb_cObject;\n            // Use a literal C string for tests\n            let value = rb_str_new_cstr(c"test".as_ptr());\n\n            rb_iv_set(obj, c"@name".as_ptr() as *const _, value);\n\n            let result = rb_funcall(obj, rb_intern(c"instance_variable_get".as_ptr()), 1,\n                                    rb_str_new_cstr(c"@name".as_ptr()));\n\n            assert_eq!(value, result);\n        }\n    }\n\n    #[ruby_test]\n    fn test_with_magnus() {\n        let _ruby = unsafe { Ruby::get_unchecked() };\n        let string = RString::new("Hello, world!");\n\n        assert_eq!(string.to_string().unwrap_or_default(), "Hello, world!");\n    }\n\n    #[ruby_test]\n    fn test_with_proptest() {\n        proptest!(|(s in "[a-zA-Z0-9]*")| {\n            let _ruby = unsafe { Ruby::get_unchecked() };\n            let ruby_string = RString::new(&s);\n            assert_eq!(ruby_string.to_string().unwrap_or_default(), s);\n        });\n    }\n}\n'})}),"\n",(0,r.jsx)(s.h2,{id:"how-it-works",children:"How It Works"}),"\n",(0,r.jsxs)(s.p,{children:["The ",(0,r.jsx)(s.code,{children:"ruby_test"})," macro sets up a Ruby VM before running your test and tears it down afterward. This allows you to\ninteract with Ruby from your Rust code during tests without having to set up the VM yourself."]}),"\n",(0,r.jsxs)(s.p,{children:["The test helpers are compatible with both ",(0,r.jsx)(s.code,{children:"rb-sys"})," for low-level C API access and ",(0,r.jsx)(s.code,{children:"magnus"})," for higher-level Ruby\ninteractions."]}),"\n",(0,r.jsx)(s.h2,{id:"testing-multiple-ruby-versions",children:"Testing Multiple Ruby Versions"}),"\n",(0,r.jsx)(s.p,{children:"To test against multiple Ruby versions, you can use environment variables and CI configuration:"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-yaml",children:'# .github/workflows/test.yml\njobs:\n  test:\n    strategy:\n      matrix:\n        ruby: ["2.7", "3.0", "3.1", "3.2", "3.3"]\n    steps:\n      - uses: actions/checkout@v4\n      - uses: oxidize-rb/actions/setup-ruby-and-rust@v1\n        with:\n          ruby-version: ${{ matrix.ruby }}\n      - run: cargo test\n'})}),"\n",(0,r.jsx)(s.p,{children:"Your tests will run against each Ruby version in the matrix, helping you ensure compatibility."})]})}function d(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>o,x:()=>l});var n=t(6540);const r={},i=n.createContext(r);function o(e){const s=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),n.createElement(i.Provider,{value:s},e.children)}}}]);