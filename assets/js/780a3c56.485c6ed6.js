"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[7340],{3049:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"cookbook","title":"Cookbook","description":"This page contains ready-to-use recipes for common patterns when building Ruby extensions with Rust.","source":"@site/docs/cookbook.mdx","sourceDirName":".","slug":"/cookbook","permalink":"/docs/cookbook","draft":false,"unlisted":false,"editUrl":"https://github.com/oxidize-rb/rb-sys/tree/main/docsite/docs/cookbook.mdx","tags":[],"version":"current","lastUpdatedBy":"Ian Ker-Seymer","lastUpdatedAt":1763832260000,"frontMatter":{"id":"cookbook","title":"Cookbook"},"sidebar":"docsSidebar","previous":{"title":"Testing with `rb-sys-test-helpers`","permalink":"/docs/api-reference/test-helpers"},"next":{"title":"Frequently Asked Questions","permalink":"/docs/faq"}}');var t=n(4848),i=n(8453);const o={id:"cookbook",title:"Cookbook"},a="Cookbook",l={},c=[{value:"String Manipulation",id:"string-manipulation",level:2},{value:"Fast String Reversal with Unicode Support",id:"fast-string-reversal-with-unicode-support",level:3},{value:"Data Processing",id:"data-processing",level:2},{value:"Parallel Array Processing",id:"parallel-array-processing",level:3},{value:"CSV Processing",id:"csv-processing",level:3},{value:"JSON Handling",id:"json-handling",level:2},{value:"File Operations",id:"file-operations",level:2},{value:"Cryptography",id:"cryptography",level:2}];function u(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"cookbook",children:"Cookbook"})}),"\n",(0,t.jsx)(r.p,{children:"This page contains ready-to-use recipes for common patterns when building Ruby extensions with Rust."}),"\n",(0,t.jsx)(r.h2,{id:"string-manipulation",children:"String Manipulation"}),"\n",(0,t.jsx)(r.h3,{id:"fast-string-reversal-with-unicode-support",children:"Fast String Reversal with Unicode Support"}),"\n",(0,t.jsxs)(r.p,{children:["This example uses the ",(0,t.jsx)(r.code,{children:"unicode-segmentation"})," crate to correctly reverse a string containing multi-byte grapheme clusters."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:'use magnus::{function, prelude::*, Error, Ruby};\nuse unicode_segmentation::UnicodeSegmentation;\n\nfn reverse_preserving_graphemes(input: String) -> String {\n    input.graphemes(true).rev().collect()\n}\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let module = ruby.define_module("StringUtils")?;\n    module.define_singleton_method("reverse_unicode", function!(reverse_preserving_graphemes, 1))?;\n    Ok(())\n}\n'})}),"\n",(0,t.jsx)(r.h2,{id:"data-processing",children:"Data Processing"}),"\n",(0,t.jsx)(r.h3,{id:"parallel-array-processing",children:"Parallel Array Processing"}),"\n",(0,t.jsxs)(r.p,{children:["This recipe demonstrates how to release the GVL to process a Ruby array in parallel using the ",(0,t.jsx)(r.code,{children:"rayon"})," crate."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:'use magnus::{RArray, Error, TryConvert};\nuse rayon::prelude::*;\nuse rb_sys::rb_thread_call_without_gvl;\nuse std::os::raw::c_void;\n\nstruct ProcessData {\n    items: Vec<i64>,\n    result: Vec<i64>,\n}\n\nextern "C" fn process_without_gvl(data: *mut c_void) -> *mut c_void {\n    unsafe {\n        let data = &mut *(data as *mut ProcessData);\n        data.result = data.items.par_iter().map(|&x| x * x).collect();\n    }\n    std::ptr::null_mut()\n}\n\nfn parallel_map_squares(array: RArray) -> Result<RArray, Error> {\n    let items: Vec<i64> = array.to_vec()?;\n    let mut data = ProcessData { items, result: Vec::new() };\n\n    unsafe {\n        rb_thread_call_without_gvl(\n            Some(process_without_gvl),\n            &mut data as *mut _ as *mut c_void,\n            None,\n            std::ptr::null_mut(),\n        );\n    }\n\n    Ok(RArray::from_vec(data.result))\n}\n'})}),"\n",(0,t.jsx)(r.h3,{id:"csv-processing",children:"CSV Processing"}),"\n",(0,t.jsxs)(r.p,{children:["This example uses the ",(0,t.jsx)(r.code,{children:"csv"})," crate to parse a CSV string into an array of Ruby hashes."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:"use magnus::{RArray, RHash, Symbol, Error, exception, Ruby};\n\nfn parse_csv_to_hashes(ruby: &Ruby, csv_string: String) -> Result<RArray, Error> {\n    let mut reader = csv::Reader::from_reader(csv_string.as_bytes());\n    let headers = reader.headers().map_err(|e| Error::new(ruby.exception_runtime_error(), e.to_string()))?.clone();\n    let result = RArray::new();\n\n    for record in reader.records() {\n        let record = record.map_err(|e| Error::new(ruby.exception_runtime_error(), e.to_string()))?;\n        let hash = RHash::new();\n        for (header, value) in headers.iter().zip(record.iter()) {\n            hash.aset(Symbol::new(header), value)?;\n        }\n        result.push(hash)?;\n    }\n\n    Ok(result)\n}\n"})}),"\n",(0,t.jsx)(r.h2,{id:"json-handling",children:"JSON Handling"}),"\n",(0,t.jsxs)(r.p,{children:["This recipe uses ",(0,t.jsx)(r.code,{children:"serde_json"})," to parse a JSON string into Ruby objects, providing a faster alternative to Ruby's default ",(0,t.jsx)(r.code,{children:"JSON"})," library."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:"use magnus::{Value, Error, Ruby};\n\nfn parse_json(ruby: &Ruby, json_string: String) -> Result<Value, Error> {\n    let value: serde_json::Value = serde_json::from_str(&json_string)\n        .map_err(|e| Error::new(ruby.exception_runtime_error(), e.to_string()))?;\n    serde_magnus::serialize(ruby, &value).map_err(|e| Error::new(ruby.exception_runtime_error(), e.to_string()))\n}\n"})}),"\n",(0,t.jsx)(r.h2,{id:"file-operations",children:"File Operations"}),"\n",(0,t.jsx)(r.p,{children:"This recipe efficiently processes a large file line-by-line without loading the entire file into memory."}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:"use magnus::{Error, Ruby};\nuse std::fs::File;\nuse std::io::{BufRead, BufReader};\n\nfn count_lines_with_pattern(ruby: &Ruby, path: String, pattern: String) -> Result<i64, Error> {\n    let file = File::open(&path)\n        .map_err(|e| Error::new(ruby.exception_runtime_error(), e.to_string()))?;\n    let reader = BufReader::new(file);\n    let mut count = 0;\n\n    for line in reader.lines() {\n        if line.map_err(|e| Error::new(ruby.exception_runtime_error(), e.to_string()))?.contains(&pattern) {\n            count += 1;\n        }\n    }\n\n    Ok(count)\n}\n"})}),"\n",(0,t.jsx)(r.h2,{id:"cryptography",children:"Cryptography"}),"\n",(0,t.jsxs)(r.p,{children:["This example uses the ",(0,t.jsx)(r.code,{children:"sha2"})," crate to compute a SHA256 hexdigest of a string."]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-rust",children:"use magnus::{RString, Error};\nuse sha2::{Sha256, Digest};\n\nfn sha256_hexdigest(input: RString) -> Result<String, Error> {\n    let data = unsafe { input.as_slice() };\n    let mut hasher = Sha256::new();\n    hasher.update(data);\n    let result = hasher.finalize();\n    Ok(hex::encode(result))\n}\n"})})]})}function d(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(u,{...e})}):u(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>o,x:()=>a});var s=n(6540);const t={},i=s.createContext(t);function o(e){const r=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(i.Provider,{value:r},e.children)}}}]);