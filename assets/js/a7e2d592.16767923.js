"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[62],{4432:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"core-concepts","title":"Core Concepts","description":"This page explains the mental models required to build safe and efficient Ruby extensions with Rust, focusing on the bridge between the two languages.","source":"@site/docs/core-concepts.mdx","sourceDirName":".","slug":"/core-concepts","permalink":"/docs/core-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/oxidize-rb/rb-sys/tree/main/docsite/docs/core-concepts.mdx","tags":[],"version":"current","lastUpdatedBy":"Nobuyoshi Nakada","lastUpdatedAt":1767844682000,"frontMatter":{"id":"core-concepts","title":"Core Concepts"},"sidebar":"docsSidebar","previous":{"title":"Quick Start","permalink":"/docs/quick-start"},"next":{"title":"Project Setup & Structure","permalink":"/docs/project-setup"}}');var s=r(4848),i=r(8453);const l={id:"core-concepts",title:"Core Concepts"},o="Core Concepts",c={},a=[{value:"The Ruby-Rust Bridge",id:"the-ruby-rust-bridge",level:2},{value:"Memory Models: Ruby vs. Rust",id:"memory-models-ruby-vs-rust",level:2},{value:"The Global VM Lock (GVL)",id:"the-global-vm-lock-gvl",level:2},{value:"When to Release the GVL",id:"when-to-release-the-gvl",level:4},{value:"Error Handling",id:"error-handling",level:2},{value:"Performance Mindset",id:"performance-mindset",level:2},{value:"Security Considerations",id:"security-considerations",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h4:"h4",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"core-concepts",children:"Core Concepts"})}),"\n",(0,s.jsx)(n.p,{children:"This page explains the mental models required to build safe and efficient Ruby extensions with Rust, focusing on the bridge between the two languages."}),"\n",(0,s.jsx)(n.h2,{id:"the-ruby-rust-bridge",children:"The Ruby-Rust Bridge"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"rb-sys"})," connects Ruby and Rust through several layers. It provides low-level, ",(0,s.jsx)(n.code,{children:"unsafe"})," bindings to Ruby's C API. Higher-level libraries like ",(0,s.jsx)(n.a,{href:"https://github.com/matsadler/magnus",children:"Magnus"})," offer a safe, ergonomic wrapper."]}),"\n",(0,s.jsx)("div",{className:"architecture-diagram",children:(0,s.jsx)(n.mermaid,{value:'graph TB\n    subgraph "Your Code"\n        A[Ruby Application]\n        B[Rust Extension]\n    end\n\n    subgraph "High-Level API (Safe)"\n        C[Magnus]\n    end\n\n    subgraph "Low-Level Bindings (Unsafe)"\n        D[rb-sys]\n    end\n\n    subgraph "Ruby Runtime"\n        E[Ruby C API]\n    end\n\n    A --\x3e|calls| B\n    B --\x3e|uses| C\n    C --\x3e|wraps| D\n    D --\x3e|binds to| E\n\n    style A fill:#CC342D,color:#fff\n    style B fill:#000,color:#fff\n    style C fill:#D99A6C,color:#fff\n    style D fill:#545B69,color:#fff\n    style E fill:#CC342D,color:#fff'})}),"\n",(0,s.jsx)(n.h2,{id:"memory-models-ruby-vs-rust",children:"Memory Models: Ruby vs. Rust"}),"\n",(0,s.jsx)(n.p,{children:"Bridging Ruby's Garbage Collector (GC) with Rust's ownership model is a key challenge. Rust references to Ruby objects must be \"marked\" to prevent premature collection by the GC, which would lead to segmentation faults."}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Aspect"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Ruby"}),(0,s.jsx)(n.th,{style:{textAlign:"left"},children:"Rust"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.strong,{children:"Management"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Garbage Collection (GC)"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Ownership & Borrowing"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.strong,{children:"Deallocation"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"When GC decides"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"When owner goes out of scope"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{style:{textAlign:"left"},children:(0,s.jsx)(n.strong,{children:"Safety"})}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Managed by VM"}),(0,s.jsx)(n.td,{style:{textAlign:"left"},children:"Enforced by compiler"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"the-global-vm-lock-gvl",children:"The Global VM Lock (GVL)"}),"\n",(0,s.jsx)(n.p,{children:"Ruby's GVL prevents true parallel execution of Ruby code. For CPU-intensive Rust code that doesn't interact with the Ruby VM, release the GVL to allow other Ruby threads to run concurrently."}),"\n",(0,s.jsx)(n.h4,{id:"when-to-release-the-gvl",children:"When to Release the GVL"}),"\n",(0,s.jsxs)(n.p,{children:["\u2705 ",(0,s.jsx)(n.strong,{children:"Release for:"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"CPU-bound computations (e.g., image processing, complex math)."}),"\n",(0,s.jsx)(n.li,{children:"Blocking I/O operations (network requests, file system access)."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["\u274c ",(0,s.jsx)(n.strong,{children:"Do not release for:"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Any operation that calls back into the Ruby API."}),"\n",(0,s.jsx)(n.li,{children:"Very short operations where overhead outweighs benefits."}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For a reusable GVL release helper, see the ",(0,s.jsx)(n.a,{href:"/docs/cookbook",children:"Cookbook"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsxs)(n.p,{children:["Rust's ",(0,s.jsx)(n.code,{children:"Result"})," type is the primary mechanism for error handling. A ",(0,s.jsx)(n.code,{children:"Result<T, magnus::Error>"})," will automatically convert its ",(0,s.jsx)(n.code,{children:"Err"})," variant into a Ruby exception."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{Error, Ruby};\n\n// A fallible operation.\nfn divide(ruby: &Ruby, a: f64, b: f64) -> Result<f64, Error> {\n    if b == 0.0 {\n        Err(Error::new(ruby.exception_zero_div_error(), "divided by 0")) // Becomes `ZeroDivisionError` in Ruby.\n    } else {\n        Ok(a / b)\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["For more details, see the ",(0,s.jsx)(n.a,{href:"/docs/error-handling",children:"Error Handling"})," guide."]}),"\n",(0,s.jsx)(n.h2,{id:"performance-mindset",children:"Performance Mindset"}),"\n",(0,s.jsx)(n.p,{children:'Rust is chosen for performance, but FFI calls incur overhead. Maximize performance by minimizing "chatty" calls.'}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"\u274c Inefficient:"})," Ruby loop calling Rust function on each iteration."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"\u2705 Efficient:"})," Single Ruby call passing a collection (e.g., ",(0,s.jsx)(n.code,{children:"RArray"}),") to Rust for internal iteration."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use magnus::{RArray, Error, TryConvert};\n\n// Efficiently sums an array by iterating on the Rust side.\nfn efficient_sum(array: RArray) -> Result<i64, Error> {\n    let mut sum = 0i64;\n    for item in array.each() {\n        sum += i64::try_convert(item?)?;\n    }\n    Ok(sum)\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,s.jsx)(n.p,{children:"Native extensions can introduce vulnerabilities. Always validate input from Ruby."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{Error, Ruby};\n\n// Validates input to prevent excessive resource usage.\nfn process_input(ruby: &Ruby, input: String) -> Result<(), Error> {\n    const MAX_LENGTH: usize = 1_024;\n    if input.len() > MAX_LENGTH {\n        return Err(Error::new(ruby.exception_arg_error(), "input is too long"));\n    }\n    Ok(()) // Proceed with processing\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>o});var t=r(6540);const s={},i=t.createContext(s);function l(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);