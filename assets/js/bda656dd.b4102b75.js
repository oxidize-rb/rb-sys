"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[4577],{7461:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"development-approaches","title":"Development Approaches","description":"You can build Ruby extensions with Rust using rb-sys directly for low-level control, or use a higher-level library like Magnus for safety and convenience. This page helps you choose the right approach.","source":"@site/docs/development-approaches.mdx","sourceDirName":".","slug":"/development-approaches","permalink":"/docs/development-approaches","draft":false,"unlisted":false,"editUrl":"https://github.com/oxidize-rb/rb-sys/tree/main/docsite/docs/development-approaches.mdx","tags":[],"version":"current","lastUpdatedBy":"Ian Ker-Seymer","lastUpdatedAt":1767649890000,"sidebarPosition":6,"frontMatter":{"id":"development-approaches","title":"Development Approaches","sidebar_position":6}}');var t=s(4848),l=s(8453);const i={id:"development-approaches",title:"Development Approaches",sidebar_position:6},o="Development Approaches",a={},c=[{value:"Comparison",id:"comparison",level:2},{value:"Direct <code>rb-sys</code> Usage",id:"direct-rb-sys-usage",level:2},{value:"When to Use Direct <code>rb-sys</code>",id:"when-to-use-direct-rb-sys",level:3},{value:"Example: Simple Extension",id:"example-simple-extension",level:3},{value:"Releasing GVL with <code>rb_thread_call_without_gvl</code>",id:"releasing-gvl-with-rb_thread_call_without_gvl",level:3},{value:"How Direct <code>rb-sys</code> Works",id:"how-direct-rb-sys-works",level:3},{value:"Higher-level Wrappers (Magnus)",id:"higher-level-wrappers-magnus",level:2},{value:"When to Use Magnus",id:"when-to-use-magnus",level:3},{value:"Example: Simple Extension with Magnus",id:"example-simple-extension-with-magnus",level:3},{value:"Example: LZ4-Flex-RB (Complex)",id:"example-lz4-flex-rb-complex",level:3},{value:"How Magnus Works",id:"how-magnus-works",level:3},{value:"Mixing Approaches",id:"mixing-approaches",level:2},{value:"Enabling <code>rb-sys</code> Feature in Magnus",id:"enabling-rb-sys-feature-in-magnus",level:3},{value:"Common Mixing Patterns",id:"common-mixing-patterns",level:3},{value:"Real-World Examples",id:"real-world-examples",level:2},{value:"Blake3-Ruby (Direct <code>rb-sys</code>)",id:"blake3-ruby-direct-rb-sys",level:3},{value:"LZ4-Flex-RB (Mixed Approach)",id:"lz4-flex-rb-mixed-approach",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"development-approaches",children:"Development Approaches"})}),"\n",(0,t.jsxs)(n.p,{children:["You can build Ruby extensions with Rust using ",(0,t.jsx)(n.code,{children:"rb-sys"})," directly for low-level control, or use a higher-level library like Magnus for safety and convenience. This page helps you choose the right approach."]}),"\n",(0,t.jsx)(n.h2,{id:"comparison",children:"Comparison"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Aspect"}),(0,t.jsxs)(n.th,{style:{textAlign:"left"},children:["Direct ",(0,t.jsx)(n.code,{children:"rb-sys"})]}),(0,t.jsx)(n.th,{style:{textAlign:"left"},children:"Magnus (High-Level)"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:(0,t.jsx)(n.strong,{children:"Control"})}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Maximum control over Ruby VM."}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Abstracts away VM details."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:(0,t.jsx)(n.strong,{children:"Safety"})}),(0,t.jsxs)(n.td,{style:{textAlign:"left"},children:["Requires ",(0,t.jsx)(n.code,{children:"unsafe"})," code blocks."]}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Provides a mostly safe API."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:(0,t.jsx)(n.strong,{children:"Verbosity"})}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"More verbose; manual type conversion."}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Concise; automatic type conversion."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:(0,t.jsx)(n.strong,{children:"Error Handling"})}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Manual check of Ruby error state."}),(0,t.jsxs)(n.td,{style:{textAlign:"left"},children:["Idiomatic ",(0,t.jsx)(n.code,{children:"Result<T, Error>"}),"."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{style:{textAlign:"left"},children:(0,t.jsx)(n.strong,{children:"Best For"})}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Performance-critical code, accessing internal APIs."}),(0,t.jsx)(n.td,{style:{textAlign:"left"},children:"Most general-purpose gems."})]})]})]}),"\n",(0,t.jsxs)(n.h2,{id:"direct-rb-sys-usage",children:["Direct ",(0,t.jsx)(n.code,{children:"rb-sys"})," Usage"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"rb-sys"})," crate provides low-level bindings to Ruby's C API, offering complete control over Rust-Ruby interaction."]}),"\n",(0,t.jsxs)(n.h3,{id:"when-to-use-direct-rb-sys",children:["When to Use Direct ",(0,t.jsx)(n.code,{children:"rb-sys"})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Maximum control over Ruby VM interaction."}),"\n",(0,t.jsx)(n.li,{children:"Access to low-level Ruby internals."}),"\n",(0,t.jsx)(n.li,{children:"Critical performance requirements, eliminating any overhead."}),"\n",(0,t.jsx)(n.li,{children:"Implementing functionality not yet covered by higher-level wrappers."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example-simple-extension",children:"Example: Simple Extension"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use rb_sys::{\n    rb_define_module, rb_define_module_function, rb_str_new_cstr,\n    rb_string_value_cstr, VALUE\n};\nuse std::ffi::CString;\nuse std::os::raw::c_char;\n\nmacro_rules! cstr { ($s:expr) => { concat!($s, "\\0").as_ptr() as *const c_char }; }\n\nunsafe extern "C" fn reverse(_: VALUE, s: VALUE) -> VALUE {\n    let mut s_copy = s;\n    let c_str = rb_string_value_cstr(&mut s_copy);\n    let rust_str = match std::ffi::CStr::from_ptr(c_str).to_str() {\n        Ok(s) => s,\n        Err(_) => return rb_str_new_cstr(c"".as_ptr()),\n    };\n    let reversed = rust_str.chars().rev().collect::<String>();\n    let c_string = match CString::new(reversed) {\n        Ok(s) => s,\n        Err(_) => return rb_str_new_cstr(c"".as_ptr()),\n    };\n    rb_str_new_cstr(c_string.as_ptr())\n}\n\n#[no_mangle]\npub extern "C" fn Init_string_utils() {\n    unsafe {\n        let module = rb_define_module(cstr!("StringUtils"));\n        rb_define_module_function(\n            module,\n            cstr!("reverse"),\n            Some(std::mem::transmute(reverse as unsafe extern "C" fn(VALUE, VALUE) -> VALUE)),\n            1,\n        );\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"releasing-gvl-with-rb_thread_call_without_gvl",children:["Releasing GVL with ",(0,t.jsx)(n.code,{children:"rb_thread_call_without_gvl"})]}),"\n",(0,t.jsx)(n.p,{children:"For computationally intensive operations, release Ruby's Global VM Lock (GVL) to allow other threads to run."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use magnus::{Error, Ruby};\nuse rb_sys::rb_thread_call_without_gvl;\nuse std::{ffi::c_void, panic::{self, AssertUnwindSafe}, ptr::null_mut};\n\npub fn nogvl<F, R>(func: F) -> Result<R, Error>\nwhere F: FnOnce() -> R, R: Send + \'static, {\n    struct CallbackData<F, R> {\n        func: Option<F>,\n        result: Option<Result<R, String>>,\n    }\n\n    extern "C" fn call_without_gvl<F, R>(data: *mut c_void) -> *mut c_void\n    where F: FnOnce() -> R, R: Send + \'static, {\n        let data = unsafe { &mut *(data as *mut CallbackData<F, R>) };\n        if let Some(func) = data.func.take() {\n            match panic::catch_unwind(AssertUnwindSafe(func)) {\n                Ok(result) => data.result = Some(Ok(result)),\n                Err(panic_info) => {\n                    let panic_msg = if let Some(s) = panic_info.downcast_ref::<&\'static str>() {\n                        s.to_string()\n                    } else if let Some(s) = panic_info.downcast_ref::<String>() {\n                        s.clone()\n                    } else {\n                        "Unknown panic occurred in Rust code".to_string()\n                    };\n                    data.result = Some(Err(panic_msg));\n                }\n            }\n        }\n        null_mut()\n    }\n\n    let mut data = CallbackData { func: Some(func), result: None };\n\n    unsafe {\n        rb_thread_call_without_gvl(\n            Some(call_without_gvl::<F, R>),\n            &mut data as *mut _ as *mut c_void,\n            None,\n            null_mut(),\n        );\n    }\n\n    match data.result {\n        Some(Ok(result)) => Ok(result),\n        Some(Err(panic_msg)) => {\n            let ruby = unsafe { Ruby::get_unchecked() };\n            Err(Error::new(\n                ruby.exception_runtime_error(),\n                format!("Rust panic in nogvl: {}", panic_msg),\n            ))\n        }\n        None => {\n            let ruby = unsafe { Ruby::get_unchecked() };\n            Err(Error::new(\n                ruby.exception_runtime_error(),\n                "nogvl function was not executed",\n            ))\n        }\n    }\n}\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"how-direct-rb-sys-works",children:["How Direct ",(0,t.jsx)(n.code,{children:"rb-sys"})," Works"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Defines C-compatible functions (",(0,t.jsx)(n.code,{children:'extern "C"'}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["Manually converts between Ruby ",(0,t.jsx)(n.code,{children:"VALUE"})," and Rust types."]}),"\n",(0,t.jsx)(n.li,{children:"Requires manual memory management and type safety."}),"\n",(0,t.jsxs)(n.li,{children:["Uses ",(0,t.jsx)(n.code,{children:"#[no_mangle]"})," for Ruby visibility."]}),"\n",(0,t.jsxs)(n.li,{children:["All Ruby data interactions use raw pointers and ",(0,t.jsx)(n.code,{children:"unsafe"})," code."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"higher-level-wrappers-magnus",children:"Higher-level Wrappers (Magnus)"}),"\n",(0,t.jsxs)(n.p,{children:["Magnus provides an ergonomic, Rust-like API built on ",(0,t.jsx)(n.code,{children:"rb-sys"}),", handling many ",(0,t.jsx)(n.code,{children:"unsafe"})," Ruby integration aspects."]}),"\n",(0,t.jsx)(n.h3,{id:"when-to-use-magnus",children:"When to Use Magnus"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Most standard Ruby extensions."}),"\n",(0,t.jsxs)(n.li,{children:["Avoiding ",(0,t.jsx)(n.code,{children:"unsafe"})," code."]}),"\n",(0,t.jsx)(n.li,{children:"Idiomatic Rust error handling."}),"\n",(0,t.jsx)(n.li,{children:"Complex type conversions."}),"\n",(0,t.jsx)(n.li,{children:"Object-oriented interaction with Ruby classes and objects."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"example-simple-extension-with-magnus",children:"Example: Simple Extension with Magnus"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use magnus::{function, prelude::*, Error, Ruby};\n\nfn hello(subject: String) -> String {\n    format!("Hello from Rust, {subject}!")\n}\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let module = ruby.define_module("StringUtils")?;\n    module.define_singleton_method("hello", function!(hello, 1))?;\n    Ok(())\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"example-lz4-flex-rb-complex",children:"Example: LZ4-Flex-RB (Complex)"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use magnus::{function, prelude::*, Error, Ruby, RString};\n\nfn compress(input: RString) -> Result<RString, Error> {\n    Ok(input) // Placeholder\n}\n\nfn decompress(input: RString) -> Result<RString, Error> {\n    Ok(input) // Placeholder\n}\n\nfn compress_varint(input: RString) -> Result<RString, Error> {\n    Ok(input) // Placeholder\n}\n\nfn decompress_varint(input: RString) -> Result<RString, Error> {\n    Ok(input) // Placeholder\n}\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let module = ruby.define_module("Lz4Flex")?;\n    let base_error = module.define_error("Error", ruby.exception_standard_error())?;\n    let _ = module.define_error("EncodeError", base_error)?;\n    let _ = module.define_error("DecodeError", base_error)?;\n\n    module.define_singleton_method("compress", function!(compress, 1))?;\n    module.define_singleton_method("decompress", function!(decompress, 1))?;\n    module.singleton_class()?.define_alias("deflate", "compress")?;\n    module.singleton_class()?.define_alias("inflate", "decompress")?;\n\n    let varint_module = module.define_module("VarInt")?;\n    varint_module.define_singleton_method("compress", function!(compress_varint, 1))?;\n    varint_module.define_singleton_method("decompress", function!(decompress_varint, 1))?;\n\n    Ok(())\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"how-magnus-works",children:"How Magnus Works"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Automatic type conversions."}),"\n",(0,t.jsxs)(n.li,{children:["Rust-like error handling with ",(0,t.jsx)(n.code,{children:"Result"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Memory safety via RAII patterns."}),"\n",(0,t.jsx)(n.li,{children:"Ergonomic APIs for modules, classes, and methods."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"mixing-approaches",children:"Mixing Approaches"}),"\n",(0,t.jsxs)(n.p,{children:["Combine Magnus for general use with direct ",(0,t.jsx)(n.code,{children:"rb-sys"})," for performance-critical sections."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use magnus::{function, prelude::*, Error, Ruby, value::ReprValue};\nuse std::os::raw::c_char;\nuse std::ffi::CString;\nuse magnus::rb_sys::AsRawValue;\n\nfn high_level() -> String { "High level".to_string() }\nmacro_rules! cstr { ($s:expr) => { concat!($s, "\\0").as_ptr() as *const c_char }; }\n\nunsafe extern "C" fn low_level() -> rb_sys::VALUE { // Changed signature\n    let c_string = match CString::new("Low level") {\n        Ok(s) => s,\n        Err(_) => return rb_sys::rb_str_new_cstr(c"".as_ptr()),\n    };\n    rb_sys::rb_str_new_cstr(c_string.as_ptr())\n}\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let module = ruby.define_module("MixedExample")?;\n    module.define_singleton_method("high_level", function!(high_level, 0))?;\n    unsafe {\n        rb_sys::rb_define_module_function(\n            module.as_value().as_raw(),\n            cstr!("low_level"),\n            Some(low_level as unsafe extern "C" fn() -> rb_sys::VALUE), // Explicit cast\n            0,\n        );\n    }\n    Ok(())\n}\n'})}),"\n",(0,t.jsxs)(n.h3,{id:"enabling-rb-sys-feature-in-magnus",children:["Enabling ",(0,t.jsx)(n.code,{children:"rb-sys"})," Feature in Magnus"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-toml",children:'# Cargo.toml\n[dependencies]\nmagnus = { version = "0.7", features = ["rb-sys"] }\n'})}),"\n",(0,t.jsx)(n.h3,{id:"common-mixing-patterns",children:"Common Mixing Patterns"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["Magnus for API, ",(0,t.jsx)(n.code,{children:"rb-sys"})," for optimization:"]})," Define public API with Magnus; drop to ",(0,t.jsx)(n.code,{children:"rb-sys"})," for hot paths (e.g., with ",(0,t.jsx)(n.code,{children:"nogvl"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:[(0,t.jsx)(n.code,{children:"rb-sys"})," for core, Magnus for conversions:"]})," Build core with ",(0,t.jsx)(n.code,{children:"rb-sys"}),"; use Magnus for complex Ruby objects."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["Start Magnus, optimize ",(0,t.jsx)(n.code,{children:"rb-sys"})," later:"]})," Rapid development with Magnus; profile and optimize hot paths with direct ",(0,t.jsx)(n.code,{children:"rb-sys"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"real-world-examples",children:"Real-World Examples"}),"\n",(0,t.jsxs)(n.h3,{id:"blake3-ruby-direct-rb-sys",children:["Blake3-Ruby (Direct ",(0,t.jsx)(n.code,{children:"rb-sys"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["Blake3-Ruby uses direct ",(0,t.jsx)(n.code,{children:"rb-sys"})," for maximum cryptographic hashing performance."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use rb_sys::{rb_define_module, rb_define_module_function, rb_str_new, VALUE, RSTRING_LEN, RSTRING_PTR};\nuse std::os::raw::c_char;\n\nmacro_rules! cstr { ($s:expr) => { concat!($s, "\\0").as_ptr() as *const c_char }; }\n\n#[no_mangle]\npub extern "C" fn Init_digest_ext() {\n    unsafe {\n        let digest_module = rb_define_module(cstr!("Digest"));\n        rb_define_module_function(\n            digest_module,\n            cstr!("simple_hash"),\n            Some(std::mem::transmute(rb_simple_hash as unsafe extern "C" fn(rb_sys::VALUE, rb_sys::VALUE) -> rb_sys::VALUE)),\n            1,\n        );\n    }\n}\n\nunsafe extern "C" fn rb_simple_hash(_klass: VALUE, string: VALUE) -> VALUE {\n    let data_ptr = RSTRING_PTR(string) as *const u8;\n    let data_len = RSTRING_LEN(string) as usize;\n    let data_slice = std::slice::from_raw_parts(data_ptr, data_len);\n\n    let mut hash: u32 = 0;\n    for &byte in data_slice { hash = hash.wrapping_mul(31).wrapping_add(byte as u32); }\n\n    let hash_str = format!("{:08x}", hash);\n    let hash_bytes = hash_str.as_bytes();\n    rb_str_new(hash_bytes.as_ptr() as *const c_char, hash_bytes.len() as i64)\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"lz4-flex-rb-mixed-approach",children:"LZ4-Flex-RB (Mixed Approach)"}),"\n",(0,t.jsxs)(n.p,{children:["LZ4-Flex-RB mixes Magnus with direct ",(0,t.jsx)(n.code,{children:"rb-sys"})," calls for compression."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use magnus::{function, prelude::*, Error, Ruby, RString};\nuse rb_sys::{rb_str_locktmp, rb_str_unlocktmp, RSTRING_PTR, RSTRING_LEN};\nuse magnus::rb_sys::AsRawValue;\n\nfn compress(input: RString) -> Result<RString, Error> { Ok(input) } // Placeholder\nfn decompress(input: RString) -> Result<RString, Error> { Ok(input) } // Placeholder\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let module = ruby.define_module("Lz4Flex")?;\n    let base_error = module.define_error("Error", ruby.exception_standard_error())?;\n    let _ = module.define_error("EncodeError", base_error)?;\n    let _ = module.define_error("DecodeError", base_error)?;\n\n    module.define_singleton_method("compress", function!(compress, 1))?;\n    module.define_singleton_method("decompress", function!(decompress, 1))?;\n    module.singleton_class()?.define_alias("deflate", "compress")?;\n    module.singleton_class()?.define_alias("inflate", "decompress")?;\n\n    let varint_module = module.define_module("VarInt")?;\n    varint_module.define_singleton_method("compress", function!(compress, 1))?;\n    varint_module.define_singleton_method("decompress", function!(decompress, 1))?;\n\n    Ok(())\n}\n\nstruct LockedRString(RString);\n\nimpl LockedRString {\n    fn new(string: RString) -> Self {\n        unsafe { rb_str_locktmp(string.as_value().as_raw()) };\n        Self(string)\n    }\n\n    fn as_slice(&self) -> &[u8] {\n        unsafe {\n            let value = self.0.as_value();\n            let ptr = RSTRING_PTR(value.as_raw()) as *const u8;\n            let len = RSTRING_LEN(value.as_raw()) as usize;\n            std::slice::from_raw_parts(ptr, len)\n        }\n    }\n}\n\nimpl Drop for LockedRString {\n    fn drop(&mut self) {\n        unsafe { rb_str_unlocktmp(self.0.as_value().as_raw()) };\n    }\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>o});var r=s(6540);const t={},l=r.createContext(t);function i(e){const n=r.useContext(l);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(l.Provider,{value:n},e.children)}}}]);