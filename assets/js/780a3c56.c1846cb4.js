"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[7340],{3049:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"cookbook","title":"Cookbook","description":"Ready-to-use recipes for common Ruby extension patterns with Rust.","source":"@site/docs/cookbook.mdx","sourceDirName":".","slug":"/cookbook","permalink":"/docs/cookbook","draft":false,"unlisted":false,"editUrl":"https://github.com/oxidize-rb/rb-sys/tree/main/docsite/docs/cookbook.mdx","tags":[],"version":"current","lastUpdatedBy":"Xiaoxi Pang","lastUpdatedAt":1762924947000,"sidebarPosition":19,"frontMatter":{"id":"cookbook","title":"Cookbook","sidebar_position":19,"keywords":["cookbook","recipes","examples","patterns","solutions"],"description":"Ready-to-use recipes for common Ruby extension patterns with Rust."},"sidebar":"docsSidebar","previous":{"title":"rb-sys-test-helpers","permalink":"/docs/api-reference/test-helpers"},"next":{"title":"Frequently Asked Questions","permalink":"/docs/faq"}}');var s=r(4848),a=r(8453);const o={id:"cookbook",title:"Cookbook",sidebar_position:19,keywords:["cookbook","recipes","examples","patterns","solutions"],description:"Ready-to-use recipes for common Ruby extension patterns with Rust."},i="Cookbook",l={},u=[{value:"String Manipulation",id:"string-manipulation",level:2},{value:"Fast String Reversal with Unicode Support",id:"fast-string-reversal-with-unicode-support",level:3},{value:"Efficient String Search and Replace",id:"efficient-string-search-and-replace",level:3},{value:"Data Processing",id:"data-processing",level:2},{value:"Parallel Array Processing",id:"parallel-array-processing",level:3},{value:"CSV Processing",id:"csv-processing",level:3},{value:"JSON Handling",id:"json-handling",level:2},{value:"High-Performance JSON Parser",id:"high-performance-json-parser",level:3},{value:"File Operations",id:"file-operations",level:2},{value:"Fast File Processing",id:"fast-file-processing",level:3},{value:"Cryptography",id:"cryptography",level:2},{value:"Hash Functions",id:"hash-functions",level:3},{value:"Database Operations",id:"database-operations",level:2},{value:"Connection Pool Pattern",id:"connection-pool-pattern",level:3},{value:"HTTP Client",id:"http-client",level:2},{value:"Simple URL Operations",id:"simple-url-operations",level:3},{value:"Image Processing",id:"image-processing",level:2},{value:"Basic Image Operations",id:"basic-image-operations",level:3},{value:"Performance Monitoring",id:"performance-monitoring",level:2},{value:"Benchmarking Helper",id:"benchmarking-helper",level:3},{value:"Thread Safety",id:"thread-safety",level:2},{value:"Thread-Safe Counter",id:"thread-safe-counter",level:3},{value:"Custom Iterators",id:"custom-iterators",level:2},{value:"Ruby-Style Enumerator",id:"ruby-style-enumerator",level:3},{value:"More Recipes Coming",id:"more-recipes-coming",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"cookbook",children:"Cookbook"})}),"\n",(0,s.jsx)(n.p,{children:"Ready-to-use recipes for common Ruby extension patterns. Copy, paste, and adapt!"}),"\n",(0,s.jsx)(n.h2,{id:"string-manipulation",children:"String Manipulation"}),"\n",(0,s.jsx)(n.h3,{id:"fast-string-reversal-with-unicode-support",children:"Fast String Reversal with Unicode Support"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{function, prelude::*, Error, Ruby};\nuse unicode_segmentation::UnicodeSegmentation;\n\nfn reverse_preserving_graphemes(input: String) -> String {\n    input.graphemes(true).rev().collect()\n}\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let module = ruby.define_module("StringUtils")?;\n    module.define_singleton_method(\n        "reverse_unicode", \n        function!(reverse_preserving_graphemes, 1)\n    )?;\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Usage:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:'StringUtils.reverse_unicode("Hello \ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc66!")  # => "!\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc66 olleH"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"efficient-string-search-and-replace",children:"Efficient String Search and Replace"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::Error;\nuse regex::Regex;\n\nfn batch_replace(text: String, patterns: Vec<(String, String)>) -> Result<String, Error> {\n    let mut result = text;\n    \n    for (pattern, replacement) in patterns {\n        let re = Regex::new(&pattern)\n            .map_err(|e| Error::new(\n                magnus::exception::arg_error(),\n                format!("Invalid regex: {}", e)\n            ))?;\n        \n        result = re.replace_all(&result, replacement.as_str()).to_string();\n    }\n    \n    Ok(result)\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"data-processing",children:"Data Processing"}),"\n",(0,s.jsx)(n.h3,{id:"parallel-array-processing",children:"Parallel Array Processing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{RArray, Error, TryConvert};\nuse rayon::prelude::*;\nuse rb_sys::rb_thread_call_without_gvl;\nuse std::os::raw::c_void;\n\n// Structure to hold data for processing\nstruct ProcessData {\n    items: Vec<i64>,\n    result: Vec<i64>,\n}\n\nextern "C" fn process_without_gvl(data: *mut c_void) -> *mut c_void {\n    unsafe {\n        let data = &mut *(data as *mut ProcessData);\n        data.result = data.items.par_iter()\n            .map(|&x| x * x)  // Square each number\n            .collect();\n    }\n    std::ptr::null_mut()\n}\n\nfn parallel_map(array: RArray) -> Result<RArray, Error> {\n    // Convert to Rust Vec\n    let mut items = Vec::with_capacity(array.len());\n    for item in array.each() {\n        let val: i64 = TryConvert::try_convert(item?)?;\n        items.push(val);\n    }\n    \n    let mut data = ProcessData {\n        items,\n        result: Vec::new(),\n    };\n    \n    // Process in parallel (release GVL)\n    unsafe {\n        rb_thread_call_without_gvl(\n            Some(process_without_gvl),\n            &mut data as *mut _ as *mut c_void,\n            None,\n            std::ptr::null_mut(),\n        );\n    }\n    \n    // Convert back to Ruby array\n    let result = RArray::new();\n    for val in data.result {\n        result.push(val)?;\n    }\n    \n    Ok(result)\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"csv-processing",children:"CSV Processing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use magnus::{RArray, RHash, Symbol, Error};\n\nfn parse_csv_to_hashes(csv_string: String) -> Result<RArray, Error> {\n    let mut reader = csv::Reader::from_reader(csv_string.as_bytes());\n    let headers = reader.headers()\n        .map_err(|e| Error::new(\n            magnus::exception::runtime_error(),\n            e.to_string()\n        ))?\n        .clone();\n    \n    let result = RArray::new();\n    \n    for record in reader.records() {\n        let record = record.map_err(|e| Error::new(\n            magnus::exception::runtime_error(),\n            e.to_string()\n        ))?;\n        \n        let hash = RHash::new();\n        for (header, value) in headers.iter().zip(record.iter()) {\n            hash.aset(Symbol::new(header), value)?;\n        }\n        \n        result.push(hash)?;\n    }\n    \n    Ok(result)\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"json-handling",children:"JSON Handling"}),"\n",(0,s.jsx)(n.h3,{id:"high-performance-json-parser",children:"High-Performance JSON Parser"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{RHash, RArray, Value, Error, Ruby, RString, value::ReprValue};\n\nfn parse_json(ruby: &Ruby, json_string: String) -> Result<Value, Error> {\n    let value: serde_json::Value = serde_json::from_str(&json_string)\n        .map_err(|e| Error::new(\n            magnus::exception::runtime_error(),\n            format!("JSON parse error: {}", e)\n        ))?;\n    \n    json_to_ruby(ruby, value)\n}\n\nfn json_to_ruby(ruby: &Ruby, value: serde_json::Value) -> Result<Value, Error> {\n    use serde_json::Value as J;\n    \n    match value {\n        J::Null => Ok(ruby.qnil().as_value()),\n        J::Bool(b) => Ok(if b { ruby.qtrue().as_value() } else { ruby.qfalse().as_value() }),\n        J::Number(n) => {\n            if let Some(i) = n.as_i64() {\n                Ok(ruby.integer_from_i64(i).as_value())\n            } else if let Some(f) = n.as_f64() {\n                Ok(ruby.float_from_f64(f).as_value())\n            } else {\n                Err(Error::new(\n                    magnus::exception::runtime_error(),\n                    "Number out of range"\n                ))\n            }\n        }\n        J::String(s) => Ok(RString::new(&s).as_value()),\n        J::Array(arr) => {\n            let ruby_array = RArray::with_capacity(arr.len());\n            for item in arr {\n                ruby_array.push(json_to_ruby(ruby, item)?)?;\n            }\n            Ok(ruby_array.as_value())\n        }\n        J::Object(obj) => {\n            let ruby_hash = RHash::new();\n            for (key, val) in obj {\n                ruby_hash.aset(key, json_to_ruby(ruby, val)?)?;\n            }\n            Ok(ruby_hash.as_value())\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"file-operations",children:"File Operations"}),"\n",(0,s.jsx)(n.h3,{id:"fast-file-processing",children:"Fast File Processing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{Error, RString};\nuse std::fs;\nuse std::io::{BufRead, BufReader};\n\nfn process_large_file(path: String, pattern: String) -> Result<i64, Error> {\n    let file = fs::File::open(&path)\n        .map_err(|e| Error::new(\n            magnus::exception::runtime_error(),\n            format!("Cannot open file: {}", e)\n        ))?;\n    \n    let reader = BufReader::new(file);\n    let mut count = 0i64;\n    \n    for line in reader.lines() {\n        let line = line.map_err(|e| Error::new(\n            magnus::exception::runtime_error(),\n            format!("Read error: {}", e)\n        ))?;\n        \n        if line.contains(&pattern) {\n            count += 1;\n        }\n    }\n    \n    Ok(count)\n}\n\nfn read_binary_file(path: String) -> Result<RString, Error> {\n    let data = fs::read(&path)\n        .map_err(|e| Error::new(\n            magnus::exception::runtime_error(),\n            format!("Cannot read file: {}", e)\n        ))?;\n    \n    // Return as binary string\n    Ok(RString::from_slice(&data))\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"cryptography",children:"Cryptography"}),"\n",(0,s.jsx)(n.h3,{id:"hash-functions",children:"Hash Functions"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use magnus::{RString, Error};\nuse sha2::{Sha256, Digest};\n\nfn sha256_hexdigest(input: RString) -> Result<String, Error> {\n    let data = unsafe { input.as_slice() };\n    \n    let mut hasher = Sha256::new();\n    hasher.update(data);\n    let result = hasher.finalize();\n    \n    Ok(hex::encode(result))\n}\n\nfn sha256_raw(input: RString) -> Result<RString, Error> {\n    let data = unsafe { input.as_slice() };\n    \n    let mut hasher = Sha256::new();\n    hasher.update(data);\n    let result = hasher.finalize();\n    \n    Ok(RString::from_slice(&result))\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"database-operations",children:"Database Operations"}),"\n",(0,s.jsx)(n.h3,{id:"connection-pool-pattern",children:"Connection Pool Pattern"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{Error};\nuse std::sync::{Arc, Mutex};\nuse once_cell::sync::Lazy;\n\n// Global connection pool\nstatic POOL: Lazy<Arc<Mutex<Vec<Connection>>>> = Lazy::new(|| {\n    Arc::new(Mutex::new(Vec::new()))\n});\n\nstruct Connection {\n    id: usize,\n    // Your actual connection here\n}\n\n#[magnus::wrap(class = "DatabasePool", free_immediately)]\nstruct DatabasePool;\n\nimpl DatabasePool {\n    fn acquire() -> Result<Connection, Error> {\n        let mut pool = POOL.lock()\n            .map_err(|_| Error::new(magnus::exception::runtime_error(), "Failed to acquire pool lock"))?;\n        \n        if let Some(conn) = pool.pop() {\n            Ok(conn)\n        } else {\n            // Create new connection\n            Ok(Connection { id: pool.len() })\n        }\n    }\n    \n    fn release(conn: Connection) -> Result<(), Error> {\n        let mut pool = POOL.lock()\n            .map_err(|_| Error::new(magnus::exception::runtime_error(), "Failed to acquire pool lock"))?;\n        pool.push(conn);\n        Ok(())\n    }\n    \n    fn with_connection<F, R>(f: F) -> Result<R, Error>\n    where\n        F: FnOnce(&Connection) -> Result<R, Error>,\n    {\n        let conn = Self::acquire()?;\n        let result = f(&conn);\n        Self::release(conn)?;\n        result\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"http-client",children:"HTTP Client"}),"\n",(0,s.jsx)(n.h3,{id:"simple-url-operations",children:"Simple URL Operations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{RHash, Error};\nuse url::Url;\n\nfn parse_url_components(url_string: String) -> Result<RHash, Error> {\n    let parsed = Url::parse(&url_string)\n        .map_err(|e| Error::new(\n            magnus::exception::arg_error(),\n            format!("Invalid URL: {}", e)\n        ))?;\n    \n    let result = RHash::new();\n    result.aset("scheme", parsed.scheme())?;\n    if let Some(host) = parsed.host_str() {\n        result.aset("host", host)?;\n    }\n    result.aset("path", parsed.path())?;\n    if let Some(port) = parsed.port() {\n        result.aset("port", port)?;\n    }\n    \n    Ok(result)\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"image-processing",children:"Image Processing"}),"\n",(0,s.jsx)(n.h3,{id:"basic-image-operations",children:"Basic Image Operations"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{RString, Error};\nuse image::ImageFormat;\n\nfn resize_image(\n    image_data: RString, \n    width: u32, \n    height: u32\n) -> Result<RString, Error> {\n    let bytes = unsafe { image_data.as_slice() };\n    \n    let img = image::load_from_memory(bytes)\n        .map_err(|e| Error::new(\n            magnus::exception::runtime_error(),\n            format!("Invalid image: {}", e)\n        ))?;\n    \n    let resized = img.resize_exact(width, height, image::imageops::FilterType::Lanczos3);\n    \n    let mut output = Vec::new();\n    use std::io::Cursor;\n    resized.write_to(&mut Cursor::new(&mut output), ImageFormat::Png)\n        .map_err(|e| Error::new(\n            magnus::exception::runtime_error(),\n            format!("Failed to encode image: {}", e)\n        ))?;\n    \n    Ok(RString::from_slice(&output))\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"performance-monitoring",children:"Performance Monitoring"}),"\n",(0,s.jsx)(n.h3,{id:"benchmarking-helper",children:"Benchmarking Helper"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{block::Proc, Value, Error};\nuse std::time::Instant;\n\nfn benchmark_block(iterations: usize, block: Proc) -> Result<f64, Error> {\n    let start = Instant::now();\n    \n    for _ in 0..iterations {\n        block.call::<_, Value>(())?;\n    }\n    \n    let duration = start.elapsed();\n    Ok(duration.as_secs_f64())\n}\n\nfn measure_memory<F, R>(f: F) -> Result<(R, usize), Error>\nwhere\n    F: FnOnce() -> Result<R, Error>,\n{\n    let before = get_memory_usage();\n    let result = f()?;\n    let after = get_memory_usage();\n    \n    Ok((result, after - before))\n}\n\nfn get_memory_usage() -> usize {\n    // Platform-specific memory measurement\n    #[cfg(target_os = "linux")]\n    {\n        use std::fs;\n        let status = fs::read_to_string("/proc/self/status")\n            .unwrap_or_else(|_| String::from("Unable to read status"));\n        // Parse VmRSS from status\n        0 // Placeholder\n    }\n    \n    #[cfg(not(target_os = "linux"))]\n    {\n        0 // Placeholder\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"thread-safety",children:"Thread Safety"}),"\n",(0,s.jsx)(n.h3,{id:"thread-safe-counter",children:"Thread-Safe Counter"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::Error;\nuse std::sync::{Arc, Mutex};\n\n#[magnus::wrap(class = "ThreadSafeCounter", free_immediately)]\nstruct ThreadSafeCounter {\n    value: Arc<Mutex<i64>>,\n}\n\nimpl ThreadSafeCounter {\n    fn new() -> Self {\n        ThreadSafeCounter {\n            value: Arc::new(Mutex::new(0)),\n        }\n    }\n    \n    fn increment(&self) -> Result<i64, Error> {\n        let mut val = self.value.lock()\n            .map_err(|_| Error::new(magnus::exception::runtime_error(), "Failed to acquire lock"))?;\n        *val += 1;\n        Ok(*val)\n    }\n    \n    fn value(&self) -> Result<i64, Error> {\n        let val = self.value.lock()\n            .map_err(|_| Error::new(magnus::exception::runtime_error(), "Failed to acquire lock"))?;\n        Ok(*val)\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"custom-iterators",children:"Custom Iterators"}),"\n",(0,s.jsx)(n.h3,{id:"ruby-style-enumerator",children:"Ruby-Style Enumerator"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{block::Proc, RArray, Value, Error};\n\n#[magnus::wrap(class = "RangeIterator", free_immediately)]\nstruct RangeIterator {\n    current: i64,\n    end: i64,\n    step: i64,\n}\n\nimpl RangeIterator {\n    fn new(start: i64, end: i64, step: Option<i64>) -> Self {\n        RangeIterator {\n            current: start,\n            end,\n            step: step.unwrap_or(1),\n        }\n    }\n    \n    fn each(&mut self, block: Proc) -> Result<(), Error> {\n        while self.current < self.end {\n            block.call::<_, Value>((self.current,))?;\n            self.current += self.step;\n        }\n        Ok(())\n    }\n    \n    fn to_a(&mut self) -> Result<RArray, Error> {\n        let array = RArray::new();\n        while self.current < self.end {\n            array.push(self.current)?;\n            self.current += self.step;\n        }\n        Ok(array)\n    }\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)("div",{className:"success-message",children:[(0,s.jsx)(n.h3,{id:"more-recipes-coming",children:"More Recipes Coming"}),(0,s.jsxs)(n.p,{children:["Have a pattern you'd like to see? ",(0,s.jsx)(n.a,{href:"https://github.com/oxidize-rb/rb-sys/issues",children:"Open an issue"})," or contribute your own."]})]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>o,x:()=>i});var t=r(6540);const s={},a=t.createContext(s);function o(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);