"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[2753],{5466:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"hello-rusty-documentation","title":"Hello Rusty!","description":"This section serves as a companion to the \\"Hello, Rusty!\\" example, a fundamental demonstration of building a Ruby gem with a Rust extension. We\'ll explore a more robust, production-oriented approach using the magnus library, which provides high-level, safe bindings to the Ruby C API.","source":"@site/docs/hello-rusty-documentation.mdx","sourceDirName":".","slug":"/hello-rusty-documentation","permalink":"/docs/hello-rusty-documentation","draft":false,"unlisted":false,"editUrl":"https://github.com/oxidize-rb/rb-sys/tree/main/docsite/docs/hello-rusty-documentation.mdx","tags":[],"version":"current","lastUpdatedBy":"Garen Torikian","lastUpdatedAt":1767647115000,"sidebarPosition":3,"frontMatter":{"sidebar_position":3}}');var r=t(4848),s=t(8453);const o={sidebar_position:3},l="Hello Rusty!",a={},d=[{value:"What We&#39;re Building",id:"what-were-building",level:2},{value:"Project Structure",id:"project-structure",level:2},{value:"Implementation Details",id:"implementation-details",level:2},{value:"Ruby Extension Configuration (<code>extconf.rb</code>)",id:"ruby-extension-configuration-extconfrb",level:3},{value:"The Rust Implementation (<code>lib.rs</code>)",id:"the-rust-implementation-librs",level:3},{value:"Key Improvements:",id:"key-improvements",level:4},{value:"The Ruby Wrapper (<code>lib/hello_rusty.rb</code>)",id:"the-ruby-wrapper-libhello_rustyrb",level:3},{value:"Trying It Out",id:"trying-it-out",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"hello-rusty",children:"Hello Rusty!"})}),"\n",(0,r.jsxs)(n.p,{children:['This section serves as a companion to the "Hello, Rusty!" example, a fundamental demonstration of building a Ruby gem with a Rust extension. We\'ll explore a more robust, production-oriented approach using the ',(0,r.jsx)(n.code,{children:"magnus"})," library, which provides high-level, safe bindings to the Ruby C API."]}),"\n",(0,r.jsx)(n.h2,{id:"what-were-building",children:"What We're Building"}),"\n",(0,r.jsxs)(n.p,{children:["A simple gem named ",(0,r.jsx)(n.code,{children:"HelloRusty"})," with a single method, ",(0,r.jsx)(n.code,{children:"greet"}),", that returns a string from Rust. We'll focus on writing safe, idiomatic code that is easy to maintain."]}),"\n",(0,r.jsx)(n.h2,{id:"project-structure",children:"Project Structure"}),"\n",(0,r.jsx)(n.p,{children:"The project structure remains standard for a gem with a native extension:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-plaintext",children:"hello_rusty/\n\u251c\u2500\u2500 Cargo.toml             # Rust package manifest\n\u251c\u2500\u2500 Gemfile               # Ruby dependencies\n\u251c\u2500\u2500 Rakefile              # Build automation\n\u251c\u2500\u2500 ext/                  # Native extension directory\n\u2502   \u2514\u2500\u2500 hello_rusty/      # Extension implementation\n\u2502       \u251c\u2500\u2500 Cargo.toml    # Rust crate configuration\n\u2502       \u251c\u2500\u2500 extconf.rb    # Ruby extension configuration\n\u2502       \u2514\u2500\u2500 src/          # Rust source code\n\u2502           \u2514\u2500\u2500 lib.rs    # Main implementation\n\u251c\u2500\u2500 hello_rusty.gemspec   # Gem specification\n\u2514\u2500\u2500 lib/                  # Ruby library code\n    \u2514\u2500\u2500 hello_rusty.rb    # Main Ruby module\n"})}),"\n",(0,r.jsx)(n.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,r.jsxs)(n.h3,{id:"ruby-extension-configuration-extconfrb",children:["Ruby Extension Configuration (",(0,r.jsx)(n.code,{children:"extconf.rb"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:["We use ",(0,r.jsx)(n.code,{children:"rb-sys"}),"'s ",(0,r.jsx)(n.code,{children:"ExtensionTask"})," to set up the build process for our native extension. This file remains simple:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",children:"# ext/hello_rusty/extconf.rb\nrequire 'rb_sys/extensiontask'\n\nRbSys::ExtensionTask.new('hello_rusty') do |ext|\n  ext.lib_dir = File.expand_path('../../lib/hello_rusty', __dir__)\nend\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"the-rust-implementation-librs",children:["The Rust Implementation (",(0,r.jsx)(n.code,{children:"lib.rs"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:["Here, instead of using the low-level ",(0,r.jsx)(n.code,{children:"rb-sys"})," APIs directly, we'll use ",(0,r.jsx)(n.code,{children:"magnus"})," to create a safer and more ergonomic implementation."]}),"\n",(0,r.jsxs)(n.p,{children:["First, let's update our ",(0,r.jsx)(n.code,{children:"Cargo.toml"})," for the extension:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-toml",children:'# ext/hello_rusty/Cargo.toml\n[package]\nname = "hello_rusty"\nversion = "0.1.0"\nedition = "2021"\n\n[dependencies]\nmagnus = "0.7"\n\n[lib]\ncrate-type = ["cdylib"]\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Now, the Rust code in ",(0,r.jsx)(n.code,{children:"ext/hello_rusty/src/lib.rs"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-rust",children:'use magnus::{function, prelude::*, Error, Ruby};\n\n// The Ruby-visible function. It takes no arguments and returns a String.\nfn greet() -> String {\n    "Hello from Rust!".to_string()\n}\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let module = ruby.define_module("HelloRusty")?;\n    module.define_singleton_method("greet", function!(greet, 0))?;\n    Ok(())\n}\n'})}),"\n",(0,r.jsx)(n.h4,{id:"key-improvements",children:"Key Improvements:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"#[magnus::init]"}),":"]})," This attribute macro handles the boilerplate of setting up the ",(0,r.jsx)(n.code,{children:"Init_..."})," function. It provides a safe, managed ",(0,r.jsx)(n.code,{children:"Ruby"})," context."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"Ruby"})," Handle:"]})," The ",(0,r.jsx)(n.code,{children:"init"})," function receives a ",(0,r.jsx)(n.code,{children:"&Ruby"})," handle, which is a token that ensures the Ruby VM is properly initialized. All interactions with Ruby happen through this handle."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Result-based Error Handling:"})," The ",(0,r.jsx)(n.code,{children:"init"})," function returns a ",(0,r.jsx)(n.code,{children:"Result<(), magnus::Error>"}),". If any of the ",(0,r.jsx)(n.code,{children:"define_module"})," or ",(0,r.jsx)(n.code,{children:"define_singleton_method"})," calls fail, the error is propagated and converted into a Ruby exception. This is much safer than ",(0,r.jsx)(n.code,{children:"unsafe"})," calls that could crash the interpreter."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"function!"})," macro:"]})," This macro from ",(0,r.jsx)(n.code,{children:"magnus"})," wraps our Rust function (",(0,r.jsx)(n.code,{children:"greet"}),") and makes it callable from Ruby, automatically handling the conversion of arguments and return values."]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"the-ruby-wrapper-libhello_rustyrb",children:["The Ruby Wrapper (",(0,r.jsx)(n.code,{children:"lib/hello_rusty.rb"}),")"]}),"\n",(0,r.jsx)(n.p,{children:"The Ruby side remains simple, loading the compiled extension:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",children:'require_relative "hello_rusty/version"\nrequire_relative "hello_rusty/hello_rusty" # This loads the .so/.dylib file\n\nmodule HelloRusty\n  class Error < StandardError; end\n  # Your Ruby code goes here...\nend\n'})}),"\n",(0,r.jsx)(n.h2,{id:"trying-it-out",children:"Trying It Out"}),"\n",(0,r.jsxs)(n.p,{children:["Once the gem is compiled (e.g., via ",(0,r.jsx)(n.code,{children:"bundle exec rake compile"}),"), you can use it in Ruby:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ruby",children:"require 'hello_rusty'\n\nputs HelloRusty.greet\n# => \"Hello from Rust!\"\n"})}),"\n",(0,r.jsx)(n.p,{children:"This refactored example provides a much stronger foundation for building real-world Rusty Ruby gems by emphasizing safety, error handling, and maintainability."})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var i=t(6540);const r={},s=i.createContext(r);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);