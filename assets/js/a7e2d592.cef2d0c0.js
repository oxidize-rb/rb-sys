"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[62],{4432:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"core-concepts","title":"Core Concepts","description":"Understand the fundamental concepts of building Ruby extensions with Rust, including how rb-sys bridges the two languages.","source":"@site/docs/core-concepts.mdx","sourceDirName":".","slug":"/core-concepts","permalink":"/docs/core-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/oxidize-rb/rb-sys/tree/main/docsite/docs/core-concepts.mdx","tags":[],"version":"current","lastUpdatedBy":"Ian Ker-Seymer","lastUpdatedAt":1752599549000,"sidebarPosition":3,"frontMatter":{"id":"core-concepts","title":"Core Concepts","sidebar_position":3,"keywords":["core concepts","ruby c api","magnus","rb-sys","memory","ffi"],"description":"Understand the fundamental concepts of building Ruby extensions with Rust, including how rb-sys bridges the two languages."},"sidebar":"docsSidebar","previous":{"title":"\ud83d\ude80 Quick Start (15 minutes)","permalink":"/docs/quick-start"},"next":{"title":"Project Setup & Structure","permalink":"/docs/project-setup"}}');var i=s(4848),t=s(8453);const l={id:"core-concepts",title:"Core Concepts",sidebar_position:3,keywords:["core concepts","ruby c api","magnus","rb-sys","memory","ffi"],description:"Understand the fundamental concepts of building Ruby extensions with Rust, including how rb-sys bridges the two languages."},o="Core Concepts",a={},c=[{value:"The Ruby-Rust Bridge",id:"the-ruby-rust-bridge",level:2},{value:"Layer 1: Ruby C API",id:"layer-1-ruby-c-api",level:3},{value:"Layer 2: rb-sys (Low-Level)",id:"layer-2-rb-sys-low-level",level:3},{value:"Layer 3: Magnus (High-Level)",id:"layer-3-magnus-high-level",level:3},{value:"Memory Models: Ruby vs Rust",id:"memory-models-ruby-vs-rust",level:2},{value:"The Bridge Challenge",id:"the-bridge-challenge",level:3},{value:"Type Conversions",id:"type-conversions",level:2},{value:"Basic Type Mappings",id:"basic-type-mappings",level:3},{value:"Working with Ruby Objects",id:"working-with-ruby-objects",level:3},{value:"The Global VM Lock (GVL)",id:"the-global-vm-lock-gvl",level:2},{value:"When to Release the GVL",id:"when-to-release-the-gvl",level:3},{value:"Error Handling Philosophy",id:"error-handling-philosophy",level:2},{value:"Error Handling Best Practices",id:"error-handling-best-practices",level:3},{value:"Build Process Deep Dive",id:"build-process-deep-dive",level:2},{value:"Key Files",id:"key-files",level:3},{value:"Platform Considerations",id:"platform-considerations",level:2},{value:"Cross-Platform Safety",id:"cross-platform-safety",level:3},{value:"Platform-Specific Code",id:"platform-specific-code",level:3},{value:"Performance Mindset",id:"performance-mindset",level:2},{value:"Performance Example",id:"performance-example",level:3},{value:"Security Considerations",id:"security-considerations",level:2},{value:"\ud83c\udfaf Key Takeaways",id:"-key-takeaways",level:2},{value:"\ud83d\udcda Next Steps",id:"-next-steps",level:2},{value:"\ud83e\udde0 Understanding Complete!",id:"-understanding-complete",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"core-concepts",children:"Core Concepts"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Time:"})," 20 minutes | ",(0,i.jsx)(n.strong,{children:"Difficulty:"})," Intermediate"]}),"\n",(0,i.jsx)(n.p,{children:"Understanding these core concepts will help you build safe, efficient Ruby extensions with Rust."}),"\n",(0,i.jsx)(n.h2,{id:"the-ruby-rust-bridge",children:"The Ruby-Rust Bridge"}),"\n",(0,i.jsx)(n.p,{children:"rb-sys creates a bridge between Ruby and Rust through three layers:"}),"\n",(0,i.jsx)("div",{className:"architecture-diagram",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mermaid",children:'graph TB\n    subgraph "Your Code"\n        A[Ruby Application]\n        B[Rust Extension]\n    end\n    \n    subgraph "High-Level API"\n        C[Magnus]\n    end\n    \n    subgraph "Low-Level Bindings"\n        D[rb-sys]\n    end\n    \n    subgraph "Ruby Runtime"\n        E[Ruby C API]\n        F[Ruby VM]\n    end\n    \n    A --\x3e|calls| B\n    B --\x3e|uses| C\n    C --\x3e|wraps| D\n    D --\x3e|binds to| E\n    E --\x3e|interfaces with| F\n    \n    style A fill:#CC342D,color:#fff\n    style B fill:#000,color:#fff\n    style C fill:#CE422B,color:#fff\n    style D fill:#f9f9f9\n    style E fill:#CC342D,color:#fff\n    style F fill:#CC342D,color:#fff\n'})})}),"\n",(0,i.jsx)(n.h3,{id:"layer-1-ruby-c-api",children:"Layer 1: Ruby C API"}),"\n",(0,i.jsx)(n.p,{children:"Ruby exposes a C API that allows native extensions to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Create Ruby objects"}),"\n",(0,i.jsx)(n.li,{children:"Call Ruby methods"}),"\n",(0,i.jsx)(n.li,{children:"Define new classes and modules"}),"\n",(0,i.jsx)(n.li,{children:"Manage memory with Ruby's GC"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"layer-2-rb-sys-low-level",children:"Layer 2: rb-sys (Low-Level)"}),"\n",(0,i.jsx)(n.p,{children:"rb-sys provides:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Safe Rust bindings"})," to Ruby's C API"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Automatic header generation"})," using bindgen"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Cross-platform compatibility"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Build system integration"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"layer-3-magnus-high-level",children:"Layer 3: Magnus (High-Level)"}),"\n",(0,i.jsx)(n.p,{children:"Magnus provides:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Ergonomic Rust API"})," that feels like Ruby"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type safety"})," with compile-time checks"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory safety"})," guarantees"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Automatic conversions"})," between Ruby and Rust types"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"memory-models-ruby-vs-rust",children:"Memory Models: Ruby vs Rust"}),"\n",(0,i.jsx)(n.p,{children:"Understanding how memory works in both languages is crucial:"}),"\n",(0,i.jsxs)("table",{className:"comparison-table",children:[(0,i.jsx)("thead",{children:(0,i.jsxs)("tr",{children:[(0,i.jsx)("th",{children:"Aspect"}),(0,i.jsx)("th",{children:"Ruby"}),(0,i.jsx)("th",{children:"Rust"})]})}),(0,i.jsxs)("tbody",{children:[(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("strong",{children:"Memory Management"})}),(0,i.jsx)("td",{children:"Garbage Collection (GC)"}),(0,i.jsx)("td",{children:"Ownership & Borrowing"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("strong",{children:"Allocation"})}),(0,i.jsx)("td",{children:"Automatic on object creation"}),(0,i.jsx)("td",{children:"Explicit with ownership"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("strong",{children:"Deallocation"})}),(0,i.jsx)("td",{children:"GC decides when"}),(0,i.jsx)("td",{children:"When owner goes out of scope"})]}),(0,i.jsxs)("tr",{children:[(0,i.jsx)("td",{children:(0,i.jsx)("strong",{children:"References"})}),(0,i.jsx)("td",{children:"All references are valid"}),(0,i.jsx)("td",{children:"Compiler enforces validity"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"the-bridge-challenge",children:"The Bridge Challenge"}),"\n",(0,i.jsx)(n.p,{children:"When Rust holds Ruby objects:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Ruby's GC doesn't know about Rust's references"}),"\n",(0,i.jsx)(n.li,{children:"Objects might be collected while Rust still uses them"}),"\n",(0,i.jsx)(n.li,{children:"This causes segmentation faults"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Solution:"})," Tell Ruby's GC about our references through marking."]}),"\n",(0,i.jsx)(n.h2,{id:"type-conversions",children:"Type Conversions"}),"\n",(0,i.jsx)(n.p,{children:"Magnus handles conversions between Ruby and Rust types automatically:"}),"\n",(0,i.jsx)(n.h3,{id:"basic-type-mappings",children:"Basic Type Mappings"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// Automatic conversions\nfn example(\n    s: String,        // Ruby String \u2192 Rust String\n    i: i64,          // Ruby Integer \u2192 Rust i64\n    f: f64,          // Ruby Float \u2192 Rust f64\n    b: bool,         // Ruby true/false \u2192 Rust bool\n    v: Vec<String>,  // Ruby Array \u2192 Rust Vec\n) -> String {        // Rust String \u2192 Ruby String\n    format!("Received: {} {} {} {} {:?}", s, i, f, b, v)\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"working-with-ruby-objects",children:"Working with Ruby Objects"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use magnus::{RHash, RArray, Value, Symbol, Error, TryConvert};\n\n// Accept any Ruby object\nfn process_data(value: Value) -> Result<String, Error> {\n    // Check type at runtime\n    if let Ok(hash) = RHash::try_convert(value) {\n        // Work with Ruby Hash\n        let size = hash.len();\n        Ok(format!("Hash with {} entries", size))\n    } else if let Ok(array) = RArray::try_convert(value) {\n        // Work with Ruby Array\n        Ok(format!("Array with {} elements", array.len()))\n    } else {\n        Ok("Unknown type".to_string())\n    }\n}\n\n// Working with symbols\nfn symbol_example() -> Symbol {\n    Symbol::new("success")  // Returns :success in Ruby\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"the-global-vm-lock-gvl",children:"The Global VM Lock (GVL)"}),"\n",(0,i.jsx)(n.p,{children:"Ruby uses a Global VM Lock (GVL/GIL) that prevents true parallelism:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use rb_sys::rb_thread_call_without_gvl;\nuse std::os::raw::c_void;\n\n// Structure to hold data\nstruct ProcessData {\n    input: Vec<u8>,\n    output: Vec<u8>,\n}\n\n// CPU-intensive operation\nextern "C" fn expensive_computation(data: *mut c_void) -> *mut c_void {\n    unsafe {\n        let data = &mut *(data as *mut ProcessData);\n        // Process data...\n        data.output = data.input.clone();\n    }\n    std::ptr::null_mut()\n}\n\n// Release GVL for long operations\nfn process_large_file(data: Vec<u8>) -> Vec<u8> {\n    // For operations > 100ms, release the GVL\n    if data.len() > 1_000_000 {\n        let mut process_data = ProcessData {\n            input: data,\n            output: Vec::new(),\n        };\n        \n        unsafe {\n            rb_thread_call_without_gvl(\n                Some(expensive_computation),\n                &mut process_data as *mut _ as *mut c_void,\n                None,\n                std::ptr::null_mut(),\n            );\n        }\n        \n        process_data.output\n    } else {\n        data\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"when-to-release-the-gvl",children:"When to Release the GVL"}),"\n",(0,i.jsxs)(n.p,{children:["\u2705 ",(0,i.jsx)(n.strong,{children:"Release for:"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"CPU-intensive computations"}),"\n",(0,i.jsx)(n.li,{children:"Network I/O operations"}),"\n",(0,i.jsx)(n.li,{children:"File system operations"}),"\n",(0,i.jsx)(n.li,{children:"Cryptographic operations"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["\u274c ",(0,i.jsx)(n.strong,{children:"Don't release for:"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Ruby object manipulation"}),"\n",(0,i.jsx)(n.li,{children:"Quick operations (< 10ms)"}),"\n",(0,i.jsx)(n.li,{children:"Memory allocation/deallocation"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"error-handling-philosophy",children:"Error Handling Philosophy"}),"\n",(0,i.jsxs)(n.p,{children:["rb-sys embraces Rust's ",(0,i.jsx)(n.code,{children:"Result"})," type for error handling:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use magnus::{Error, exception, function, Ruby};\n\nfn divide(a: f64, b: f64) -> Result<f64, Error> {\n    if b == 0.0 {\n        Err(Error::new(\n            exception::zero_div_error(),\n            "divided by 0"\n        ))\n    } else {\n        Ok(a / b)\n    }\n}\n\n// Magnus automatically converts Result to Ruby exceptions\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let module = ruby.define_module("MyMath")?;\n    module.define_module_function("divide", function!(divide, 2))?;\n    Ok(())\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"error-handling-best-practices",children:"Error Handling Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Result everywhere"})," - Let Magnus handle conversions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Map errors appropriately"})," - Use Ruby's exception hierarchy"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Provide context"})," - Include helpful error messages"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fail fast"})," - Don't hide errors"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"build-process-deep-dive",children:"Build Process Deep Dive"}),"\n",(0,i.jsx)(n.p,{children:"Understanding the build process helps debug issues:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-mermaid",children:"flowchart LR\n    A[extconf.rb] --\x3e B[Makefile]\n    B --\x3e C[cargo build]\n    C --\x3e D[lib.rs \u2192 .so/.bundle]\n    D --\x3e E[Ruby loads extension]\n    \n    F[Cargo.toml] --\x3e C\n    G[build.rs] --\x3e C\n"})}),"\n",(0,i.jsx)(n.h3,{id:"key-files",children:"Key Files"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"extconf.rb"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ruby",children:'require "mkmf"\nrequire "rb_sys/mkmf"\n\ncreate_rust_makefile("my_gem/my_gem") do |r|\n  # Optional: specify Rust edition\n  r.extra_rustflags = ["--edition", "2021"]\n  \n  # Optional: enable specific features\n  r.features = ["performance"]\nend\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Cargo.toml"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-toml",children:'[dependencies]\nmagnus = { version = "0.7", features = ["embed"] }\nrb-sys = { version = "0.9", features = ["stable-api-compiled"] }\n\n[features]\ndefault = []\nperformance = ["lto"]  # Link-time optimization\n\n[profile.release]\nlto = true\ncodegen-units = 1\n'})}),"\n",(0,i.jsx)(n.h2,{id:"platform-considerations",children:"Platform Considerations"}),"\n",(0,i.jsx)(n.p,{children:"rb-sys handles platform differences automatically:"}),"\n",(0,i.jsx)(n.h3,{id:"cross-platform-safety",children:"Cross-Platform Safety"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'// rb-sys handles platform differences\nuse magnus::RString;\n\n// Same code works on all platforms\nfn create_string() -> RString {\n    RString::new("Hello from any platform!")\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"platform-specific-code",children:"Platform-Specific Code"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'#[cfg(target_os = "windows")]\nfn platform_name() -> &\'static str {\n    "Windows"\n}\n\n#[cfg(target_os = "macos")]\nfn platform_name() -> &\'static str {\n    "macOS"\n}\n\n#[cfg(target_os = "linux")]\nfn platform_name() -> &\'static str {\n    "Linux"\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"performance-mindset",children:"Performance Mindset"}),"\n",(0,i.jsx)(n.p,{children:"When building extensions, think about:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Allocation costs"})," - Minimize Ruby object creation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Conversion overhead"})," - Batch operations when possible"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"GVL contention"})," - Release for long operations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory locality"})," - Process data in chunks"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"performance-example",children:"Performance Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:"use magnus::{RArray, Error, TryConvert};\n\n// \u274c Inefficient: Many Ruby allocations\nfn inefficient_sum(numbers: Vec<i64>) -> i64 {\n    numbers.iter().sum()  // Converts entire Vec at once\n}\n\n// \u2705 Efficient: Process without conversions\nfn efficient_sum(array: RArray) -> Result<i64, Error> {\n    let mut sum = 0i64;\n    \n    // Iterate without converting to Vec\n    for item in array.each() {\n        sum += i64::try_convert(item?)?;\n    }\n    \n    Ok(sum)\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,i.jsx)(n.p,{children:"Building safe extensions requires attention to:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Input validation"})," - Never trust user input"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Buffer bounds"})," - Use Rust's safety guarantees"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Integer overflow"})," - Use checked arithmetic"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Resource limits"})," - Prevent DoS attacks"]}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-rust",children:'use magnus::{Error, Ruby};\n\nfn safe_operation(ruby: &Ruby, input: String) -> Result<String, Error> {\n    // Validate input length\n    const MAX_LENGTH: usize = 1_000_000;\n    if input.len() > MAX_LENGTH {\n        return Err(Error::new(\n            ruby.exception_arg_error(),\n            "input too large"\n        ));\n    }\n    \n    // Use checked arithmetic\n    let count = input.chars().count();\n    let doubled = count.checked_mul(2).ok_or_else(|| {\n        Error::new(ruby.exception_range_error(), "overflow")\n    })?;\n    \n    Ok(format!("Processed {} characters", doubled))\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"-key-takeaways",children:"\ud83c\udfaf Key Takeaways"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"rb-sys provides the bridge"})," between Ruby and Rust"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Magnus makes it ergonomic"})," with high-level APIs"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Memory safety requires marking"})," Ruby objects"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type conversions are automatic"})," but have overhead"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"The GVL limits parallelism"})," but can be released"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Errors use Result"})," and convert to exceptions"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Platform differences are handled"})," automatically"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Performance requires thought"})," about allocations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Security is critical"})," - validate everything"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"-next-steps",children:"\ud83d\udcda Next Steps"}),"\n",(0,i.jsx)(n.p,{children:"Now that you understand the core concepts:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"project-setup",children:(0,i.jsx)(n.strong,{children:"Project Setup"})})," - Structure your gem properly"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"working-with-ruby-objects",children:(0,i.jsx)(n.strong,{children:"Working with Ruby Objects"})})," - Manipulate Ruby data"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"memory-management",children:(0,i.jsx)(n.strong,{children:"Memory Management"})})," - Deep dive into GC integration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"error-handling",children:(0,i.jsx)(n.strong,{children:"Error Handling"})})," - Build robust extensions"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsxs)("div",{className:"success-message",children:[(0,i.jsx)(n.h3,{id:"-understanding-complete",children:"\ud83e\udde0 Understanding Complete!"}),(0,i.jsx)(n.p,{children:"You now have a solid foundation in rb-sys core concepts. Ready to build amazing extensions!"})]})]})}function u(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>o});var r=s(6540);const i={},t=r.createContext(i);function l(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);