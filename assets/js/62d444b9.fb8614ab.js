"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[6208],{223:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>i,metadata:()=>r,toc:()=>h});const r=JSON.parse('{"id":"performance","title":"Performance & Best Practices","description":"One of the primary reasons to use Rust for a Ruby native extension is to improve performance. This guide covers key concepts and best practices for writing high-performance extensions with rb-sys.","source":"@site/docs/performance.mdx","sourceDirName":".","slug":"/performance","permalink":"/docs/performance","draft":false,"unlisted":false,"editUrl":"https://github.com/oxidize-rb/rb-sys/tree/main/docsite/docs/performance.mdx","tags":[],"version":"current","lastUpdatedBy":"Ian Ker-Seymer","lastUpdatedAt":1765939306000,"sidebarPosition":10,"frontMatter":{"id":"performance","title":"Performance & Best Practices","sidebar_position":10},"sidebar":"docsSidebar","previous":{"title":"Troubleshooting","permalink":"/docs/troubleshooting"},"next":{"title":"Memory Management & Safety","permalink":"/docs/memory-management"}}');var s=t(4848),o=t(8453);const i={id:"performance",title:"Performance & Best Practices",sidebar_position:10},a="Performance & Best Practices",c={},h=[{value:"The FFI Boundary Cost",id:"the-ffi-boundary-cost",level:2},{value:"Benchmarking",id:"benchmarking",level:2},{value:"Best Practices for Data Conversions",id:"best-practices-for-data-conversions",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"performance--best-practices",children:"Performance & Best Practices"})}),"\n",(0,s.jsxs)(n.p,{children:["One of the primary reasons to use Rust for a Ruby native extension is to improve performance. This guide covers key concepts and best practices for writing high-performance extensions with ",(0,s.jsx)(n.code,{children:"rb-sys"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"the-ffi-boundary-cost",children:"The FFI Boundary Cost"}),"\n",(0,s.jsx)(n.p,{children:'Calling from Ruby into Rust (and back) is not free. This transition is known as the "FFI (Foreign Function Interface) boundary." Each time your code crosses this boundary, there is a small but non-trivial amount of overhead.'}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:'Best Practice: Avoid "Chatty" Calls'})}),"\n",(0,s.jsx)(n.p,{children:'To minimize this overhead, you should design your extension\'s API to be "chunky" rather than "chatty."'}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Chatty (less performant):"})," A loop in Ruby that calls a Rust function on every iteration to process a small piece of data."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Chunky (more performant):"})," A single call from Ruby that passes a large collection (e.g., a Ruby ",(0,s.jsx)(n.code,{children:"Array"}),") to a Rust function, which then iterates over the data on the Rust side."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:'(Placeholder: This section can be expanded with a code example showing a "chatty" vs. "chunky" API design.)'})}),"\n",(0,s.jsx)(n.h2,{id:"benchmarking",children:"Benchmarking"}),"\n",(0,s.jsx)(n.p,{children:"Quantitative data is the best way to demonstrate a performance improvement. You should always benchmark your code to prove that the Rust extension is faster than a pure Ruby equivalent."}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"rb-sys"})," project itself includes a ",(0,s.jsx)(n.code,{children:"bench/"})," directory with benchmarks that you can use as a reference for setting up your own."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Recipe: Before-and-After Benchmark"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"(Placeholder: This section can be expanded with a full benchmarking example for a function (e.g., the JSON or Markdown parser from the examples), showing:)"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.em,{children:"A pure Ruby implementation of a function."})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.em,{children:"The Rust-accelerated version."})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.em,{children:["A benchmark script (using a library like ",(0,s.jsx)(n.code,{children:"benchmark-ips"}),") that measures and compares both, showing the performance gain."]})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-for-data-conversions",children:"Best Practices for Data Conversions"}),"\n",(0,s.jsx)(n.p,{children:"A common performance consideration is when and how to convert Ruby objects into native Rust structs."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Working directly with Ruby types:"})," Using ",(0,s.jsx)(n.code,{children:"rb-sys"}),"'s wrappers around Ruby objects (like ",(0,s.jsx)(n.code,{children:"RString"}),", ",(0,s.jsx)(n.code,{children:"RArray"}),") can be efficient if you only need to perform a few operations or pass them to other C API functions."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Converting to native Rust structs:"})," If you are performing many complex computations, it is often more performant to convert the Ruby objects into native Rust ",(0,s.jsx)(n.code,{children:"struct"}),"s at the beginning of your function. This allows the Rust compiler to perform more optimizations, as it has full knowledge of the data layout."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"(Placeholder: This section can be expanded with guidelines and code examples showing when to prefer one approach over the other.)"})})]})}function l(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(6540);const s={},o=r.createContext(s);function i(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);