"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[324],{2829:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"error-handling","title":"Error Handling","description":"This guide covers how to handle errors in Rust and correctly map them to Ruby exceptions. Proper error handling is critical to prevent crashes in the Ruby VM.","source":"@site/docs/error-handling.mdx","sourceDirName":".","slug":"/error-handling","permalink":"/docs/error-handling","draft":false,"unlisted":false,"editUrl":"https://github.com/oxidize-rb/rb-sys/tree/main/docsite/docs/error-handling.mdx","tags":[],"version":"current","lastUpdatedBy":"Garen Torikian","lastUpdatedAt":1770941528000,"frontMatter":{"id":"error-handling","title":"Error Handling"},"sidebar":"docsSidebar","previous":{"title":"Classes & Modules","permalink":"/docs/classes-and-modules"},"next":{"title":"Testing","permalink":"/docs/testing"}}');var o=n(4848),t=n(8453);const i={id:"error-handling",title:"Error Handling"},l="Error Handling",c={},a=[{value:"<code>Result</code> vs. <code>panic!</code>",id:"result-vs-panic",level:2},{value:"Mapping Rust Errors to Ruby Exceptions",id:"mapping-rust-errors-to-ruby-exceptions",level:2},{value:"Custom Exception Classes",id:"custom-exception-classes",level:2},{value:"Propagating Errors with <code>?</code>",id:"propagating-errors-with-",level:2},{value:"Handling Panics",id:"handling-panics",level:2},{value:"Handling <code>RefCell</code> Borrows",id:"handling-refcell-borrows",level:2}];function u(e){const r={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.header,{children:(0,o.jsx)(r.h1,{id:"error-handling",children:"Error Handling"})}),"\n",(0,o.jsx)(r.p,{children:"This guide covers how to handle errors in Rust and correctly map them to Ruby exceptions. Proper error handling is critical to prevent crashes in the Ruby VM."}),"\n",(0,o.jsxs)(r.h2,{id:"result-vs-panic",children:[(0,o.jsx)(r.code,{children:"Result"})," vs. ",(0,o.jsx)(r.code,{children:"panic!"})]}),"\n",(0,o.jsxs)(r.ul,{children:["\n",(0,o.jsxs)(r.li,{children:[(0,o.jsxs)(r.strong,{children:[(0,o.jsx)(r.code,{children:"Result<T, magnus::Error>"}),":"]})," For recoverable errors. Functions that can fail should return a ",(0,o.jsx)(r.code,{children:"Result"}),". Magnus automatically converts the ",(0,o.jsx)(r.code,{children:"Err"})," variant into a Ruby exception that can be rescued in Ruby code."]}),"\n",(0,o.jsxs)(r.li,{children:[(0,o.jsxs)(r.strong,{children:[(0,o.jsx)(r.code,{children:"panic!"}),":"]})," For unrecoverable errors (i.e., bugs). A panic in your Rust code will crash the entire Ruby process. ",(0,o.jsx)(r.strong,{children:"Avoid panics in production code."})]}),"\n"]}),"\n",(0,o.jsx)(r.h2,{id:"mapping-rust-errors-to-ruby-exceptions",children:"Mapping Rust Errors to Ruby Exceptions"}),"\n",(0,o.jsxs)(r.p,{children:["Return a ",(0,o.jsx)(r.code,{children:"magnus::Error"})," to raise a Ruby exception. You can create an error from any of Ruby's standard exception classes."]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-rust",children:'use magnus::{Error, Ruby};\n\nfn divide(ruby: &Ruby, a: f64, b: f64) -> Result<f64, Error> {\n    if b == 0.0 {\n        Err(Error::new(ruby.exception_zero_div_error(), "Division by zero")) // Becomes `ZeroDivisionError` in Ruby.\n    } else {\n        Ok(a / b)\n    }\n}\n\nfn get_first(ruby: &Ruby, array: &[i64]) -> Result<i64, Error> {\n    array.get(0).copied().ok_or_else(|| {\n        Error::new(ruby.exception_index_error(), "index 0 out of bounds") // Becomes an `IndexError`.\n    })\n}\n'})}),"\n",(0,o.jsx)(r.h2,{id:"custom-exception-classes",children:"Custom Exception Classes"}),"\n",(0,o.jsx)(r.p,{children:"Define your own exception classes in a module to provide more specific error information."}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-rust",children:'use magnus::{prelude::*, Error, Ruby, ExceptionClass, RModule}; // Add ExceptionClass, RModule\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let module = ruby.define_module("MyGem")?;\n    let _custom_error = module.define_error("CustomError", ruby.exception_standard_error())?; // Fix deprecated exception\n    Ok(()) // You can now raise `MyGem::CustomError`.\n}\n\nfn do_something(ruby: &Ruby) -> Result<(), Error> {\n    // Correct way to get nested class in magnus 0.8\n    let my_error_module: RModule = ruby.class_object().const_get("MyGem")?;\n    let my_error_class: ExceptionClass = my_error_module.const_get("CustomError")?;\n    Err(Error::new(my_error_class, "something went wrong"))\n}\n'})}),"\n",(0,o.jsxs)(r.h2,{id:"propagating-errors-with-",children:["Propagating Errors with ",(0,o.jsx)(r.code,{children:"?"})]}),"\n",(0,o.jsxs)(r.p,{children:["The ",(0,o.jsx)(r.code,{children:"?"})," operator is the idiomatic way to propagate errors up the call stack."]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-rust",children:"use magnus::{Error, Ruby, Value};\n\nfn step_one(_ruby: &Ruby, input: Value) -> Result<Value, Error> { Ok(input) } // ... might fail\nfn step_two(_ruby: &Ruby, input: Value) -> Result<Value, Error> { Ok(input) } // ... might fail\n\nfn multi_step_process(ruby: &Ruby, value: Value) -> Result<Value, Error> {\n    let step1_result = step_one(ruby, value)?; // Returns early on error.\n    let step2_result = step_two(ruby, step1_result)?;\n    Ok(step2_result)\n}\n"})}),"\n",(0,o.jsx)(r.h2,{id:"handling-panics",children:"Handling Panics"}),"\n",(0,o.jsxs)(r.p,{children:["If you must use a library that can panic, wrap the call in ",(0,o.jsx)(r.code,{children:"std::panic::catch_unwind"})," to convert the panic into a Ruby ",(0,o.jsx)(r.code,{children:"RuntimeError"}),"."]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-rust",children:'use magnus::{Error, Ruby};\nuse std::panic::catch_unwind;\n\nfn might_panic() { panic!("this should not happen"); }\n\nfn safe_wrapper(ruby: &Ruby) -> Result<(), Error> {\n    let result = catch_unwind(|| { might_panic(); });\n    match result {\n        Ok(_) => Ok(()),\n        Err(_) => Err(Error::new(ruby.exception_runtime_error(), "Internal Rust panic occurred.")),\n    }\n}\n'})}),"\n",(0,o.jsxs)(r.h2,{id:"handling-refcell-borrows",children:["Handling ",(0,o.jsx)(r.code,{children:"RefCell"})," Borrows"]}),"\n",(0,o.jsxs)(r.p,{children:["Incorrect ",(0,o.jsx)(r.code,{children:"RefCell"})," usage can cause panics. Use ",(0,o.jsx)(r.code,{children:"try_borrow_mut"})," to handle borrow errors gracefully."]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-rust",children:'use std::cell::RefCell;\nuse magnus::{Error, Ruby};\n\n#[magnus::wrap(class = "Counter")]\nstruct Counter(RefCell<i64>);\n\nimpl Counter {\n    fn try_increment(&self, ruby: &Ruby) -> Result<(), Error> {\n        match self.0.try_borrow_mut() {\n            Ok(mut value) => { *value += 1; Ok(()) },\n            Err(_) => Err(Error::new(ruby.exception_runtime_error(), "Counter is already borrowed.")),\n        }\n    }\n}\n'})})]})}function d(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>i,x:()=>l});var s=n(6540);const o={},t=s.createContext(o);function i(e){const r=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(t.Provider,{value:r},e.children)}}}]);