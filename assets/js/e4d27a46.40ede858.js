"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[8136],{5489:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"project-setup","title":"Project Setup & Structure","description":"Learn how to properly structure a Ruby gem with Rust extensions, including workspace setup, dependency management, and build configuration.","source":"@site/docs/project-setup.mdx","sourceDirName":".","slug":"/project-setup","permalink":"/docs/project-setup","draft":false,"unlisted":false,"editUrl":"https://github.com/oxidize-rb/rb-sys/tree/main/docsite/docs/project-setup.mdx","tags":[],"version":"current","lastUpdatedBy":"Garen Torikian","lastUpdatedAt":1769966166000,"sidebarPosition":4,"frontMatter":{"id":"project-setup","title":"Project Setup & Structure","sidebar_position":4,"keywords":["project setup","gem structure","cargo workspace","bundler","rake"],"description":"Learn how to properly structure a Ruby gem with Rust extensions, including workspace setup, dependency management, and build configuration."},"sidebar":"docsSidebar","previous":{"title":"Core Concepts","permalink":"/docs/core-concepts"},"next":{"title":"Basic Patterns","permalink":"/docs/basic-patterns"}}');var t=r(4848),i=r(8453);const a={id:"project-setup",title:"Project Setup & Structure",sidebar_position:4,keywords:["project setup","gem structure","cargo workspace","bundler","rake"],description:"Learn how to properly structure a Ruby gem with Rust extensions, including workspace setup, dependency management, and build configuration."},l="Project Setup & Structure",o={},c=[{value:"Project Anatomy",id:"project-anatomy",level:2},{value:"Key Files Explained",id:"key-files-explained",level:3},{value:"Real Example: URL Parser Gem",id:"real-example-url-parser-gem",level:2},{value:"Step 1: Create the Gem Structure",id:"step-1-create-the-gem-structure",level:3},{value:"Step 2: Configure the Extension",id:"step-2-configure-the-extension",level:3},{value:"Step 3: Implement the Rust Extension",id:"step-3-implement-the-rust-extension",level:3},{value:"Step 4: Create Ruby Wrapper",id:"step-4-create-ruby-wrapper",level:3},{value:"Step 5: Add Comprehensive Tests",id:"step-5-add-comprehensive-tests",level:3},{value:"Advanced Project Patterns",id:"advanced-project-patterns",level:2},{value:"Workspace Benefits",id:"workspace-benefits",level:3},{value:"Build Configuration",id:"build-configuration",level:3},{value:"Dependency Management",id:"dependency-management",level:3},{value:"Error Handling Strategy",id:"error-handling-strategy",level:3},{value:"Project Organization Best Practices",id:"project-organization-best-practices",level:2},{value:"1. Module Structure",id:"1-module-structure",level:3},{value:"2. Testing Strategy",id:"2-testing-strategy",level:3},{value:"3. Documentation",id:"3-documentation",level:3},{value:"Shipping Your Gem",id:"shipping-your-gem",level:2},{value:"Pre-release Checklist",id:"pre-release-checklist",level:3},{value:"Building Platform Gems",id:"building-platform-gems",level:3},{value:"\ud83c\udfaf Key Takeaways",id:"-key-takeaways",level:2},{value:"\ud83d\udcda Next Steps",id:"-next-steps",level:2},{value:"\ud83c\udfd7\ufe0f Ready to Build!",id:"\ufe0f-ready-to-build",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components},{Details:r}=n;return r||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"project-setup--structure",children:"Project Setup & Structure"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Time:"})," 25 minutes | ",(0,t.jsx)(n.strong,{children:"Difficulty:"})," Intermediate"]}),"\n",(0,t.jsx)(n.p,{children:"Learn how to structure production-ready Ruby gems with Rust extensions. We'll build a URL parser that showcases\nreal-world patterns."}),"\n",(0,t.jsx)(n.h2,{id:"project-anatomy",children:"Project Anatomy"}),"\n",(0,t.jsx)(n.p,{children:"A production rb-sys project has a specific structure. Let's understand each component:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"my_gem/\n\u251c\u2500\u2500 \ud83d\udce6 Cargo.toml              # Workspace configuration\n\u251c\u2500\u2500 \ud83d\udc8e Gemfile                 # Ruby dependencies\n\u251c\u2500\u2500 \ud83d\udd28 Rakefile                # Build automation\n\u251c\u2500\u2500 \ud83d\udccb my_gem.gemspec          # Gem specification\n\u251c\u2500\u2500 \ud83d\udcdd README.md               # Documentation\n\u251c\u2500\u2500 \ud83d\udd12 Gemfile.lock            # Locked dependencies\n\u251c\u2500\u2500 \ud83d\udcc2 ext/\n\u2502   \u2514\u2500\u2500 my_gem/\n\u2502       \u251c\u2500\u2500 \ud83e\udd80 Cargo.toml      # Extension dependencies\n\u2502       \u251c\u2500\u2500 \ud83d\udd27 extconf.rb      # Build configuration\n\u2502       \u251c\u2500\u2500 \ud83c\udfd7\ufe0f build.rs        # Build script (optional)\n\u2502       \u2514\u2500\u2500 \ud83d\udcc2 src/\n\u2502           \u251c\u2500\u2500 \ud83d\udcc4 lib.rs      # Rust entry point\n\u2502           \u2514\u2500\u2500 \ud83d\udcc4 *.rs        # Additional modules\n\u251c\u2500\u2500 \ud83d\udcc2 lib/\n\u2502   \u251c\u2500\u2500 \ud83d\udc8e my_gem.rb           # Ruby entry point\n\u2502   \u2514\u2500\u2500 \ud83d\udcc2 my_gem/\n\u2502       \u251c\u2500\u2500 \ud83d\udcc4 version.rb      # Version constant\n\u2502       \u2514\u2500\u2500 \ud83d\udcc4 *.rb            # Ruby modules\n\u251c\u2500\u2500 \ud83e\uddea test/                   # Test files\n\u251c\u2500\u2500 \ud83d\udcca benchmark/              # Performance tests\n\u2514\u2500\u2500 \ud83d\udcda examples/               # Usage examples\n"})}),"\n",(0,t.jsx)(n.h3,{id:"key-files-explained",children:"Key Files Explained"}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)("strong",{children:"\ud83e\udd80 Cargo.toml (Workspace)"})}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-toml",children:'# Root Cargo.toml - Defines the workspace\n[workspace]\nmembers = ["ext/*"]\nresolver = "2"\n\n# Shared dependencies for all crates\n[workspace.dependencies]\nmagnus = { version = "0.7", features = ["rb-sys"] }\nrb-sys = "0.9"\n'})})]}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)("strong",{children:"\ud83d\udccb Gemspec Configuration"})}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'# my_gem.gemspec\nGem::Specification.new do |spec|\n  spec.name = "my_gem"\n  spec.version = MyGem::VERSION\n  spec.authors = ["Your Name"]\n  spec.email = ["you@example.com"]\n\n  spec.summary = "Fast URL parsing for Ruby"\n  spec.description = "A Ruby gem using Rust for blazing-fast URL parsing"\n  spec.homepage = "https://github.com/you/my_gem"\n  spec.license = "MIT"\n\n  # Gem files\n  spec.files = Dir[\n    "ext/**/*.{rs,toml,rb,lock}",\n    "lib/**/*.rb",\n    "LICENSE",\n    "README.md"\n  ]\n\n  # Extension configuration\n  spec.extensions = ["ext/my_gem/extconf.rb"]\n  spec.require_paths = ["lib"]\n\n  # Ruby version requirement\n  spec.required_ruby_version = ">= 3.0"\n\n  # Dependencies\n  spec.add_dependency "rb_sys", "~> 0.9"\n\n  # Development dependencies\n  spec.add_development_dependency "rake", "~> 13.0"\n  spec.add_development_dependency "minitest", "~> 5.0"\nend\n'})})]}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)("strong",{children:"\ud83d\udd28 Rakefile with rb-sys"})}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'# Rakefile\nrequire "bundler/gem_tasks"\nrequire "minitest/test_task"\n\nMinitest::TestTask.create\n\n# Add rb-sys extension task\nrequire "rb_sys/extensiontask"\n\nRbSys::ExtensionTask.new("my_gem") do |ext|\n  ext.lib_dir = "lib/my_gem"\nend\n\ntask default: [:compile, :test]\n\n# Custom tasks\ndesc "Run benchmarks"\ntask :bench => :compile do\n  ruby "benchmark/run.rb"\nend\n\ndesc "Open console with extension loaded"\ntask :console => :compile do\n  exec "irb -r ./lib/my_gem.rb"\nend\n'})})]}),"\n",(0,t.jsx)(n.h2,{id:"real-example-url-parser-gem",children:"Real Example: URL Parser Gem"}),"\n",(0,t.jsxs)(n.p,{children:["Let's build a production-ready URL parser using the Rust ",(0,t.jsx)(n.a,{href:"https://crates.io/crates/url",children:"url"})," crate. This demonstrates\nkey patterns you'll use in real projects."]}),"\n",(0,t.jsx)(n.h3,{id:"step-1-create-the-gem-structure",children:"Step 1: Create the Gem Structure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'# Create gem with Rust extension\nbundle gem --ext=rust url_parser\ncd url_parser\n\n# Set up workspace\ncat > Cargo.toml << \'EOF\'\n[workspace]\nmembers = ["ext/*"]\nresolver = "2"\n\n[workspace.dependencies]\nmagnus = { version = "0.7", features = ["rb-sys"] }\nurl = "2.5"\nEOF\n'})}),"\n",(0,t.jsx)(n.h3,{id:"step-2-configure-the-extension",children:"Step 2: Configure the Extension"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-toml",children:'# ext/url_parser/Cargo.toml\n[package]\nname = "url_parser"\nversion = "0.1.0"\nedition = "2021"\nauthors = ["Your Name <your.email@example.com>"]\nlicense = "MIT"\npublish = false\n\n[lib]\ncrate-type = ["cdylib"]\n\n[dependencies]\n# High-level Ruby bindings with rb-sys feature\nmagnus = { version = "0.7", features = ["rb-sys"] }\n\n# The main Rust library we\'re wrapping\nurl = "2.4"\n\n[build-dependencies]\nrb-sys-env = "0.1"\n'})}),"\n",(0,t.jsx)(n.h3,{id:"step-3-implement-the-rust-extension",children:"Step 3: Implement the Rust Extension"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// ext/url_parser/src/lib.rs\nuse magnus::{function, method, prelude::*, Error, Ruby};\nuse url::Url;\nuse std::fmt;\n\n// Simple URL wrapper class\n#[magnus::wrap(class = "UrlParser::URL")]\nstruct UrlWrapper {\n    inner: Url,\n}\n\nimpl UrlWrapper {\n    // Parse a URL string\n    fn parse(ruby: &Ruby, url_str: String) -> Result<Self, Error> {\n        match Url::parse(&url_str) {\n            Ok(url) => Ok(UrlWrapper { inner: url }),\n            Err(err) => {\n                Err(Error::new(ruby.exception_arg_error(), format!("Invalid URL: {}", err)))\n            }\n        }\n    }\n\n    // Basic getters\n    fn scheme(&self) -> String {\n        self.inner.scheme().to_string()\n    }\n\n    fn host(&self) -> Option<String> {\n        self.inner.host_str().map(|s| s.to_string())\n    }\n\n    fn path(&self) -> String {\n        self.inner.path().to_string()\n    }\n\n    fn query(&self) -> Option<String> {\n        self.inner.query().map(|s| s.to_string())\n    }\n\n    // String representation of the URL\n    fn to_string_ruby(&self) -> String {\n        self.inner.to_string()\n    }\n}\n\nimpl fmt::Display for UrlWrapper {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        write!(f, "{}", self.inner)\n    }\n}\n\n// Module-level utilities\nfn is_valid_url(url_str: String) -> bool {\n    Url::parse(&url_str).is_ok()\n}\n\n// Module init function - Ruby extension entry point\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    // Define the main module\n    let module = ruby.define_module("UrlParser")?;\n\n    // Add utility function at module level\n    module.define_singleton_method("valid_url?", function!(is_valid_url, 1))?;\n\n    // Define and configure the URL class\n    let class = module.define_class("URL", ruby.class_object())?;\n    class.define_singleton_method("parse", function!(UrlWrapper::parse, 1))?;\n\n    // Instance methods\n    class.define_method("scheme", method!(UrlWrapper::scheme, 0))?;\n    class.define_method("host", method!(UrlWrapper::host, 0))?;\n    class.define_method("path", method!(UrlWrapper::path, 0))?;\n    class.define_method("query", method!(UrlWrapper::query, 0))?;\n    class.define_method("to_s", method!(UrlWrapper::to_string_ruby, 0))?;\n\n    Ok(())\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"step-4-create-ruby-wrapper",children:"Step 4: Create Ruby Wrapper"}),"\n",(0,t.jsx)(n.p,{children:"The Ruby side provides a clean API and additional conveniences:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'# lib/url_parser.rb\nrequire_relative "url_parser/version"\nrequire_relative "url_parser/url_parser"\n\nmodule UrlParser\n  class Error < StandardError; end\n\n  # Parse a URL string and return a URL object\n  def self.parse(url_string)\n    URL.parse(url_string)\n  rescue => e\n    raise Error, "Failed to parse URL: #{e.message}"\n  end\n\n  # Check if a URL has an HTTPS scheme\n  def self.https?(url_string)\n    return false unless valid_url?(url_string)\n    url = parse(url_string)\n    url.scheme == "https"\n  end\nend\n'})}),"\n",(0,t.jsx)(n.h3,{id:"step-5-add-comprehensive-tests",children:"Step 5: Add Comprehensive Tests"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'# test/test_url_parser.rb\nrequire "test_helper"\n\nclass TestUrlParser < Minitest::Test\n  def test_basic_url_parsing\n    url = UrlParser::URL.parse("https://example.com/path?query=value")\n\n    assert_equal "https", url.scheme\n    assert_equal "example.com", url.host\n    assert_equal "/path", url.path\n    assert_equal "query=value", url.query\n  end\n\n  def test_url_validation\n    assert UrlParser.valid_url?("https://example.com")\n    refute UrlParser.valid_url?("not a url")\n  end\n\n  def test_https_check\n    assert UrlParser.https?("https://example.com")\n    refute UrlParser.https?("http://example.com")\n  end\n\n  def test_invalid_url_raises_error\n    assert_raises UrlParser::Error do\n      UrlParser.parse("not://a.valid/url")\n    end\n  end\nend\n'})}),"\n",(0,t.jsx)(n.h2,{id:"advanced-project-patterns",children:"Advanced Project Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"workspace-benefits",children:"Workspace Benefits"}),"\n",(0,t.jsx)(n.p,{children:"Using a Cargo workspace provides:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Shared dependencies"})," - One ",(0,t.jsx)(n.code,{children:"Cargo.lock"})," for reproducible builds"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Faster compilation"})," - Dependencies compiled once"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Multiple extensions"})," - Easy to add more Rust crates"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unified testing"})," - Run all Rust tests together"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"build-configuration",children:"Build Configuration"}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)("strong",{children:"Custom extconf.rb Options"})}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'# ext/my_gem/extconf.rb\nrequire "mkmf"\nrequire "rb_sys/mkmf"\n\ncreate_rust_makefile("my_gem/my_gem") do |r|\n  # Enable link-time optimization\n  r.profile = ENV.fetch("RB_SYS_CARGO_PROFILE", "release")\n\n  # Add feature flags\n  r.features = ["performance"] if ENV["ENABLE_PERF"]\n\n  # Extra Rust flags\n  r.extra_rustflags = ["--cfg", "ruby_3_0"] if RUBY_VERSION >= "3.0"\n\n  # Target specific configuration\n  if RbConfig::CONFIG["target_os"] == "darwin"\n    r.target = "x86_64-apple-darwin"\n  end\nend\n'})})]}),"\n",(0,t.jsxs)(r,{children:[(0,t.jsx)("summary",{children:(0,t.jsx)("strong",{children:"Build Script (build.rs)"})}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'// ext/my_gem/build.rs\nfn main() {\n    // rb-sys automatically sets up the build environment\n    // You can add custom build configuration here\n    println!("cargo:rustc-cfg=has_custom_feature");\n\n    // Link to system libraries if needed\n    #[cfg(target_os = "macos")]\n    println!("cargo:rustc-link-lib=framework=Security");\n}\n'})})]}),"\n",(0,t.jsx)(n.h3,{id:"dependency-management",children:"Dependency Management"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-toml",children:'# ext/my_gem/Cargo.toml\n[dependencies]\n# Required dependencies\nmagnus = { version = "0.7", features = ["rb-sys"] }\n\n# Feature-gated dependencies\nserde = { version = "1.0", optional = true }\nserde_json = { version = "1.0", optional = true }\n\n[features]\ndefault = []\njson = ["serde", "serde_json"]\nperformance = ["lto"]\n\n[profile.release]\nlto = "thin"\ncodegen-units = 1\nopt-level = 3\n'})}),"\n",(0,t.jsx)(n.h3,{id:"error-handling-strategy",children:"Error Handling Strategy"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use magnus::{Error, exception};\nuse std::fmt;\n\n// Custom error type\n#[derive(Debug)]\nenum UrlError {\n    InvalidScheme(String),\n    InvalidHost(String),\n    ParseError(url::ParseError),\n}\n\nimpl fmt::Display for UrlError {\n    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {\n        match self {\n            UrlError::InvalidScheme(s) => write!(f, "Invalid scheme: {}", s),\n            UrlError::InvalidHost(h) => write!(f, "Invalid host: {}", h),\n            UrlError::ParseError(e) => write!(f, "Parse error: {}", e),\n        }\n    }\n}\n\n// Convert to Ruby exceptions\nimpl From<UrlError> for Error {\n    fn from(err: UrlError) -> Self {\n        let ruby = unsafe { magnus::Ruby::get_unchecked() };\n        match err {\n            UrlError::InvalidScheme(_) | UrlError::InvalidHost(_) => {\n                Error::new(ruby.exception_arg_error(), err.to_string())\n            }\n            UrlError::ParseError(_) => {\n                Error::new(ruby.exception_runtime_error(), err.to_string())\n            }\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"project-organization-best-practices",children:"Project Organization Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"1-module-structure",children:"1. Module Structure"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"ext/my_gem/src/\n\u251c\u2500\u2500 lib.rs          # Entry point and module declarations\n\u251c\u2500\u2500 types.rs        # Type definitions and conversions\n\u251c\u2500\u2500 errors.rs       # Error types and handling\n\u251c\u2500\u2500 implementation/ # Core functionality\n\u2502   \u251c\u2500\u2500 mod.rs\n\u2502   \u251c\u2500\u2500 parser.rs\n\u2502   \u2514\u2500\u2500 validator.rs\n\u2514\u2500\u2500 ruby_api.rs     # Ruby class/module definitions\n"})}),"\n",(0,t.jsx)(n.h3,{id:"2-testing-strategy",children:"2. Testing Strategy"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"test/\n\u251c\u2500\u2500 test_helper.rb      # Common test utilities\n\u251c\u2500\u2500 unit/               # Unit tests\n\u2502   \u251c\u2500\u2500 test_parser.rb\n\u2502   \u2514\u2500\u2500 test_errors.rb\n\u251c\u2500\u2500 integration/        # Integration tests\n\u2502   \u2514\u2500\u2500 test_api.rb\n\u2514\u2500\u2500 performance/        # Benchmark tests\n    \u2514\u2500\u2500 bench_parser.rb\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-documentation",children:"3. Documentation"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ruby",children:'# Document Ruby methods with YARD\nmodule UrlParser\n  # Parses a URL string into components\n  #\n  # @param url_string [String] the URL to parse\n  # @return [URL] parsed URL object\n  # @raise [Error] if URL is invalid\n  #\n  # @example Parse a simple URL\n  #   url = UrlParser.parse("https://example.com")\n  #   url.scheme #=> "https"\n  def self.parse(url_string)\n    # Implementation\n  end\nend\n'})}),"\n",(0,t.jsx)(n.h2,{id:"shipping-your-gem",children:"Shipping Your Gem"}),"\n",(0,t.jsx)(n.h3,{id:"pre-release-checklist",children:"Pre-release Checklist"}),"\n",(0,t.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","All tests passing"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Benchmarks show expected performance"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Documentation complete (README, YARD)"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","CHANGELOG updated"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Version bumped"]}),"\n",(0,t.jsxs)(n.li,{className:"task-list-item",children:[(0,t.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Platform compatibility verified"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"building-platform-gems",children:"Building Platform Gems"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"# Build native gems for multiple platforms\nrake native gem\n\n# This creates:\n# - url_parser-1.0.0.gem (source gem)\n# - url_parser-1.0.0-x86_64-linux.gem\n# - url_parser-1.0.0-x86_64-darwin.gem\n# - url_parser-1.0.0-arm64-darwin.gem\n"})}),"\n",(0,t.jsx)(n.h2,{id:"-key-takeaways",children:"\ud83c\udfaf Key Takeaways"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use workspaces"})," for better dependency management"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Structure for growth"})," - organize code into modules"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Handle errors gracefully"})," - map to Ruby exceptions"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Test comprehensively"})," - unit, integration, performance"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Document thoroughly"})," - both Ruby and Rust code"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Plan for platforms"})," - test across OS and Ruby versions"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"-next-steps",children:"\ud83d\udcda Next Steps"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"basic-patterns",children:(0,t.jsx)(n.strong,{children:"Basic Patterns"})})," - Common implementation patterns"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"working-with-ruby-objects",children:(0,t.jsx)(n.strong,{children:"Working with Ruby Objects"})})," - Manipulating Ruby data"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"testing",children:(0,t.jsx)(n.strong,{children:"Testing Extensions"})})," - Comprehensive testing strategies"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"cross-platform",children:(0,t.jsx)(n.strong,{children:"Cross-Platform Development"})})," - Building for all platforms"]}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)("div",{className:"success-message",children:[(0,t.jsx)(n.h3,{id:"\ufe0f-ready-to-build",children:"\ud83c\udfd7\ufe0f Ready to Build!"}),(0,t.jsx)(n.p,{children:"You now understand how to structure production-ready Ruby gems with Rust. Start building!"})]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>l});var s=r(6540);const t={},i=s.createContext(t);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);