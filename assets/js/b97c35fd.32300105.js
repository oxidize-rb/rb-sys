"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[564],{2117:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"basic-patterns","title":"Basic Patterns","description":"Learn essential patterns for building Ruby extensions with Rust, including functions, type conversions, and error handling.","source":"@site/docs/basic-patterns.mdx","sourceDirName":".","slug":"/basic-patterns","permalink":"/docs/basic-patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/oxidize-rb/rb-sys/tree/main/docsite/docs/basic-patterns.mdx","tags":[],"version":"current","lastUpdatedBy":"Ian Ker-Seymer","lastUpdatedAt":1752599549000,"sidebarPosition":5,"frontMatter":{"id":"basic-patterns","title":"Basic Patterns","sidebar_position":5,"keywords":["patterns","functions","methods","strings","numbers","arrays","errors"],"description":"Learn essential patterns for building Ruby extensions with Rust, including functions, type conversions, and error handling."},"sidebar":"docsSidebar","previous":{"title":"Project Setup & Structure","permalink":"/docs/project-setup"},"next":{"title":"Working with Ruby Objects","permalink":"/docs/working-with-ruby-objects"}}');var s=r(4848),i=r(8453);const a={id:"basic-patterns",title:"Basic Patterns",sidebar_position:5,keywords:["patterns","functions","methods","strings","numbers","arrays","errors"],description:"Learn essential patterns for building Ruby extensions with Rust, including functions, type conversions, and error handling."},o="Basic Patterns",l={},c=[{value:"Functions &amp; Methods",id:"functions--methods",level:2},{value:"Module Functions",id:"module-functions",level:3},{value:"Instance Methods on Classes",id:"instance-methods-on-classes",level:3},{value:"String Handling",id:"string-handling",level:2},{value:"Basic String Operations",id:"basic-string-operations",level:3},{value:"String Encoding",id:"string-encoding",level:3},{value:"Number Handling",id:"number-handling",level:2},{value:"Integer Operations",id:"integer-operations",level:3},{value:"Float Operations",id:"float-operations",level:3},{value:"Array Handling",id:"array-handling",level:2},{value:"Basic Array Operations",id:"basic-array-operations",level:3},{value:"Advanced Array Patterns",id:"advanced-array-patterns",level:3},{value:"Hash Handling",id:"hash-handling",level:2},{value:"Error Handling Patterns",id:"error-handling-patterns",level:2},{value:"Custom Error Types",id:"custom-error-types",level:3},{value:"Error Context",id:"error-context",level:3},{value:"Optional and Default Arguments",id:"optional-and-default-arguments",level:2},{value:"Working with Blocks",id:"working-with-blocks",level:2},{value:"\ud83c\udfaf Pattern Summary",id:"-pattern-summary",level:2},{value:"Do&#39;s \u2705",id:"dos-",level:3},{value:"Don&#39;ts \u274c",id:"donts-",level:3},{value:"\ud83d\udcda Next Steps",id:"-next-steps",level:2},{value:"\ud83c\udf89 Patterns Mastered!",id:"-patterns-mastered",level:3}];function u(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"basic-patterns",children:"Basic Patterns"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Time:"})," 30 minutes | ",(0,s.jsx)(e.strong,{children:"Difficulty:"})," Beginner to Intermediate"]}),"\n",(0,s.jsx)(e.p,{children:"Master the fundamental patterns for building Ruby extensions with Rust. These patterns form the foundation of every rb-sys project."}),"\n",(0,s.jsx)(e.h2,{id:"functions--methods",children:"Functions & Methods"}),"\n",(0,s.jsx)(e.h3,{id:"module-functions",children:"Module Functions"}),"\n",(0,s.jsx)(e.p,{children:"The simplest pattern - standalone functions in a module:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use magnus::{function, prelude::*, Error, Ruby};\n\n// Simple function with automatic type conversion\nfn add(a: i64, b: i64) -> i64 {\n    a + b\n}\n\n// Function that can fail\nfn divide(a: f64, b: f64) -> Result<f64, Error> {\n    if b == 0.0 {\n        Err(Error::new(\n            magnus::exception::zero_div_error(),\n            "divided by 0"\n        ))\n    } else {\n        Ok(a / b)\n    }\n}\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let module = ruby.define_module("MathUtils")?;\n    \n    // Register functions with their arity\n    module.define_singleton_method("add", function!(add, 2))?;\n    module.define_singleton_method("divide", function!(divide, 2))?;\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Ruby usage:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ruby",children:"MathUtils.add(5, 3)      # => 8\nMathUtils.divide(10, 2)  # => 5.0\nMathUtils.divide(10, 0)  # => ZeroDivisionError\n"})}),"\n",(0,s.jsx)(e.h3,{id:"instance-methods-on-classes",children:"Instance Methods on Classes"}),"\n",(0,s.jsx)(e.p,{children:"Creating classes with instance methods:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use magnus::{function, method, prelude::*, Error, Ruby};\nuse std::cell::RefCell;\n\nstruct CounterData {\n    value: i64,\n}\n\n#[magnus::wrap(class = "Counter", free_immediately)]\nstruct Counter(RefCell<CounterData>);\n\nimpl Counter {\n    fn new(initial: i64) -> Self {\n        Counter(RefCell::new(CounterData { value: initial }))\n    }\n    \n    fn increment(&self) -> i64 {\n        let mut data = self.0.borrow_mut();\n        data.value += 1;\n        data.value\n    }\n    \n    fn increment_by(&self, amount: i64) -> i64 {\n        let mut data = self.0.borrow_mut();\n        data.value += amount;\n        data.value\n    }\n    \n    fn value(&self) -> i64 {\n        self.0.borrow().value\n    }\n    \n    fn reset(&self) {\n        self.0.borrow_mut().value = 0;\n    }\n}\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let class = ruby.define_class("Counter", ruby.class_object())?;\n    \n    // Constructor\n    class.define_singleton_method("new", function!(Counter::new, 1))?;\n    \n    // Instance methods\n    class.define_method("increment", method!(Counter::increment, 0))?;\n    class.define_method("increment_by", method!(Counter::increment_by, 1))?;\n    class.define_method("value", method!(Counter::value, 0))?;\n    class.define_method("reset", method!(Counter::reset, 0))?;\n    \n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Ruby usage:"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-ruby",children:"counter = Counter.new(10)\ncounter.value         # => 10\ncounter.increment     # => 11\ncounter.increment_by(5) # => 16\ncounter.reset\ncounter.value         # => 0\n"})}),"\n",(0,s.jsx)(e.h2,{id:"string-handling",children:"String Handling"}),"\n",(0,s.jsx)(e.p,{children:"Strings are one of the most common data types. Here are key patterns:"}),"\n",(0,s.jsx)(e.h3,{id:"basic-string-operations",children:"Basic String Operations"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use magnus::{RString, Error};\n\n// Accept and return strings with automatic conversion\nfn reverse_string(input: String) -> String {\n    input.chars().rev().collect()\n}\n\n// Work with Ruby strings directly\nfn uppercase_first(ruby_str: RString) -> Result<RString, Error> {\n    let s = ruby_str.to_string()?;\n    \n    if s.is_empty() {\n        return Ok(ruby_str);\n    }\n    \n    let first_char = s.chars().next()\n        .ok_or_else(|| Error::new(magnus::exception::arg_error(), "string is empty"))?;\n    let result = format!(\n        "{}{}",\n        first_char.to_uppercase(),\n        &s[first_char.len_utf8()..]\n    );\n    \n    Ok(RString::new(&result))\n}\n\n// Efficient string building\nfn repeat_string(s: String, times: usize) -> Result<String, Error> {\n    if times > 1_000_000 {\n        return Err(Error::new(\n            magnus::exception::arg_error(),\n            "too many repetitions"\n        ));\n    }\n    \n    Ok(s.repeat(times))\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"string-encoding",children:"String Encoding"}),"\n",(0,s.jsx)(e.p,{children:"Handle different encodings properly:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:"use magnus::{RString, Error, Ruby};\n\nfn ensure_utf8(_ruby: &Ruby, input: RString) -> Result<RString, Error> {\n    // For this example, we'll assume the string is already in the correct encoding\n    // In production code, you would use rb-sys directly for encoding operations\n    Ok(input)\n}\n\n// Work with binary data\nfn process_binary(data: RString) -> Result<Vec<u8>, Error> {\n    // Get bytes regardless of encoding\n    let bytes = unsafe { data.as_slice() };\n    \n    // Process the bytes...\n    Ok(bytes.to_vec())\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"number-handling",children:"Number Handling"}),"\n",(0,s.jsx)(e.h3,{id:"integer-operations",children:"Integer Operations"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use magnus::{Integer, Error, exception};\n\n// Basic arithmetic with overflow checking\nfn safe_multiply(a: i64, b: i64) -> Result<i64, Error> {\n    a.checked_mul(b).ok_or_else(|| {\n        Error::new(\n            exception::range_error(),\n            "integer overflow"\n        )\n    })\n}\n\n// Work with Ruby Integer objects\nfn factorial(n: Integer) -> Result<Integer, Error> {\n    let num: i64 = n.to_i64()?;\n    \n    if num < 0 {\n        return Err(Error::new(\n            exception::arg_error(),\n            "factorial of negative number"\n        ));\n    }\n    \n    let result = (1..=num).product::<i64>();\n    Ok(Integer::from_i64(result))\n}\n\n// Handle large numbers\nfn is_prime(n: Integer) -> bool {\n    let num = match n.to_u64() {\n        Ok(n) => n,\n        Err(_) => return false, // Negative or too large\n    };\n    \n    if num < 2 {\n        return false;\n    }\n    \n    for i in 2..=(num as f64).sqrt() as u64 {\n        if num % i == 0 {\n            return false;\n        }\n    }\n    \n    true\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"float-operations",children:"Float Operations"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use magnus::{Float, Error, exception};\nuse std::f64::consts::PI;\n\n// Automatic conversion from Ruby Float\nfn circle_area(radius: f64) -> f64 {\n    PI * radius * radius\n}\n\n// Return Ruby Float objects\nfn calculate_mean(numbers: Vec<f64>) -> Result<Float, Error> {\n    if numbers.is_empty() {\n        return Err(Error::new(\n            exception::arg_error(),\n            "empty array"\n        ));\n    }\n    \n    let sum: f64 = numbers.iter().sum();\n    let mean = sum / numbers.len() as f64;\n    \n    Ok(Float::from_f64(mean))\n}\n\n// Handle special float values\nfn safe_divide(a: f64, b: f64) -> Result<f64, Error> {\n    let result = a / b;\n    \n    if result.is_nan() {\n        Err(Error::new(\n            exception::float_domain_error(),\n            "result is NaN"\n        ))\n    } else if result.is_infinite() {\n        Err(Error::new(\n            exception::float_domain_error(),\n            "result is infinite"\n        ))\n    } else {\n        Ok(result)\n    }\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"array-handling",children:"Array Handling"}),"\n",(0,s.jsx)(e.p,{children:"Arrays are fundamental in Ruby. Here's how to work with them efficiently:"}),"\n",(0,s.jsx)(e.h3,{id:"basic-array-operations",children:"Basic Array Operations"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:"use magnus::{RArray, Error, TryConvert};\n\n// Accept Vec with automatic conversion\nfn sum_integers(numbers: Vec<i64>) -> i64 {\n    numbers.iter().sum()\n}\n\n// Work with Ruby arrays directly\nfn first_n_elements(array: RArray, n: usize) -> Result<RArray, Error> {\n    let result = RArray::new();\n    \n    for (i, item) in array.each().enumerate() {\n        if i >= n {\n            break;\n        }\n        result.push(item?)?;\n    }\n    \n    Ok(result)\n}\n\n// Modify arrays efficiently\nfn double_values(array: RArray) -> Result<RArray, Error> {\n    let result = RArray::with_capacity(array.len());\n    \n    for item in array.each() {\n        let value: i64 = TryConvert::try_convert(item?)?;\n        result.push(value * 2)?;\n    }\n    \n    Ok(result)\n}\n"})}),"\n",(0,s.jsx)(e.h3,{id:"advanced-array-patterns",children:"Advanced Array Patterns"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use magnus::{RArray, Error, RString, exception, TryConvert};\n\n// Filter arrays\nfn select_strings(array: RArray) -> Result<RArray, Error> {\n    let result = RArray::new();\n    \n    for item in array.each() {\n        let value = item?;\n        if RString::try_convert(value).is_ok() {\n            result.push(value)?;\n        }\n    }\n    \n    Ok(result)\n}\n\n// Transform arrays with error handling\nfn parse_integers(array: RArray) -> Result<Vec<i64>, Error> {\n    let mut result = Vec::with_capacity(array.len());\n    \n    for (index, item) in array.each().enumerate() {\n        let value = item?;\n        \n        match i64::try_convert(value) {\n            Ok(n) => result.push(n),\n            Err(_) => {\n                return Err(Error::new(\n                    exception::type_error(),\n                    format!("element at index {} is not an integer", index)\n                ));\n            }\n        }\n    }\n    \n    Ok(result)\n}\n\n// Create nested arrays\nfn create_matrix(rows: usize, cols: usize, initial: i64) -> RArray {\n    let matrix = RArray::with_capacity(rows);\n    \n    for _ in 0..rows {\n        let row = RArray::with_capacity(cols);\n        for _ in 0..cols {\n            let _ = row.push(initial);\n        }\n        let _ = matrix.push(row);\n    }\n    \n    matrix\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"hash-handling",children:"Hash Handling"}),"\n",(0,s.jsx)(e.p,{children:"Working with Ruby hashes (dictionaries):"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:"use magnus::{RHash, Value, Symbol, Error, r_hash::ForEach};\n\n// Accept HashMap with automatic conversion\nuse std::collections::HashMap;\n\nfn count_words(text: String) -> HashMap<String, usize> {\n    let mut counts = HashMap::new();\n    \n    for word in text.split_whitespace() {\n        *counts.entry(word.to_string()).or_insert(0) += 1;\n    }\n    \n    counts\n}\n\n// Work with Ruby hashes directly\nfn merge_hashes(hash1: RHash, hash2: RHash) -> Result<RHash, Error> {\n    let result = RHash::new();\n    \n    // Copy first hash\n    hash1.foreach(|key: Value, value: Value| {\n        result.aset(key, value)?;\n        Ok(ForEach::Continue)\n    })?;\n    \n    // Merge second hash\n    hash2.foreach(|key: Value, value: Value| {\n        result.aset(key, value)?;\n        Ok(ForEach::Continue)\n    })?;\n    \n    Ok(result)\n}\n\n// Symbol keys\nfn get_config_value(config: RHash, key: &str) -> Result<Option<Value>, Error> {\n    let symbol_key = Symbol::new(key);\n    Ok(config.get(symbol_key))\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"error-handling-patterns",children:"Error Handling Patterns"}),"\n",(0,s.jsx)(e.p,{children:"Robust error handling is crucial for production extensions:"}),"\n",(0,s.jsx)(e.h3,{id:"custom-error-types",children:"Custom Error Types"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use magnus::{Error, exception};\nuse std::fmt;\n\n// Define custom error types\n#[derive(Debug)]\nenum ProcessingError {\n    InvalidInput(String),\n    ProcessingFailed(String),\n    ResourceNotFound(String),\n}\n\nimpl fmt::Display for ProcessingError {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            ProcessingError::InvalidInput(msg) => write!(f, "Invalid input: {}", msg),\n            ProcessingError::ProcessingFailed(msg) => write!(f, "Processing failed: {}", msg),\n            ProcessingError::ResourceNotFound(msg) => write!(f, "Resource not found: {}", msg),\n        }\n    }\n}\n\n// Convert to Ruby exceptions\nimpl From<ProcessingError> for Error {\n    fn from(err: ProcessingError) -> Self {\n        match err {\n            ProcessingError::InvalidInput(_) => {\n                Error::new(exception::arg_error(), err.to_string())\n            }\n            ProcessingError::ProcessingFailed(_) => {\n                Error::new(exception::runtime_error(), err.to_string())\n            }\n            ProcessingError::ResourceNotFound(_) => {\n                Error::new(exception::runtime_error(), err.to_string())\n            }\n        }\n    }\n}\n\n// Use in functions\nfn process_data(input: String) -> Result<String, Error> {\n    if input.is_empty() {\n        return Err(ProcessingError::InvalidInput("input cannot be empty".to_string()).into());\n    }\n    \n    // Processing logic...\n    Ok(input.to_uppercase())\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"error-context",children:"Error Context"}),"\n",(0,s.jsx)(e.p,{children:"Add context to errors for better debugging:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:"use magnus::{Error, exception};\n\nfn read_and_parse(filename: String) -> Result<Vec<i64>, Error> {\n    // Read file\n    let contents = std::fs::read_to_string(&filename)\n        .map_err(|e| Error::new(\n            exception::runtime_error(),\n            format!(\"Failed to read file '{}': {}\", filename, e)\n        ))?;\n    \n    // Parse numbers\n    let mut numbers = Vec::new();\n    for (line_no, line) in contents.lines().enumerate() {\n        let num = line.trim().parse::<i64>()\n            .map_err(|e| Error::new(\n                exception::arg_error(),\n                format!(\"Invalid number on line {} of '{}': {}\", line_no + 1, filename, e)\n            ))?;\n        numbers.push(num);\n    }\n    \n    Ok(numbers)\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"optional-and-default-arguments",children:"Optional and Default Arguments"}),"\n",(0,s.jsx)(e.p,{children:"Handle optional parameters gracefully:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use magnus::{RHash, RArray, Symbol, Error, exception, TryConvert};\n\n// Using Option for optional parameters\nfn greet(name: String, greeting: Option<String>) -> String {\n    let greeting = greeting.unwrap_or_else(|| "Hello".to_string());\n    format!("{}, {}!", greeting, name)\n}\n\n// Using kwargs for named parameters\nfn create_user(kwargs: RHash) -> Result<String, Error> {\n    // Required parameter\n    let name: String = TryConvert::try_convert(\n        kwargs\n            .get(Symbol::new("name"))\n            .ok_or_else(|| Error::new(exception::arg_error(), "name is required"))?\n    )?;\n    \n    // Optional parameters with defaults\n    let age: i32 = kwargs\n        .get(Symbol::new("age"))\n        .and_then(|v| TryConvert::try_convert(v).ok())\n        .unwrap_or(0);\n    \n    let email: Option<String> = kwargs\n        .get(Symbol::new("email"))\n        .and_then(|v| TryConvert::try_convert(v).ok());\n    \n    Ok(format!("User: {}, Age: {}, Email: {:?}", name, age, email))\n}\n\n// Variadic arguments\nfn concat_strings(strings: RArray) -> Result<String, Error> {\n    let mut result = String::new();\n    \n    for item in strings.each() {\n        let s: String = TryConvert::try_convert(item?)?;\n        result.push_str(&s);\n        result.push(\' \');\n    }\n    \n    Ok(result.trim().to_string())\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"working-with-blocks",children:"Working with Blocks"}),"\n",(0,s.jsx)(e.p,{children:"Ruby blocks are powerful - here's how to use them:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:"use magnus::{block::Proc, Value, RArray, Error};\n\n// Accept a block and call it\nfn map_array(array: RArray, block: Proc) -> Result<RArray, Error> {\n    let result = RArray::with_capacity(array.len());\n    \n    for item in array.each() {\n        let value = item?;\n        let mapped = block.call::<_, Value>((value,))?;\n        result.push(mapped)?;\n    }\n    \n    Ok(result)\n}\n\n// Yield to a block multiple times\nfn times(n: usize, block: Proc) -> Result<(), Error> {\n    for i in 0..n {\n        block.call::<_, Value>((i,))?;\n    }\n    Ok(())\n}\n\n// Check if block given\nfn with_optional_block(data: String, block: Option<Proc>) -> Result<String, Error> {\n    match block {\n        Some(b) => {\n            // Call block with data\n            b.call::<_, String>((data,))\n        }\n        None => {\n            // No block provided\n            Ok(data.to_uppercase())\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(e.h2,{id:"-pattern-summary",children:"\ud83c\udfaf Pattern Summary"}),"\n",(0,s.jsx)(e.h3,{id:"dos-",children:"Do's \u2705"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Use Result<T, Error>"})," for fallible operations"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Validate inputs"})," early and clearly"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Provide helpful error messages"})," with context"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Use type conversions"})," appropriately"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Handle edge cases"})," (empty arrays, zero division, etc.)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Pre-allocate collections"})," when size is known"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"donts-",children:"Don'ts \u274c"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Don't panic"})," - return errors instead"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Don't ignore errors"})," - propagate them"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Don't allocate unnecessarily"})," - reuse when possible"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Don't block the GVL"})," unnecessarily"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Don't assume types"})," - validate or use try_convert"]}),"\n"]}),"\n",(0,s.jsx)(e.h2,{id:"-next-steps",children:"\ud83d\udcda Next Steps"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"working-with-ruby-objects",children:(0,s.jsx)(e.strong,{children:"Working with Ruby Objects"})})," - Deep dive into Ruby types"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"error-handling",children:(0,s.jsx)(e.strong,{children:"Error Handling"})})," - Advanced error patterns"]}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsxs)("div",{className:"success-message",children:[(0,s.jsx)(e.h3,{id:"-patterns-mastered",children:"\ud83c\udf89 Patterns Mastered!"}),(0,s.jsx)(e.p,{children:"You now know the essential patterns for building Ruby extensions with Rust. Practice these patterns to build robust, efficient extensions!"})]})]})}function d(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(u,{...n})}):u(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>a,x:()=>o});var t=r(6540);const s={},i=t.createContext(s);function a(n){const e=t.useContext(i);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:a(n.components),t.createElement(i.Provider,{value:e},n.children)}}}]);