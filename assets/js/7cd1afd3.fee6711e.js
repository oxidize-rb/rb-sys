"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[626],{7485:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"memory-management","title":"Memory Management & Safety","description":"This guide covers how Ruby\'s garbage collector interacts with Rust objects and how to prevent memory leaks and segmentation faults in your extensions.","source":"@site/docs/memory-management.mdx","sourceDirName":".","slug":"/memory-management","permalink":"/docs/memory-management","draft":false,"unlisted":false,"editUrl":"https://github.com/oxidize-rb/rb-sys/tree/main/docsite/docs/memory-management.mdx","tags":[],"version":"current","lastUpdatedBy":"Ian Ker-Seymer","lastUpdatedAt":1752632597000,"frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Error Handling in Rust Ruby Extensions","permalink":"/docs/error-handling"},"next":{"title":"The Build Process","permalink":"/docs/build-process"}}');var s=r(4848),o=r(8453);const a={},i="Memory Management & Safety",l={},c=[{value:"Ruby&#39;s Garbage Collection System",id:"rubys-garbage-collection-system",level:2},{value:"TypedData and DataTypeFunctions",id:"typeddata-and-datatypefunctions",level:2},{value:"Basic TypedData Example",id:"basic-typeddata-example",level:3},{value:"Implementing GC Marking",id:"implementing-gc-marking",level:3},{value:"A Real-World Example: Error Handler",id:"a-real-world-example-error-handler",level:2},{value:"More Complex Example: Memory References",id:"more-complex-example-memory-references",level:2},{value:"Common Memory Management Pitfalls",id:"common-memory-management-pitfalls",level:2},{value:"1. Forgetting to Mark References",id:"1-forgetting-to-mark-references",level:3},{value:"2. Creating Cyclic References",id:"2-creating-cyclic-references",level:3},{value:"3. Inefficient String Creation",id:"3-inefficient-string-creation",level:3},{value:"4. Not Handling Exceptions Properly",id:"4-not-handling-exceptions-properly",level:3},{value:"RefCell and Interior Mutability",id:"refcell-and-interior-mutability",level:2},{value:"Understanding RefCell and Borrowing",id:"understanding-refcell-and-borrowing",level:3},{value:"The BorrowMutError Problem",id:"the-borrowmuterror-problem",level:3},{value:"The Solution: Complete Borrows Before Mutating",id:"the-solution-complete-borrows-before-mutating",level:3},{value:"Complex Example with Multiple Operations",id:"complex-example-with-multiple-operations",level:3},{value:"Using Temporary Variables Instead of Block Scopes",id:"using-temporary-variables-instead-of-block-scopes",level:3},{value:"RefCell Best Practices",id:"refcell-best-practices",level:3},{value:"Best Practices",id:"best-practices",level:2}];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"memory-management--safety",children:"Memory Management & Safety"})}),"\n",(0,s.jsx)(n.p,{children:"This guide covers how Ruby's garbage collector interacts with Rust objects and how to prevent memory leaks and segmentation faults in your extensions."}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"Improper memory management is the leading cause of crashes and security vulnerabilities in native extensions. Rust's\nsafety guarantees help prevent many common issues, but you still need to carefully manage the boundary between Ruby and\nRust memory."})}),"\n",(0,s.jsx)(n.h2,{id:"rubys-garbage-collection-system",children:"Ruby's Garbage Collection System"}),"\n",(0,s.jsx)(n.p,{children:"Ruby uses a mark-and-sweep garbage collector to manage memory. Understanding how it works is essential for writing safe\nextensions:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Marking Phase"}),': Ruby traverses all visible objects, marking them as "in use"']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sweeping Phase"}),": Objects that weren't marked are considered garbage and freed"]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["When you create Rust objects that reference Ruby objects, you need to tell Ruby's GC about these references to prevent\npremature garbage collection. The ",(0,s.jsx)(n.code,{children:"TypedData"})," trait and ",(0,s.jsx)(n.code,{children:"mark"})," method provide the mechanism to do this."]})}),"\n",(0,s.jsx)(n.h2,{id:"typeddata-and-datatypefunctions",children:"TypedData and DataTypeFunctions"}),"\n",(0,s.jsxs)(n.p,{children:["Magnus provides a ",(0,s.jsx)(n.code,{children:"TypedData"})," trait and ",(0,s.jsx)(n.code,{children:"DataTypeFunctions"})," trait for managing Ruby objects that wrap Rust structs. This\nis the recommended way to handle complex objects in Rust."]}),"\n",(0,s.jsx)(n.h3,{id:"basic-typeddata-example",children:"Basic TypedData Example"}),"\n",(0,s.jsx)(n.p,{children:"Here's how to define a simple Ruby object that wraps a Rust struct:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{prelude::*, Error, Ruby, TypedData, DataTypeFunctions, function, method, Value};\n\nuse std::cell::RefCell;\n\n// Define your Rust struct with interior mutability\n#[derive(TypedData)]\n#[magnus(class = "MyExtension::Counter", free_immediately)]\nstruct Counter(RefCell<i64>);\n\n// Implement required functions\nimpl DataTypeFunctions for Counter {}\n\n// Implement methods for your struct\nimpl Counter {\n    fn new(initial_value: i64) -> Self {\n        Counter(RefCell::new(initial_value))\n    }\n\n    fn increment(&self, amount: i64) -> i64 {\n        let mut count = self.0.borrow_mut();\n        *count += amount;\n        *count\n    }\n\n    fn value(&self) -> i64 {\n        *self.0.borrow()\n    }\n}\n\n// Register with Ruby\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let class = ruby.define_class("Counter", ruby.class_object())?;\n\n    class.define_singleton_method("new", function!(Counter::new, 1))?;\n\n    class.define_method("increment", method!(Counter::increment, 1))?;\n    class.define_method("value", method!(Counter::value, 0))?;\n\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"implementing-gc-marking",children:"Implementing GC Marking"}),"\n",(0,s.jsxs)(n.p,{children:["When your Rust struct holds references to Ruby objects, you need to implement the ",(0,s.jsx)(n.code,{children:"mark"})," method to tell Ruby's GC about\nthose references. Here's a simple example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{\n    prelude::*, Error, Ruby, Value, TypedData, DataTypeFunctions,\n    gc::Marker, typed_data::Obj, function, method\n};\n\nuse std::cell::RefCell;\n\n// Internal data structure\nstruct PersonData {\n    // Reference to a Ruby string (their name)\n    name: Value,\n    // Reference to Ruby array (their hobbies)\n    hobbies: Value,\n    // Optional reference to another Person (their friend)\n    friend: Option<Obj<Person>>,\n}\n\n// A struct that holds references to Ruby objects\n#[derive(TypedData)]\n#[magnus(class = "MyExtension::Person", free_immediately, mark)]\nstruct Person(RefCell<PersonData>);\n\n// SAFETY: Person is only accessed from Ruby threads with the GVL\nunsafe impl Send for Person {}\n\n// Implement DataTypeFunctions with mark method\nimpl DataTypeFunctions for Person {\n    // This is called during GC mark phase\n    fn mark(&self, marker: &Marker) {\n        let data = self.0.borrow();\n        // Mark the Ruby objects we reference\n        marker.mark(data.name);\n        marker.mark(data.hobbies);\n\n        // If we have a friend, mark them too\n        if let Some(ref friend) = data.friend {\n            marker.mark(*friend);\n        }\n    }\n}\n\nimpl Person {\n    fn new(name: Value, hobbies: Value) -> Self {\n        Self(RefCell::new(PersonData {\n            name,\n            hobbies,\n            friend: None,\n        }))\n    }\n\n    fn add_friend(&self, friend: Obj<Person>) {\n        self.0.borrow_mut().friend = Some(friend);\n    }\n\n    fn name(&self) -> Value {\n        self.0.borrow().name\n    }\n\n    fn hobbies(&self) -> Value {\n        self.0.borrow().hobbies\n    }\n\n    fn friend(&self) -> Option<Obj<Person>> {\n        self.0.borrow().friend\n    }\n}\n\n// Register with Ruby\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let class = ruby.define_class("Person", ruby.class_object())?;\n\n    class.define_singleton_method("new", function!(Person::new, 2))?;\n\n    class.define_method("name", method!(Person::name, 0))?;\n    class.define_method("hobbies", method!(Person::hobbies, 0))?;\n    class.define_method("friend", method!(Person::friend, 0))?;\n    class.define_method("add_friend", method!(Person::add_friend, 1))?;\n\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"In this example:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"Person"})," struct holds references to Ruby objects (",(0,s.jsx)(n.code,{children:"name"})," and ",(0,s.jsx)(n.code,{children:"hobbies"}),") and another wrapped Rust object\n(",(0,s.jsx)(n.code,{children:"friend"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["We implement the ",(0,s.jsx)(n.code,{children:"mark"})," method to tell Ruby's GC about all these references"]}),"\n",(0,s.jsxs)(n.li,{children:["During garbage collection, Ruby will know not to collect these objects as long as the ",(0,s.jsx)(n.code,{children:"Person"})," is alive"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"a-real-world-example-error-handler",children:"A Real-World Example: Error Handler"}),"\n",(0,s.jsx)(n.p,{children:"Here's an example of a real-world error handling pattern:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{\n    prelude::*, method, Error, Ruby, TypedData, DataTypeFunctions,\n    typed_data::Obj, Symbol\n};\n\n// Different error types that might occur\n#[derive(Debug, Clone)]\npub enum ErrorKind {\n    StackOverflow,\n    MemoryOutOfBounds,\n    InvalidOperation(String),\n    Unknown,\n}\n\n// A struct representing an error with optional backtrace\n#[derive(TypedData)]\n#[magnus(class = "MyExtension::Error", size, free_immediately)]\npub struct ErrorInfo {\n    kind: ErrorKind,\n    message: String,\n    backtrace: Option<String>,\n}\n\n// No references to Ruby objects, so mark is empty\nimpl DataTypeFunctions for ErrorInfo {}\n\nimpl ErrorInfo {\n    pub fn new(kind: ErrorKind, message: String, backtrace: Option<String>) -> Self {\n        Self {\n            kind,\n            message,\n            backtrace,\n        }\n    }\n\n    // Return a text description of the error\n    pub fn message(&self) -> String {\n        self.message.clone()\n    }\n\n    // Return the backtrace if available\n    pub fn backtrace_message(&self) -> Option<String> {\n        self.backtrace.clone()\n    }\n\n    // Return the error code as a Ruby symbol\n    pub fn code(&self) -> Result<Option<Symbol>, Error> {\n        match &self.kind {\n            ErrorKind::StackOverflow => Ok(Some(Symbol::new("STACK_OVERFLOW"))),\n            ErrorKind::MemoryOutOfBounds => Ok(Some(Symbol::new("MEMORY_OUT_OF_BOUNDS"))),\n            ErrorKind::InvalidOperation(_) => Ok(Some(Symbol::new("INVALID_OPERATION"))),\n            ErrorKind::Unknown => Ok(Some(Symbol::new("UNKNOWN"))),\n        }\n    }\n\n    // Custom inspect method\n    pub fn inspect(rb_self: Obj<Self>) -> Result<String, Error> {\n        Ok(format!(\n            "#<MyExtension::Error:0x{:016x} @error_code={}>",\n            &rb_self as *const _ as usize,\n            rb_self.code()?.map_or("nil".to_string(), |s| s.to_string())\n        ))\n    }\n}\n\n// Register with Ruby\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let module = ruby.define_module("MyExtension")?;\n    let class = module.define_class("Error", ruby.class_object())?;\n\n    class.define_method("message", method!(ErrorInfo::message, 0))?;\n    class.define_method("backtrace_message", method!(ErrorInfo::backtrace_message, 0))?;\n    class.define_method("code", method!(ErrorInfo::code, 0))?;\n    class.define_method("inspect", method!(ErrorInfo::inspect, 0))?;\n\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This example shows:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"A Rust struct that wraps error information with an optional backtrace"}),"\n",(0,s.jsx)(n.li,{children:"Methods that convert Rust values to Ruby-friendly types"}),"\n",(0,s.jsxs)(n.li,{children:["A simple implementation of ",(0,s.jsx)(n.code,{children:"DataTypeFunctions"})," (since there are no Ruby object references to mark)"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"more-complex-example-memory-references",children:"More Complex Example: Memory References"}),"\n",(0,s.jsx)(n.p,{children:"Let's look at a more complex scenario involving memory management:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{\n    prelude::*, gc::Marker, Error, Ruby, TypedData, DataTypeFunctions,\n    typed_data::Obj, value::Opaque, RString, Value\n};\n\n// Placeholder types for the example\nstruct StoreContext(Value);\nstruct WasmMemory;\n\nimpl StoreContext {\n    fn mark(&self, marker: &Marker) {\n        marker.mark(self.0);\n    }\n}\n\n// Represents WebAssembly memory\n#[derive(TypedData)]\n#[magnus(class = "Wasmtime::Memory", free_immediately, mark)]\nstruct Memory {\n    // Reference to a store (context) object\n    store: StoreContext,\n    // The actual WebAssembly memory\n    memory: WasmMemory,\n}\n\n// SAFETY: Memory is only accessed from Ruby threads with the GVL\nunsafe impl Send for Memory {}\n\nimpl DataTypeFunctions for Memory {\n    fn mark(&self, marker: &Marker) {\n        // Mark the store so it stays alive\n        self.store.mark(marker);\n    }\n}\n\nimpl Memory {\n    fn size(&self) -> Result<u64, Error> {\n        Ok(65536) // Example: 64KB\n    }\n    \n    fn data_size(&self) -> Result<usize, Error> {\n        Ok(65536) // Example: 64KB\n    }\n    \n    fn data(&self) -> Result<Vec<u8>, Error> {\n        Ok(vec![0; 65536]) // Example: zero-filled memory\n    }\n}\n\n// A guard that ensures memory access is safe\nstruct MemoryGuard {\n    // Reference to Memory object\n    memory: Opaque<Obj<Memory>>,\n    // Size when created, to detect resizing\n    original_size: u64,\n}\n\nimpl MemoryGuard {\n    fn new(memory: Obj<Memory>) -> Result<Self, Error> {\n        let original_size = memory.size()?;\n\n        Ok(Self {\n            memory: memory.into(),\n            original_size,\n        })\n    }\n\n    fn get(&self) -> Result<&Memory, Error> {\n        let ruby = unsafe { Ruby::get_unchecked() };\n        let mem = ruby.get_inner_ref(&self.memory);\n\n        // Check that memory size hasn\'t changed\n        if mem.size()? != self.original_size {\n            return Err(Error::new(\n                magnus::exception::runtime_error(),\n                "memory was resized, reference is no longer valid"\n            ));\n        }\n\n        Ok(mem)\n    }\n\n    fn mark(&self, marker: &Marker) {\n        marker.mark(self.memory);\n    }\n}\n\n// A slice of WebAssembly memory\n#[derive(TypedData)]\n#[magnus(class = "Wasmtime::MemorySlice", free_immediately, mark)]\nstruct MemorySlice {\n    guard: MemoryGuard,\n    offset: usize,\n    size: usize,\n}\n\n// SAFETY: MemorySlice is only accessed from Ruby threads with the GVL\nunsafe impl Send for MemorySlice {}\n\nimpl DataTypeFunctions for MemorySlice {\n    fn mark(&self, marker: &Marker) {\n        // Mark the memory guard, which marks the memory object\n        self.guard.mark(marker);\n    }\n}\n\nimpl MemorySlice {\n    fn new(memory: Obj<Memory>, offset: usize, size: usize) -> Result<Self, Error> {\n        let guard = MemoryGuard::new(memory)?;\n\n        // Validate the slice is in bounds\n        let mem = guard.get()?;\n        if offset + size > mem.data_size()? {\n            return Err(Error::new(\n                magnus::exception::range_error(),\n                "memory slice out of bounds"\n            ));\n        }\n\n        Ok(Self {\n            guard,\n            offset,\n            size,\n        })\n    }\n\n    // Read the slice as a Ruby string (efficiently, without copying)\n    fn to_str(&self) -> Result<RString, Error> {\n        let ruby = unsafe { Ruby::get_unchecked() };\n        let mem = self.guard.get()?;\n        let data = mem.data()?;\n\n        // Extract the relevant slice\n        let slice = &data[self.offset..self.offset + self.size];\n\n        // Create a Ruby string directly from the slice (zero-copy)\n        Ok(ruby.str_from_slice(slice))\n    }\n\n    // Read the slice as a UTF-8 string (with validation)\n    fn to_utf8_str(&self) -> Result<RString, Error> {\n        let ruby = unsafe { Ruby::get_unchecked() };\n        let mem = self.guard.get()?;\n        let data = mem.data()?;\n\n        // Extract the relevant slice\n        let slice = &data[self.offset..self.offset + self.size];\n\n        // Validate UTF-8 and create a Ruby string\n        match std::str::from_utf8(slice) {\n            Ok(s) => Ok(RString::new(s)),\n            Err(e) => Err(Error::new(\n                magnus::exception::encoding_error(),\n                format!("invalid UTF-8: {}", e)\n            ))\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This more advanced example demonstrates:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Guarded Resource Access"}),": The ",(0,s.jsx)(n.code,{children:"MemoryGuard"})," ensures memory operations are safe by checking for resizing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Proper GC Integration"}),": Both structs implement marking to ensure referenced objects aren't collected"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Efficient String Creation"}),": Using ",(0,s.jsx)(n.code,{children:"str_from_slice"})," to create strings directly from memory without extra copying"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error Handling"}),": All operations that might fail return meaningful errors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource Validation"}),": The code validates bounds before accessing memory"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"common-memory-management-pitfalls",children:"Common Memory Management Pitfalls"}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"These pitfalls can lead to crashes, memory leaks, or undefined behavior in your Ruby extensions. Understanding and\navoiding them is crucial for writing reliable code."})}),"\n",(0,s.jsx)(n.h3,{id:"1-forgetting-to-mark-references",children:"1. Forgetting to Mark References"}),"\n",(0,s.jsx)(n.p,{children:"If your Rust struct holds Ruby objects but doesn't implement marking, those objects might be collected while still in\nuse:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{Error, RString};\nuse std::cell::RefCell;\n\n// Example: Store Ruby data as Rust types instead of Value\n#[magnus::wrap(class = "DataHolder")]\nstruct DataHolder {\n    // Store extracted data, not Ruby Values\n    strings: RefCell<Vec<String>>,\n    data: RefCell<std::collections::HashMap<String, String>>,\n}\n\nimpl DataHolder {\n    fn new() -> Self {\n        DataHolder {\n            strings: RefCell::new(Vec::new()),\n            data: RefCell::new(std::collections::HashMap::new()),\n        }\n    }\n    \n    fn add_string(&self, ruby_str: RString) -> Result<(), Error> {\n        self.strings.borrow_mut().push(ruby_str.to_string()?);\n        Ok(())\n    }\n    \n    fn add_data(&self, key: String, value: String) -> Result<(), Error> {\n        self.data.borrow_mut().insert(key, value);\n        Ok(())\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-creating-cyclic-references",children:"2. Creating Cyclic References"}),"\n",(0,s.jsx)(n.p,{children:"Cyclic references (A references B, which references A) can lead to memory leaks. Consider using weak references or\nredesigning your object graph."}),"\n",(0,s.jsx)(n.h3,{id:"3-inefficient-string-creation",children:"3. Inefficient String Creation"}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"String handling is often a performance bottleneck in Ruby extensions. Using the right APIs can significantly improve\nperformance."})}),"\n",(0,s.jsx)(n.p,{children:"Creating strings inefficiently can significantly impact performance:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use magnus::{Error, RString, Ruby};\n\n// BAD: Creates unnecessary temporary Rust String\nfn inefficient_string(data: &[u8]) -> Result<RString, Error> {\n    let temp_string = String::from_utf8(data.to_vec()).map_err(|e| Error::new(magnus::exception::type_error(), e.to_string()))?; // Unnecessary allocation\n    Ok(RString::new(&temp_string))  // Another copy\n}\n\n// GOOD: Direct creation from slice\nfn efficient_string(ruby: &Ruby, data: &[u8]) -> RString {\n    ruby.str_from_slice(data)  // No extra copies\n}\n\n// ALSO GOOD: Creating from string slice when UTF-8 is confirmed\nfn from_str(_ruby: &Ruby, s: &str) -> RString {\n    RString::new(s)\n}\n\n// ALSO GOOD: Creating binary string with capacity then filling\nfn build_string(_ruby: &Ruby, size: usize) -> RString {\n    // In a real implementation, you would fill the string here\n    RString::with_capacity(size)\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-not-handling-exceptions-properly",children:"4. Not Handling Exceptions Properly"}),"\n",(0,s.jsx)(n.p,{children:"Ruby exceptions can disrupt the normal flow of your code. Ensure resources are cleaned up even when exceptions occur."}),"\n",(0,s.jsx)(n.h2,{id:"refcell-and-interior-mutability",children:"RefCell and Interior Mutability"}),"\n",(0,s.jsxs)(n.p,{children:["When creating Ruby objects with Rust, you'll often need to use interior mutability patterns. The most common approach is\nusing ",(0,s.jsx)(n.code,{children:"RefCell"})," to allow your Ruby objects to be mutated even when users hold immutable references to them."]}),"\n",(0,s.jsx)(n.h3,{id:"understanding-refcell-and-borrowing",children:"Understanding RefCell and Borrowing"}),"\n",(0,s.jsxs)(n.p,{children:["Rust's ",(0,s.jsx)(n.code,{children:"RefCell"})," allows mutable access to data through shared references, but enforces Rust's borrowing rules at\nruntime. This is perfect for Ruby extension objects, where Ruby owns the object and we interact with it via method\ncalls."]}),"\n",(0,s.jsxs)(n.p,{children:["A common pattern is to wrap your Rust struct in a ",(0,s.jsx)(n.code,{children:"RefCell"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use std::cell::RefCell;\nuse magnus::{prelude::*, Error, Ruby};\n\nstruct Counter {\n    count: i64,\n}\n\n#[magnus::wrap(class = "MyExtension::Counter")]\nstruct MutCounter(RefCell<Counter>);\n\nimpl MutCounter {\n    fn new(initial: i64) -> Self {\n        Self(RefCell::new(Counter { count: initial }))\n    }\n\n    fn count(&self) -> i64 {\n        self.0.borrow().count\n    }\n\n    fn increment(&self) -> i64 {\n        let mut counter = self.0.borrow_mut();\n        counter.count += 1;\n        counter.count\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"the-borrowmuterror-problem",children:"The BorrowMutError Problem"}),"\n",(0,s.jsxs)(n.p,{children:["A common mistake when using ",(0,s.jsx)(n.code,{children:"RefCell"})," is trying to borrow mutably when you already have an active immutable borrow. This\nleads to a ",(0,s.jsx)(n.code,{children:"BorrowMutError"})," panic:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{Error, Ruby};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct CounterInner {\n    count: i64,\n}\n\nstruct Counter(Rc<RefCell<CounterInner>>);\n\n// BAD - will panic with "already borrowed: BorrowMutError"\nimpl Counter {\n    fn buggy_add(&self, val: i64) -> Result<i64, Error> {\n        let ruby = unsafe { Ruby::get_unchecked() };\n        // First borrow is still active when we try to borrow_mut below\n        if let Some(sum) = self.0.borrow().count.checked_add(val) {\n            self.0.borrow_mut().count = sum; // ERROR - already borrowed above\n            Ok(sum)\n        } else {\n            Err(Error::new(\n                ruby.exception_range_error(),\n                "result too large"\n            ))\n        }\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The problem is that the ",(0,s.jsx)(n.code,{children:"borrow()"})," in the ",(0,s.jsx)(n.code,{children:"if"})," condition is still active when we try to use ",(0,s.jsx)(n.code,{children:"borrow_mut()"})," in the body.\nRust's borrow checker would catch this at compile time for normal references, but ",(0,s.jsx)(n.code,{children:"RefCell"})," defers this check to\nruntime, resulting in a panic."]}),"\n",(0,s.jsx)(n.h3,{id:"the-solution-complete-borrows-before-mutating",children:"The Solution: Complete Borrows Before Mutating"}),"\n",(0,s.jsx)(n.p,{children:"The solution is to complete all immutable borrows before starting mutable ones:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{Error, Ruby};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct CounterInner {\n    count: i64,\n}\n\nstruct Counter(Rc<RefCell<CounterInner>>);\n\n// GOOD - copy the value first to complete the borrow\nimpl Counter {\n    fn safe_add(&self, val: i64) -> Result<i64, Error> {\n        let ruby = unsafe { magnus::Ruby::get_unchecked() };\n        // Get the current count, completing this borrow\n        let current_count = self.0.borrow().count;\n\n        // Now we can safely borrow mutably\n        if let Some(sum) = current_count.checked_add(val) {\n            self.0.borrow_mut().count = sum; // Safe now\n            Ok(sum)\n        } else {\n            Err(Error::new(\n                ruby.exception_range_error(),\n                "result too large"\n            ))\n        }\n    }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["By copying ",(0,s.jsx)(n.code,{children:"count"})," to a local variable, we complete the immutable borrow before starting the mutable one, avoiding the\nruntime panic."]}),"\n",(0,s.jsx)(n.h3,{id:"complex-example-with-multiple-operations",children:"Complex Example with Multiple Operations"}),"\n",(0,s.jsx)(n.p,{children:"When working with more complex data structures:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use std::cell::RefCell;\nuse magnus::Error;\n\nstruct Game {\n    players: Vec<String>,\n    current_player: usize,\n    score: i64,\n}\n\n#[magnus::wrap(class = "MyGame")]\nstruct MutGame(RefCell<Game>);\n\nimpl MutGame {\n    fn new() -> Self {\n        Self(RefCell::new(Game {\n            players: Vec::new(),\n            current_player: 0,\n            score: 0,\n        }))\n    }\n\n    // INCORRECT: Multiple borrows that will cause issues\n    fn buggy_next_player_scores(&self, points: i64) -> Result<String, Error> {\n        let game = self.0.borrow();\n        if game.players.is_empty() {\n            return Err(Error::new(\n                magnus::exception::runtime_error(),\n                "No players in game"\n            ));\n        }\n\n        // This would panic - we\'re still borrowing game\n        let mut game_mut = self.0.borrow_mut();\n        game_mut.score += points;\n        let player = game_mut.current_player;\n        game_mut.current_player = (player + 1) % game_mut.players.len();\n\n        Ok(format!("{} scored {} points! New total: {}",\n            game_mut.players[player], points, game_mut.score))\n    }\n\n    // CORRECT: Copy all needed data before releasing the borrow\n    fn safe_next_player_scores(&self, points: i64) -> Result<String, Error> {\n        // Read all the data we need first\n        let player_name: String;\n        let new_player_index: usize;\n        let new_score: i64;\n\n        {\n            // Create a block scope to ensure the borrow is dropped\n            let game = self.0.borrow();\n            if game.players.is_empty() {\n                return Err(Error::new(\n                    magnus::exception::runtime_error(),\n                    "No players in game"\n                ));\n            }\n\n            player_name = game.players[game.current_player].clone();\n            new_player_index = (game.current_player + 1) % game.players.len();\n            new_score = game.score + points;\n        } // borrow is dropped here\n\n        // Now we can borrow mutably\n        let mut game = self.0.borrow_mut();\n        game.score = new_score;\n        game.current_player = new_player_index;\n\n        Ok(format!("{} scored {} points! New total: {}",\n            player_name, points, new_score))\n    }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"using-temporary-variables-instead-of-block-scopes",children:"Using Temporary Variables Instead of Block Scopes"}),"\n",(0,s.jsx)(n.p,{children:"If you prefer, you can use temporary variables instead of block scopes:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"use magnus::{Error, Ruby};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct GameState {\n    players: Vec<String>,\n    score: i64,\n    current_player: usize,\n}\n\nstruct Game(Rc<RefCell<GameState>>);\n\nimpl Game {\n    fn add_player(&self, player: String) -> Result<usize, Error> {\n        // Get the current number of players first\n        let player_count = self.0.borrow().players.len();\n\n        // Now we can mutate\n        let mut game = self.0.borrow_mut();\n        game.players.push(player);\n\n        Ok(player_count + 1) // Return new count\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"refcell-best-practices",children:"RefCell Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Complete All Borrows"}),": Always complete immutable borrows before starting mutable borrows."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use Block Scopes or Variables"}),": Either use block scopes to limit borrow lifetimes or copy needed values to local\nvariables."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Minimize Borrow Scope"}),": Keep the scope of borrows as small as possible."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Clone When Necessary"}),": If you need to keep references to data while mutating other parts, clone the data you need\nto keep."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Consider Data Design"}),": Structure your data to minimize the need for complex borrowing patterns."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Error When Conflicting"}),": If you can't resolve a borrowing conflict cleanly, make the operation an error rather\nthan trying to force it."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use TypedData and DataTypeFunctions"}),": They provide a safe framework for memory management"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Always Implement Mark Methods"}),": Mark all Ruby objects your struct references"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Validate Assumptions"}),": Check that resources are valid before using them"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Zero-Copy APIs"}),": Leverage APIs like ",(0,s.jsx)(n.code,{children:"str_from_slice"})," to avoid unnecessary copying"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use Guards for Changing Data"}),": Validate assumptions before accessing data that might change"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Test Thoroughly with GC Stress"}),": Run tests with ",(0,s.jsx)(n.code,{children:"GC.stress = true"})," to expose memory issues"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Handle RefCell Borrowing Carefully"}),": Complete all immutable borrows before starting mutable ones to avoid runtime\npanics"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"By following these practices, you can write Ruby extensions in Rust that are both memory-safe and efficient."})]})}function m(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>i});var t=r(6540);const s={},o=t.createContext(s);function a(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);