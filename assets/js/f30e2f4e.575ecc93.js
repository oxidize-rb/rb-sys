"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[8138],{599:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"glossary","title":"Glossary","description":"Definitions of common terms used in Ruby and Rust extension development.","source":"@site/docs/glossary.mdx","sourceDirName":".","slug":"/glossary","permalink":"/docs/glossary","draft":false,"unlisted":false,"editUrl":"https://github.com/oxidize-rb/rb-sys/tree/main/docsite/docs/glossary.mdx","tags":[],"version":"current","lastUpdatedBy":"Ian Ker-Seymer","lastUpdatedAt":1752632597000,"sidebarPosition":21,"frontMatter":{"id":"glossary","title":"Glossary","sidebar_position":21,"keywords":["glossary","terms","definitions","terminology"],"description":"Definitions of common terms used in Ruby and Rust extension development."},"sidebar":"docsSidebar","previous":{"title":"Frequently Asked Questions","permalink":"/docs/faq"},"next":{"title":"Community and Support","permalink":"/docs/community-support"}}');var r=s(4848),t=s(8453);const o={id:"glossary",title:"Glossary",sidebar_position:21,keywords:["glossary","terms","definitions","terminology"],description:"Definitions of common terms used in Ruby and Rust extension development."},l="Glossary",c={},d=[{value:"A",id:"a",level:2},{value:"B",id:"b",level:2},{value:"C",id:"c",level:2},{value:"D",id:"d",level:2},{value:"E",id:"e",level:2},{value:"F",id:"f",level:2},{value:"G",id:"g",level:2},{value:"I",id:"i",level:2},{value:"L",id:"l",level:2},{value:"M",id:"m",level:2},{value:"O",id:"o",level:2},{value:"P",id:"p",level:2},{value:"R",id:"r",level:2},{value:"S",id:"s",level:2},{value:"T",id:"t",level:2},{value:"U",id:"u",level:2},{value:"V",id:"v",level:2},{value:"W",id:"w",level:2},{value:"Common Acronyms",id:"common-acronyms",level:2},{value:"Missing a Term?",id:"missing-a-term",level:3}];function a(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"glossary",children:"Glossary"})}),"\n",(0,r.jsx)(n.p,{children:"Quick reference for terms used throughout rb-sys documentation."}),"\n",(0,r.jsx)(n.h2,{id:"a",children:"A"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"ABI (Application Binary Interface)"}),"\n: The low-level interface between compiled code and the system. Defines how functions are called, how data is represented in memory, etc."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"API (Application Programming Interface)"}),"\n: The high-level interface for using a library or system. In rb-sys context, refers to Ruby's C API or Magnus's Rust API."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Arity"}),"\n: The number of arguments a function accepts. In Ruby, this determines how Magnus registers methods."]}),"\n",(0,r.jsx)(n.h2,{id:"b",children:"B"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Bindgen"}),"\n: A Rust tool that automatically generates FFI bindings from C header files. Used by rb-sys to create Ruby C API bindings."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Borrowing"}),"\n: Rust's mechanism for temporary access to data without taking ownership. Prevents data races at compile time."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Build Script (build.rs)"}),"\n: Rust code that runs before compilation. Used to configure the build process, generate code, or link to external libraries."]}),"\n",(0,r.jsx)(n.h2,{id:"c",children:"C"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"C API"}),"\n: Ruby's native extension interface, written in C. Provides functions for creating Ruby objects, calling methods, etc."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cargo"}),"\n: Rust's package manager and build tool. Similar to Bundler for Ruby."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cargo.toml"}),"\n: Rust's project configuration file. Specifies dependencies, metadata, and build settings."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"cdylib"}),"\n: A type of Rust library that produces a C-compatible dynamic library. Required for Ruby extensions."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"CFG"}),"\n: Conditional compilation in Rust. Allows code to be included/excluded based on configuration."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Crate"}),"\n: A Rust package or library. Can be published to crates.io."]}),"\n",(0,r.jsx)(n.h2,{id:"d",children:"D"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"DataTypeFunctions"}),"\n: Magnus trait for defining how Ruby's GC interacts with Rust structs. Includes marking and deallocation."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Drop"}),"\n: Rust trait for cleanup when a value goes out of scope. Similar to Ruby's finalizers but deterministic."]}),"\n",(0,r.jsx)(n.h2,{id:"e",children:"E"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"extconf.rb"}),"\n: Ruby script that configures extension compilation. Creates a Makefile for building native extensions."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Extension"}),"\n: Native code (C, Rust, etc.) compiled into a shared library that Ruby can load."]}),"\n",(0,r.jsx)(n.h2,{id:"f",children:"F"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"FFI (Foreign Function Interface)"}),"\n: Mechanism for calling functions across language boundaries. How Rust calls Ruby's C API."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Feature Flags"}),"\n: Compile-time options in Rust. Enable/disable functionality or dependencies."]}),"\n",(0,r.jsx)(n.h2,{id:"g",children:"G"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"GC (Garbage Collector)"}),"\n: Ruby's automatic memory management system. Cleans up unused objects."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Gem"}),"\n: Ruby package format. Can include pure Ruby code and/or native extensions."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Gemspec"}),"\n: Ruby gem specification file. Defines metadata, dependencies, and files."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"GVL (Global VM Lock)"}),"\n: Ruby's Global VM Lock (also called GIL). Prevents true parallelism in Ruby threads."]}),"\n",(0,r.jsx)(n.h2,{id:"i",children:"I"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Interior Mutability"}),"\n: Rust pattern allowing mutation through shared references. Often uses ",(0,r.jsx)(n.code,{children:"RefCell"})," or ",(0,r.jsx)(n.code,{children:"Mutex"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"l",children:"L"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Lifetime"}),"\n: Rust's way of tracking how long references are valid. Prevents use-after-free errors."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Link-Time Optimization (LTO)"}),"\n: Optimization across compilation units. Can significantly improve performance but increases build time."]}),"\n",(0,r.jsx)(n.h2,{id:"m",children:"M"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Magnus"}),"\n: High-level Rust library for Ruby extensions. Provides safe, ergonomic API over rb-sys."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Makefile"}),"\n: Build instructions generated by extconf.rb. Used by Ruby to compile extensions."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Marking"}),"\n: Process of telling Ruby's GC about references from Rust to Ruby objects. Prevents premature collection."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"mkmf"}),"\n: Ruby's makefile generator library. Used by extconf.rb."]}),"\n",(0,r.jsx)(n.h2,{id:"o",children:"O"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Ownership"}),"\n: Rust's memory management model. Each value has one owner, and is freed when the owner goes out of scope."]}),"\n",(0,r.jsx)(n.h2,{id:"p",children:"P"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Panic"}),"\n: Rust's unrecoverable error. Should be avoided in Ruby extensions as it can crash Ruby."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Platform Triple"}),"\n: Target specification like ",(0,r.jsx)(n.code,{children:"x86_64-apple-darwin"}),". Identifies CPU architecture, vendor, and OS."]}),"\n",(0,r.jsx)(n.h2,{id:"r",children:"R"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"rb-sys"}),"\n: Low-level Rust bindings to Ruby's C API. Foundation for building Ruby extensions in Rust."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"rb_sys gem"}),"\n: Ruby gem that helps compile Rust extensions. Companion to the rb-sys crate."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"RAII (Resource Acquisition Is Initialization)"}),"\n: Pattern where resource lifetime is tied to object lifetime. Used extensively in Rust."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Rake"}),"\n: Ruby's build automation tool. Similar to Make but written in Ruby."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"RefCell"}),"\n: Rust type providing interior mutability with runtime borrow checking."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Result"}),"\n: Rust's error handling type. Either ",(0,r.jsx)(n.code,{children:"Ok(value)"})," or ",(0,r.jsx)(n.code,{children:"Err(error)"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"RSTRING"}),"\n: Ruby's internal string representation. Accessed through rb-sys for zero-copy operations."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Rustup"}),"\n: Rust toolchain installer and version manager."]}),"\n",(0,r.jsx)(n.h2,{id:"s",children:"S"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Segfault (Segmentation Fault)"}),"\n: Memory access violation causing program crash. Rust helps prevent these."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Symbol"}),"\n: Ruby's immutable string identifiers. Often used as hash keys or method names."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Static"}),"\n: In Rust, either compile-time constants or values that live for the program's lifetime."]}),"\n",(0,r.jsx)(n.h2,{id:"t",children:"T"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Target"}),"\n: Platform being compiled for. Can cross-compile for different targets."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Trait"}),"\n: Rust's interface mechanism. Defines shared behavior across types."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"TypedData"}),"\n: Ruby's way of wrapping C/Rust structs with type information and GC integration."]}),"\n",(0,r.jsx)(n.h2,{id:"u",children:"U"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Unsafe"}),"\n: Rust code that bypasses safety checks. Required for FFI but should be minimized."]}),"\n",(0,r.jsx)(n.h2,{id:"v",children:"V"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"VALUE"}),"\n: Ruby's generic object type in the C API. Represents any Ruby object."]}),"\n",(0,r.jsx)(n.h2,{id:"w",children:"W"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Workspace"}),"\n: Cargo feature for managing multiple related packages. Shares dependencies and build cache."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Wrapper"}),"\n: Code that provides a higher-level interface over low-level functionality."]}),"\n",(0,r.jsx)(n.h2,{id:"common-acronyms",children:"Common Acronyms"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"API"}),": Application Programming Interface"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CI/CD"}),": Continuous Integration/Continuous Deployment"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"DRY"}),": Don't Repeat Yourself"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"FFI"}),": Foreign Function Interface"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"GC"}),": Garbage Collector"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"GVL"}),": Global VM Lock (also GIL - Global Interpreter Lock)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"IDE"}),": Integrated Development Environment"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"JIT"}),": Just-In-Time compilation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"RAII"}),": Resource Acquisition Is Initialization"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"REPL"}),": Read-Eval-Print Loop"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"VM"}),": Virtual Machine"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"YAGNI"}),": You Aren't Gonna Need It"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"YJIT"}),": Yet another Ruby JIT"]}),"\n"]}),"\n",(0,r.jsx)(n.hr,{}),"\n",(0,r.jsxs)("div",{className:"success-message",children:[(0,r.jsx)(n.h3,{id:"missing-a-term",children:"Missing a Term?"}),(0,r.jsxs)(n.p,{children:["Help us improve by ",(0,r.jsx)(n.a,{href:"https://github.com/oxidize-rb/rb-sys",children:"submitting a PR"})," to add missing terms."]})]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var i=s(6540);const r={},t=i.createContext(r);function o(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);