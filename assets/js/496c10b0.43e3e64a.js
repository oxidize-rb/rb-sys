"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[1046],{1137:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>y,frontMatter:()=>i,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"working-with-ruby-objects","title":"Working with Ruby Objects","description":"When writing Ruby extensions in Rust, one of the most common tasks is converting between Ruby and Rust types. The magnus","source":"@site/docs/working-with-ruby-objects.mdx","sourceDirName":".","slug":"/working-with-ruby-objects","permalink":"/docs/working-with-ruby-objects","draft":false,"unlisted":false,"editUrl":"https://github.com/oxidize-rb/rb-sys/tree/main/docsite/docs/working-with-ruby-objects.mdx","tags":[],"version":"current","lastUpdatedBy":"Ian Ker-Seymer","lastUpdatedAt":1767892449000,"sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"docsSidebar","previous":{"title":"Basic Patterns","permalink":"/docs/basic-patterns"},"next":{"title":"Classes & Modules","permalink":"/docs/classes-and-modules"}}');var s=r(4848),a=r(8453);const i={sidebar_position:7},o="Working with Ruby Objects",l={},u=[{value:"Basic Type Conversions",id:"basic-type-conversions",level:2},{value:"Primitive Types",id:"primitive-types",level:3},{value:"Checking Types",id:"checking-types",level:3},{value:"Strings, Arrays, and Hashes",id:"strings-arrays-and-hashes",level:2},{value:"Working with Ruby Strings",id:"working-with-ruby-strings",level:3},{value:"Working with Ruby Arrays",id:"working-with-ruby-arrays",level:3},{value:"Working with Ruby Hashes",id:"working-with-ruby-hashes",level:3},{value:"Handling nil Values",id:"handling-nil-values",level:2},{value:"Converting Between Ruby and Rust Types",id:"converting-between-ruby-and-rust-types",level:2},{value:"From Ruby to Rust (TryConvert)",id:"from-ruby-to-rust-tryconvert",level:3},{value:"From Rust to Ruby (IntoValue)",id:"from-rust-to-ruby-intovalue",level:3},{value:"Best Practices",id:"best-practices",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"working-with-ruby-objects",children:"Working with Ruby Objects"})}),"\n",(0,s.jsx)(n.p,{children:"When writing Ruby extensions in Rust, one of the most common tasks is converting between Ruby and Rust types. The magnus\ncrate provides a comprehensive set of conversion functions for this purpose."}),"\n",(0,s.jsx)(n.h2,{id:"basic-type-conversions",children:"Basic Type Conversions"}),"\n",(0,s.jsx)(n.h3,{id:"primitive-types",children:"Primitive Types"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{RString, Ruby, Integer, Float, Error};\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    // Convert Rust types to Ruby\n    let rb_string: RString = ruby.str_new("Hello, Ruby!");        // Rust &str to Ruby String\n    let rb_int: Integer = ruby.integer_from_i64(42);                 // Rust i64 to Ruby Integer\n    let rb_float: Float = ruby.float_from_f64(std::f64::consts::PI); // Rust f64 to Ruby Float\n    let _rb_bool = ruby.qtrue();  // Rust bool to Ruby true/false\n\n    // Convert Ruby types to Rust\n    let _rust_string: String = rb_string.to_string()?;          // Ruby String to Rust String\n    let _rust_int: i64 = rb_int.to_i64()?;                      // Ruby Integer to Rust i64\n    let _rust_float: f64 = rb_float.to_f64();                   // Ruby Float to Rust f64\n    // To check if a value is true/false, compare with qtrue/qfalse\n\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"checking-types",children:"Checking Types"}),"\n",(0,s.jsxs)(n.p,{children:["When working with a generic ",(0,s.jsx)(n.code,{children:"magnus::Value"}),", you often need to determine what kind of object it is before you can work with it. The ",(0,s.jsx)(n.code,{children:"is_kind_of"})," method, combined with ",(0,s.jsx)(n.code,{children:"TryConvert"}),", provides a robust way to do this."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{function, method, prelude::*, Error, Ruby, Value, TryConvert};\n\n// An example of a simple wrapped struct.\n#[magnus::wrap(class = "MyNumber")]\nstruct MyNumber(i64);\n\nimpl MyNumber {\n    fn new(val: i64) -> Self { Self(val) }\n    fn get(&self) -> i64 { self.0 }\n}\n\n// A function that can accept different types from Ruby.\nfn process_value(ruby: &Ruby, val: Value) -> Result<(), Error> {\n    // We can use `is_kind_of` to check the class of a Ruby object before\n    // attempting a conversion.\n    if val.is_kind_of(ruby.class_integer()) {\n        let i = i64::try_convert(val)?;\n        println!("Got a built-in Integer: {}", i);\n    } else if val.is_kind_of(ruby.class_string()) {\n        let s = String::try_convert(val)?;\n        println!("Got a built-in String: \'{}\'", s);\n    } else if let Ok(n) = <&MyNumber>::try_convert(val) {\n        // For our own wrapped types, we can convert to a reference.\n        println!("Got our custom MyNumber with value: {}", n.get());\n    } else {\n        // As a fallback, print a generic message.\n        println!("Got some other type.");\n    }\n    Ok(())\n}\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    let my_number_class = ruby.define_class("MyNumber", ruby.class_object())?;\n    my_number_class.define_singleton_method("new", function!(MyNumber::new, 1))?;\n    my_number_class.define_method("get", method!(MyNumber::get, 0))?;\n    ruby.define_global_function("process_value", function!(process_value, 1));\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"strings-arrays-and-hashes",children:"Strings, Arrays, and Hashes"}),"\n",(0,s.jsx)(n.h3,{id:"working-with-ruby-strings",children:"Working with Ruby Strings"}),"\n",(0,s.jsx)(n.p,{children:"Ruby strings are encoded and have more complex behavior than Rust strings:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{RString, Ruby, value::ReprValue};\n\nfn string_operations(ruby: &Ruby) -> Result<(), magnus::Error> {\n    // Create a new Ruby string\n    let mut hello = ruby.str_new("Hello");\n\n    // Concatenate strings (using funcall)\n    let world = ruby.str_new(" World!");\n    let message: RString = hello.as_value().funcall("concat", (world,))?;\n\n    // Get bytes\n    let bytes = unsafe { message.as_slice() };\n    println!("Bytes: {:?}", bytes);\n\n    // Create from bytes\n    let bytes = [72, 101, 108, 108, 111]; // "Hello" in ASCII\n    let _new_str = ruby.str_from_slice(&bytes);\n\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"working-with-ruby-arrays",children:"Working with Ruby Arrays"}),"\n",(0,s.jsx)(n.p,{children:"Ruby arrays can hold any kind of Ruby object:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{RArray, Ruby, Value};\n\nfn array_operations(ruby: &Ruby) -> Result<(), magnus::Error> {\n    // Create a new empty array\n    let array: RArray = ruby.ary_new();\n\n    // Push elements\n    array.push(1)?;\n    array.push("two")?;\n    array.push(3.0)?;\n\n    // Get length\n    let _length = array.len();\n\n    // Access elements\n    let _first: i64 = array.entry(0)?;\n    let _second: String = array.entry(1)?;\n    let _third: f64 = array.entry(2)?;\n\n    // Iterate through elements\n    for i in 0..array.len() {\n        let item: Value = array.entry(i as isize)?;\n        println!("Item {}: {:?}", i, item);\n    }\n\n    // Another way to iterate\n    array.into_iter().for_each(|val| {\n        println!("Item: {:?}", val);\n    });\n\n    // Create an array from Rust Vec\n    let numbers = vec![1, 2, 3, 4, 5];\n    let rb_array = ruby.ary_from_vec(numbers);\n\n    // Convert to a Rust Vec\n    let _vec: Vec<i64> = rb_array.to_vec()?;\n\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"working-with-ruby-hashes",children:"Working with Ruby Hashes"}),"\n",(0,s.jsx)(n.p,{children:"Ruby hashes are similar to Rust's HashMap but can use any Ruby object as keys:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{RHash, Value, Ruby, r_hash::ForEach, TryConvert, Error};\n\nfn hash_operations(ruby: &Ruby) -> Result<(), magnus::Error> {\n    // Create a new hash\n    let hash: RHash = ruby.hash_new();\n\n    // Add key-value pairs\n    hash.aset("name", "Alice")?;\n    hash.aset(ruby.to_symbol("age"), 30)?;\n    hash.aset(1, "one")?;\n\n    // Get values\n    let _name: String = TryConvert::try_convert(\n        hash.get("name")\n            .ok_or_else(|| Error::new(ruby.exception_key_error(), "name not found"))?\n    )?;\n    let _age: i64 = TryConvert::try_convert(\n        hash.get(ruby.to_symbol("age"))\n            .ok_or_else(|| Error::new(ruby.exception_key_error(), "age not found"))?\n    )?;\n    let _one: String = TryConvert::try_convert(\n        hash.get(1)\n            .ok_or_else(|| Error::new(ruby.exception_key_error(), "1 not found"))?\n    )?;\n\n    // Check if key exists\n    if hash.get("name").is_some() {\n        println!("Has key \'name\'");\n    }\n\n    // Delete a key\n    let _deleted: Value = hash.delete(1)?;\n\n    // Iterate over key-value pairs\n    hash.foreach(|k: Value, v: Value| {\n        println!("Key: {:?}, Value: {:?}", k, v);\n        Ok(ForEach::Continue)\n    })?;\n\n    // Convert to a Rust HashMap (if keys and values are convertible)\n    // Convert to Rust HashMap by iterating\n    let mut map = std::collections::HashMap::new();\n    hash.foreach(|k: Value, v: Value| {\n        if let (Ok(key), Ok(value)) = (String::try_convert(k), String::try_convert(v)) {\n            map.insert(key, value);\n        }\n        Ok(ForEach::Continue)\n    })?;\n\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"handling-nil-values",children:"Handling nil Values"}),"\n",(0,s.jsxs)(n.p,{children:["Ruby's ",(0,s.jsx)(n.code,{children:"nil"})," is a special value that requires careful handling:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{Value, Ruby, RString, value::ReprValue, TryConvert, Error};\n\nfn handle_nil(_ruby: &Ruby, val: Value) -> Result<(), Error> {\n    // Try to convert value - returns None if nil or wrong type\n    let maybe_string: Option<RString> = TryConvert::try_convert(val).ok();\n    match maybe_string {\n        Some(s) => println!("Got string: {}", s.to_string()?),\n        None => println!("No string (was nil or couldn\'t convert)"),\n    }\n\n    // Return nil from a function\n    fn returns_nil(ruby: &Ruby) -> Value {\n        ruby.qnil().as_value()\n    }\n    let _ = returns_nil; // silence unused warning\n\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"converting-between-ruby-and-rust-types",children:"Converting Between Ruby and Rust Types"}),"\n",(0,s.jsx)(n.p,{children:"Magnus provides powerful type conversion traits that make it easy to convert between Ruby and Rust types."}),"\n",(0,s.jsx)(n.h3,{id:"from-ruby-to-rust-tryconvert",children:"From Ruby to Rust (TryConvert)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{Value, Ruby, TryConvert, Error, RHash};\n\n// Convert custom Rust types to Ruby objects\nstruct Person {\n    name: String,\n    age: u32,\n}\n\nimpl TryConvert for Person {\n    fn try_convert(val: Value) -> Result<Self, Error> {\n        let ruby = unsafe { Ruby::get_unchecked() };\n        let hash = RHash::try_convert(val)?;\n\n        let name: String = TryConvert::try_convert(hash.get("name").ok_or_else(|| Error::new(ruby.exception_key_error(), "name not found"))?)?;\n        let age: u32 = TryConvert::try_convert(hash.get("age").ok_or_else(|| Error::new(ruby.exception_key_error(), "age not found"))?)?;\n\n        Ok(Person { name, age })\n    }\n}\n\n// Usage\nfn process_person(val: Value) -> Result<(), Error> {\n    let person: Person = Person::try_convert(val)?;\n    println!("Person: {} ({})", person.name, person.age);\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"from-rust-to-ruby-intovalue",children:"From Rust to Ruby (IntoValue)"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use magnus::{Value, Ruby, IntoValue, Error, value::ReprValue};\n\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\nimpl IntoValue for Point {\n    fn into_value_with(self, ruby: &Ruby) -> Value {\n        let hash = ruby.hash_new();\n        let _ = hash.aset("x", self.x);\n        let _ = hash.aset("y", self.y);\n        hash.as_value()\n    }\n}\n\n// Usage\nfn create_point(ruby: &Ruby) -> Result<Value, Error> {\n    let point = Point { x: 10.5, y: 20.7 };\n    Ok(point.into_value_with(ruby))\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Always Handle Errors"}),": Type conversions can fail, wrap them in proper error handling."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use try_convert"}),": Prefer ",(0,s.jsx)(n.code,{children:"try_convert"})," over direct conversions to safely handle type mismatches."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Remember Boxing Rules"}),": All Ruby objects are reference types, while many Rust types are value types."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Be Careful with Magic Methods"}),": Some Ruby methods like ",(0,s.jsx)(n.code,{children:"method_missing"})," might not behave as expected when called\nfrom Rust."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Cache Ruby Objects"}),": If you're repeatedly using the same Ruby objects (like classes or symbols), consider caching\nthem using ",(0,s.jsx)(n.code,{children:"Lazy"})," or similar mechanisms."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Check for nil"}),": Always check for nil values before attempting conversions that don't handle nil."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Use Type Annotations"}),": Explicitly specifying types when converting Ruby values to Rust can make your code clearer\nand avoid potential runtime errors."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Pass Ruby State"}),": Always pass the ",(0,s.jsx)(n.code,{children:"Ruby"})," instance through your functions when needed rather than using\n",(0,s.jsx)(n.code,{children:"Ruby::get()"})," repeatedly, as this is more performant and clearer about dependencies."]}),"\n"]}),"\n"]})]})}function y(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>i,x:()=>o});var t=r(6540);const s={},a=t.createContext(s);function i(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);