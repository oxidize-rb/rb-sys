<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ruby Classes and Modules - The Ruby on Rust Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A comprehensive guide to building Ruby extensions with Rust using rb-sys">
        <meta name="keywords" content="ruby, rust, ffi, bindings, rb-sys, ruby on rust">
        <meta name="author" content="">
        
        <!-- Open Graph / Facebook -->
        <meta property="og:type" content="website">
        <meta property="og:url" content="">
        <meta property="og:title" content="Ruby Classes and Modules - The Ruby on Rust Book">
        <meta property="og:description" content="A comprehensive guide to building Ruby extensions with Rust using rb-sys">
        
        <!-- Twitter -->
        <meta property="twitter:card" content="summary_large_image">
        <meta property="twitter:url" content="">
        <meta property="twitter:title" content="Ruby Classes and Modules - The Ruby on Rust Book">
        <meta property="twitter:description" content="A comprehensive guide to building Ruby extensions with Rust using rb-sys">
        
        <!-- Canonical URL -->
        <link rel="canonical" href="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Ruby on Rust Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/oxidize-rb/rb-sys" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ruby-classes-and-modules"><a class="header" href="#ruby-classes-and-modules">Ruby Classes and Modules</a></h1>
<p>This chapter covers how to define and work with Ruby classes and modules from Rust. It explains different approaches for
creating Ruby objects, defining methods, and organizing your code.</p>
<h2 id="defining-modules"><a class="header" href="#defining-modules">Defining Modules</a></h2>
<p>Modules in Ruby are used to namespace functionality and define mixins. Here's how to create and use modules in your Rust
extension:</p>
<h3 id="creating-a-basic-module"><a class="header" href="#creating-a-basic-module">Creating a Basic Module</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{define_module, prelude::*, Error, Ruby};

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    // Create a top-level module
    let module = ruby.define_module("MyExtension")?;

    // Define a method on the module
    module.define_singleton_method("version", function!(|| "1.0.0", 0))?;

    // Create a nested module
    let utils = module.define_module("Utils")?;
    utils.define_singleton_method("helper", function!(|| "Helper function", 0))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>This creates a module structure that would look like this in Ruby:</p>
<pre><code class="language-ruby">module MyExtension
  def self.version
    "1.0.0"
  end

  module Utils
    def self.helper
      "Helper function"
    end
  end
end
</code></pre>
<h3 id="module-constants"><a class="header" href="#module-constants">Module Constants</a></h3>
<p>You can define constants in your modules:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{define_module, Module, Ruby, Error, Value, Symbol};

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let module = ruby.define_module("Config")?;

    // Define constants
    module.const_set::&lt;_, _, Value&gt;(ruby, "VERSION", "1.0.0")?;
    module.const_set::&lt;_, _, Value&gt;(ruby, "MAX_CONNECTIONS", 100)?;
    module.const_set::&lt;_, _, Value&gt;(ruby, "DEFAULT_MODE", Symbol::new("production"))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-module-attributes"><a class="header" href="#using-module-attributes">Using Module Attributes</a></h3>
<p>To maintain module state, a common pattern is storing attributes in the module itself:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{define_module, function, prelude::*, Error, Module, Ruby};
use std::sync::Mutex;
use std::sync::atomic::{AtomicUsize, Ordering};

// Store a counter in a static atomic
static REQUEST_COUNT: AtomicUsize = AtomicUsize::new(0);

// Store configuration in a mutex
static CONFIG: Mutex&lt;Option&lt;String&gt;&gt; = Mutex::new(None);

fn increment_counter() -&gt; usize {
    REQUEST_COUNT.fetch_add(1, Ordering::SeqCst)
}

fn get_config() -&gt; Result&lt;String, Error&gt; {
    match CONFIG.lock().unwrap().clone() {
        Some(config) =&gt; Ok(config),
        None =&gt; Ok("default".to_string()),
    }
}

fn set_config(value: String) -&gt; Result&lt;String, Error&gt; {
    let mut config = CONFIG.lock().unwrap();
    *config = Some(value.clone());
    Ok(value)
}

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let module = ruby.define_module("Stats")?;

    module.define_singleton_method("increment", function!(increment_counter, 0))?;
    module.define_singleton_method("count", function!(|| REQUEST_COUNT.load(Ordering::SeqCst), 0))?;

    // Configuration methods
    module.define_singleton_method("config", function!(get_config, 0))?;
    module.define_singleton_method("config=", function!(set_config, 1))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="creating-ruby-classes-from-rust-structs"><a class="header" href="#creating-ruby-classes-from-rust-structs">Creating Ruby Classes from Rust Structs</a></h2>
<p>Magnus provides several ways to define Ruby classes that wrap Rust structures. The approach you choose depends on your
specific needs.</p>
<h3 id="using-the-typeddata-trait-full-control"><a class="header" href="#using-the-typeddata-trait-full-control">Using the TypedData Trait (Full Control)</a></h3>
<p>For full control over memory management and Ruby integration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{class, define_class, method, prelude::*, DataTypeFunctions, TypedData, Error, Ruby};

// Define a Rust struct
#[derive(Debug, TypedData)]
#[magnus(class = "MyExtension::Point", free_immediately, size)]
struct Point {
    x: f64,
    y: f64,
}

// Implement required trait
impl DataTypeFunctions for Point {}

// Implement methods
impl Point {
    fn new(x: f64, y: f64) -&gt; Self {
        Point { x, y }
    }

    fn x(&amp;self) -&gt; f64 {
        self.x
    }

    fn y(&amp;self) -&gt; f64 {
        self.y
    }

    fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
        ((self.x - other.x).powi(2) + (self.y - other.y).powi(2)).sqrt()
    }

    fn to_s(&amp;self) -&gt; String {
        format!("Point({}, {})", self.x, self.y)
    }
}

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let module = ruby.define_module("MyExtension")?;
    let class = module.define_class("Point", ruby.class_object())?;

    // Define the constructor
    class.define_singleton_method("new", function!(|x: f64, y: f64| {
        Point::new(x, y)
    }, 2))?;

    // Define instance methods
    class.define_method("x", method!(Point::x, 0))?;
    class.define_method("y", method!(Point::y, 0))?;
    class.define_method("distance", method!(Point::distance, 1))?;
    class.define_method("to_s", method!(Point::to_s, 0))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-the-wrap-macro-simplified-approach"><a class="header" href="#using-the-wrap-macro-simplified-approach">Using the Wrap Macro (Simplified Approach)</a></h3>
<p>For a simpler approach with less boilerplate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{define_class, function, method, prelude::*, Error, Ruby};

// Define a Rust struct
struct Rectangle {
    width: f64,
    height: f64,
}

// Use the wrap macro to handle the Ruby class mapping
#[magnus::wrap(class = "MyExtension::Rectangle")]
impl Rectangle {
    // Constructor
    fn new(width: f64, height: f64) -&gt; Self {
        Rectangle { width, height }
    }

    // Instance methods
    fn width(&amp;self) -&gt; f64 {
        self.width
    }

    fn height(&amp;self) -&gt; f64 {
        self.height
    }

    fn area(&amp;self) -&gt; f64 {
        self.width * self.height
    }

    fn perimeter(&amp;self) -&gt; f64 {
        2.0 * (self.width + self.height)
    }
}

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let module = ruby.define_module("MyExtension")?;
    let class = module.define_class("Rectangle", ruby.class_object())?;

    // Register class methods and instance methods
    class.define_singleton_method("new", function!(Rectangle::new, 2))?;
    class.define_method("width", method!(Rectangle::width, 0))?;
    class.define_method("height", method!(Rectangle::height, 0))?;
    class.define_method("area", method!(Rectangle::area, 0))?;
    class.define_method("perimeter", method!(Rectangle::perimeter, 0))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-refcell-for-mutable-rust-objects"><a class="header" href="#using-refcell-for-mutable-rust-objects">Using RefCell for Mutable Rust Objects</a></h3>
<p>For Ruby objects that need interior mutability:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;
use magnus::{define_class, function, method, prelude::*, Error, Ruby};

struct Counter {
    count: usize,
}

#[magnus::wrap(class = "MyExtension::Counter")]
struct MutCounter(RefCell&lt;Counter&gt;);

impl MutCounter {
    fn new(initial: usize) -&gt; Self {
        MutCounter(RefCell::new(Counter { count: initial }))
    }

    fn count(&amp;self) -&gt; usize {
        self.0.borrow().count
    }

    fn increment(&amp;self) -&gt; usize {
        let mut counter = self.0.borrow_mut();
        counter.count += 1;
        counter.count
    }

    fn increment_by(&amp;self, n: usize) -&gt; usize {
        let mut counter = self.0.borrow_mut();
        counter.count += n;
        counter.count
    }

    // AVOID this pattern which can cause BorrowMutError
    fn bad_increment_method(&amp;self) -&gt; Result&lt;usize, Error&gt; {
        // Don't do this - it keeps the borrowing active while trying to borrow_mut
        if self.0.borrow().count &gt; 10 {
            // This will panic with "already borrowed: BorrowMutError"
            self.0.borrow_mut().count += 100;
        } else {
            self.0.borrow_mut().count += 1;
        }

        Ok(self.0.borrow().count)
    }

    // CORRECT pattern - complete the first borrow before starting the second
    fn good_increment_method(&amp;self) -&gt; Result&lt;usize, Error&gt; {
        // Copy the value first
        let current_count = self.0.borrow().count;

        // Then the first borrow is dropped and we can borrow_mut safely
        if current_count &gt; 10 {
            self.0.borrow_mut().count += 100;
        } else {
            self.0.borrow_mut().count += 1;
        }

        Ok(self.0.borrow().count)
    }
}

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let module = ruby.define_module("MyExtension")?;
    let class = module.define_class("Counter", ruby.class_object())?;

    class.define_singleton_method("new", function!(MutCounter::new, 1))?;
    class.define_method("count", method!(MutCounter::count, 0))?;
    class.define_method("increment", method!(MutCounter::increment, 0))?;
    class.define_method("increment_by", method!(MutCounter::increment_by, 1))?;
    class.define_method("good_increment", method!(MutCounter::good_increment_method, 0))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="implementing-ruby-methods"><a class="header" href="#implementing-ruby-methods">Implementing Ruby Methods</a></h2>
<p>Magnus provides flexible macros to help define methods with various signatures.</p>
<h3 id="function-vs-method-macros"><a class="header" href="#function-vs-method-macros">Function vs Method Macros</a></h3>
<p>Magnus provides two primary macros for defining callable Ruby code:</p>
<ol>
<li><code>function!</code> - For singleton/class methods and module functions</li>
<li><code>method!</code> - For instance methods when you need access to the Rust object (<code>&amp;self</code>)</li>
</ol>
<p>Here's how to use each:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{function, method, define_class, prelude::*, Error, Ruby};

struct Calculator {}

#[magnus::wrap(class = "Calculator")]
impl Calculator {
    // Constructor - a class method
    fn new() -&gt; Self {
        Calculator {}
    }

    // Regular instance method that doesn't raise exceptions
    fn add(&amp;self, a: i64, b: i64) -&gt; i64 {
        a + b
    }

    // Method that needs the Ruby interpreter to raise an exception
    fn divide(ruby: &amp;Ruby, _rb_self: &amp;Self, a: i64, b: i64) -&gt; Result&lt;i64, Error&gt; {
        if b == 0 {
            return Err(Error::new(
                ruby.exception_zero_div_error(),
                "Division by zero"
            ));
        }
        Ok(a / b)
    }

    // Class method that doesn't need a Calculator instance
    fn version() -&gt; &amp;'static str {
        "1.0.0"
    }
}

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let class = ruby.define_class("Calculator", ruby.class_object())?;

    // Register the constructor with function!
    class.define_singleton_method("new", function!(Calculator::new, 0))?;

    // Register a class method with function!
    class.define_singleton_method("version", function!(Calculator::version, 0))?;

    // Register instance methods with method!
    class.define_method("add", method!(Calculator::add, 2))?;
    class.define_method("divide", method!(Calculator::divide, 2))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="method-signature-patterns"><a class="header" href="#method-signature-patterns">Method Signature Patterns</a></h3>
<p>There are several common method signature patterns depending on what your method needs to do:</p>
<h4 id="basic-method-no-ruby-access-no-exceptions"><a class="header" href="#basic-method-no-ruby-access-no-exceptions">Basic Method (no Ruby access, no exceptions)</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(&amp;self, a: i64, b: i64) -&gt; i64 {
    a + b
}
<span class="boring">}</span></code></pre></pre>
<h4 id="method-that-raises-exceptions"><a class="header" href="#method-that-raises-exceptions">Method that Raises Exceptions</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn divide(ruby: &amp;Ruby, _rb_self: &amp;Self, a: i64, b: i64) -&gt; Result&lt;i64, Error&gt; {
    if b == 0 {
        return Err(Error::new(
            ruby.exception_zero_div_error(),
            "Division by zero"
        ));
    }
    Ok(a / b)
}
<span class="boring">}</span></code></pre></pre>
<h4 id="method-that-needs-to-access-self-by-value"><a class="header" href="#method-that-needs-to-access-self-by-value">Method that Needs to Access Self by Value</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Usually for cloning or consuming self
fn clone_and_modify(rb_self: Value) -&gt; Result&lt;Value, Error&gt; {
    let ruby = unsafe { Ruby::get_unchecked() };
    let obj = ruby.class_object::&lt;Calculator&gt;()?.new_instance(())?;
    // Modify obj...
    Ok(obj)
}
<span class="boring">}</span></code></pre></pre>
<h4 id="method-with-ruby-block"><a class="header" href="#method-with-ruby-block">Method with Ruby Block</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn with_retries(ruby: &amp;Ruby, _rb_self: &amp;Self, max_retries: usize, block: Proc) -&gt; Result&lt;Value, Error&gt; {
    let mut retries = 0;
    loop {
        match block.call(ruby, ()) {
            Ok(result) =&gt; return Ok(result),
            Err(e) if retries &lt; max_retries =&gt; {
                retries += 1;
                // Maybe backoff or log error
            },
            Err(e) =&gt; return Err(e),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="class-inheritance-and-mixins"><a class="header" href="#class-inheritance-and-mixins">Class Inheritance and Mixins</a></h2>
<p>Ruby supports a rich object model with single inheritance and multiple module inclusion. Magnus allows you to replicate
this model in your Rust extension.</p>
<h3 id="creating-a-subclass"><a class="header" href="#creating-a-subclass">Creating a Subclass</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{Module, class, define_class, method, prelude::*, Error, Ruby};

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    // Get the parent class (Ruby's built-in Array)
    let array_class = ruby.class_object::&lt;RArray&gt;()?;

    // Create a subclass
    let sorted_array = ruby.define_class("SortedArray", array_class)?;

    // Override the &lt;&lt; (push) method to keep the array sorted
    sorted_array.define_method("&lt;&lt;", method!(|ruby, rb_self: Value, item: Value| {
        let array = RArray::from_value(rb_self)?;
        array.push(ruby, item)?;

        // Call sort! to keep the array sorted
        array.funcall(ruby, "sort!", ())?;

        Ok(rb_self) // Return self for method chaining
    }, 1))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="including-modules-mixins"><a class="header" href="#including-modules-mixins">Including Modules (Mixins)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{Module, class, define_class, define_module, method, prelude::*, Error, Ruby};

fn make_comparable(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let module = ruby.define_module("MyComparable")?;

    // Define methods for the module
    module.define_method("&lt;=&gt;", method!(|_ruby, rb_self: Value, other: Value| {
        // Implementation of the spaceship operator for comparison
        let self_num: Result&lt;i64, _&gt; = rb_self.try_convert();
        let other_num: Result&lt;i64, _&gt; = other.try_convert();

        match (self_num, other_num) {
            (Ok(a), Ok(b)) =&gt; Ok(a.cmp(&amp;b) as i8),
            _ =&gt; Ok(nil()),
        }
    }, 1))?;

    // Define methods that depend on &lt;=&gt;
    module.define_method("==", method!(|ruby, rb_self: Value, other: Value| {
        let result: i8 = rb_self.funcall(ruby, "&lt;=&gt;", (other,))?;
        Ok(result == 0)
    }, 1))?;

    module.define_method("&gt;", method!(|ruby, rb_self: Value, other: Value| {
        let result: i8 = rb_self.funcall(ruby, "&lt;=&gt;", (other,))?;
        Ok(result &gt; 0)
    }, 1))?;

    module.define_method("&lt;", method!(|ruby, rb_self: Value, other: Value| {
        let result: i8 = rb_self.funcall(ruby, "&lt;=&gt;", (other,))?;
        Ok(result &lt; 0)
    }, 1))?;

    Ok(())
}

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    // Create our module
    make_comparable(ruby)?;

    // Create a class
    let score = ruby.define_class("Score", ruby.class_object())?;

    // Define methods
    score.define_singleton_method("new", function!(|value: i64| {
        let obj = RObject::new(ruby.class_object::&lt;Score&gt;())?;
        obj.ivar_set(ruby, "@value", value)?;
        Ok(obj)
    }, 1))?;

    score.define_method("value", method!(|ruby, rb_self: Value| {
        rb_self.ivar_get::&lt;_, i64&gt;(ruby, "@value")
    }, 0))?;

    // Include our module
    let comparable = ruby.define_module("MyComparable")?;
    score.include_module(ruby, comparable)?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="working-with-singleton-methods"><a class="header" href="#working-with-singleton-methods">Working with Singleton Methods</a></h2>
<p>Singleton methods in Ruby are methods attached to individual objects, not to their class. The most common use is
defining class methods, but they can be applied to any object.</p>
<h3 id="defining-a-class-with-both-instance-and-singleton-methods"><a class="header" href="#defining-a-class-with-both-instance-and-singleton-methods">Defining a Class with Both Instance and Singleton Methods</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{class, define_class, function, method, prelude::*, Error, Ruby, Value};

#[magnus::wrap(class = "Logger")]
struct Logger {
    level: String,
}

impl Logger {
    fn new(level: String) -&gt; Self {
        Logger { level }
    }

    fn log(&amp;self, message: String) -&gt; String {
        format!("[{}] {}", self.level, message)
    }

    // Class methods (singleton methods)
    fn default_level() -&gt; &amp;'static str {
        "INFO"
    }

    fn create_default(ruby: &amp;Ruby) -&gt; Result&lt;Value, Error&gt; {
        let class = ruby.class_object::&lt;Logger&gt;()?;
        let default_level = Self::default_level();
        class.new_instance((default_level,))
    }
}

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let class = ruby.define_class("Logger", ruby.class_object())?;

    // Instance methods
    class.define_singleton_method("new", function!(Logger::new, 1))?;
    class.define_method("log", method!(Logger::log, 1))?;

    // Class methods using function! macro
    class.define_singleton_method("default_level", function!(Logger::default_level, 0))?;
    class.define_singleton_method("create_default", function!(Logger::create_default, 0))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="attaching-methods-to-a-specific-object-true-singleton-methods"><a class="header" href="#attaching-methods-to-a-specific-object-true-singleton-methods">Attaching Methods to a Specific Object (True Singleton Methods)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{module, function, prelude::*, Error, Ruby, Value};

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    // Create a single object
    let config = ruby.eval::&lt;Value&gt;("Object.new")?;

    // Define singleton methods directly on that object
    config.define_singleton_method(ruby, "get", function!(|| {
        "Configuration value"
    }, 0))?;

    config.define_singleton_method(ruby, "enabled?", function!(|| {
        true
    }, 0))?;

    // Make it globally accessible
    ruby.define_global_const("CONFIG", config)?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>This creates an object that can be used in Ruby like:</p>
<pre><code class="language-ruby">CONFIG.get          # =&gt; "Configuration value"
CONFIG.enabled?     # =&gt; true
CONFIG.class        # =&gt; Object
</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li>
<p><strong>Use magnus macros for class definition</strong>: The <code>wrap</code> and <code>TypedData</code> macros simplify class definition
significantly.</p>
</li>
<li>
<p><strong>Consistent naming</strong>: Keep Ruby and Rust naming conventions consistent within their domains (snake_case for Ruby
methods, CamelCase for Ruby classes).</p>
</li>
<li>
<p><strong>Layer your API</strong>: Consider providing both low-level and high-level APIs for complex functionality.</p>
</li>
<li>
<p><strong>Document method signatures</strong>: When using methods that can raise exceptions, document which exceptions can be
raised.</p>
</li>
<li>
<p><strong>RefCell borrowing pattern</strong>: Always release a <code>borrow()</code> before calling <code>borrow_mut()</code> by copying any needed
values.</p>
</li>
<li>
<p><strong>Method macro selection</strong>: Use <code>function!</code> for singleton methods and <code>method!</code> for instance methods.</p>
</li>
<li>
<p><strong>Include the Ruby parameter</strong>: Always include <code>ruby: &amp;Ruby</code> in your method signature if your method might raise
exceptions or interact with the Ruby runtime.</p>
</li>
<li>
<p><strong>Reuse existing Ruby patterns</strong>: When designing your API, follow existing Ruby conventions that users will already
understand.</p>
</li>
<li>
<p><strong>Cache Ruby classes and modules</strong>: Use <code>Lazy</code> to cache frequently accessed classes and modules.</p>
</li>
<li>
<p><strong>Maintain object hierarchy</strong>: Properly use Ruby's inheritance and module system to organize your code."</p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" style="margin-bottom: 0;" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="working-with-ruby-objects.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="error-handling.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                    
                    <div class="footer-note" style="margin: 3rem 0 0 0; padding: 2rem; font-size: 1.1rem; color: #555; border-top: 1px solid #ddd; display: flex; justify-content: center; align-items: center; font-family: inherit;">
                        <div style="max-width: 800px; text-align: center; line-height: 1.6;">
                            This documentation was created with assistance from an LLM.<br>
                            If you spot any issues, please <a href="https://github.com/oxidize-rb/rb-sys/issues" style="color: #3184a8; text-decoration: none; font-weight: bold;">submit a fix or report it</a>.<br>
                            We appreciate your help in improving these docs!
                        </div>
                    </div>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="working-with-ruby-objects.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="error-handling.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/js/custom.js"></script>


    </div>
    </body>
</html>
