<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Working with Ruby Objects - The Ruby on Rust Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A comprehensive guide to building Ruby extensions with Rust using rb-sys">
        <meta name="keywords" content="ruby, rust, ffi, bindings, rb-sys, ruby on rust">
        <meta name="author" content="">
        
        <!-- Open Graph / Facebook -->
        <meta property="og:type" content="website">
        <meta property="og:url" content="">
        <meta property="og:title" content="Working with Ruby Objects - The Ruby on Rust Book">
        <meta property="og:description" content="A comprehensive guide to building Ruby extensions with Rust using rb-sys">
        
        <!-- Twitter -->
        <meta property="twitter:card" content="summary_large_image">
        <meta property="twitter:url" content="">
        <meta property="twitter:title" content="Working with Ruby Objects - The Ruby on Rust Book">
        <meta property="twitter:description" content="A comprehensive guide to building Ruby extensions with Rust using rb-sys">
        
        <!-- Canonical URL -->
        <link rel="canonical" href="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Ruby on Rust Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/oxidize-rb/rb-sys" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="working-with-ruby-objects"><a class="header" href="#working-with-ruby-objects">Working with Ruby Objects</a></h1>
<h2 id="basic-type-conversions"><a class="header" href="#basic-type-conversions">Basic Type Conversions</a></h2>
<p>When writing Ruby extensions in Rust, one of the most common tasks is converting between Ruby and Rust types. The magnus
crate provides a comprehensive set of conversion functions for this purpose.</p>
<h3 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{RString, Ruby, Value, Integer, Float, Boolean};

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), magnus::Error&gt; {
    // Convert Rust types to Ruby
    let rb_string: RString = RString::new(ruby, "Hello, Ruby!");  // Rust &amp;str to Ruby String
    let rb_int: Integer = Integer::from_i64(42);                 // Rust i64 to Ruby Integer
    let rb_float: Float = Float::from_f64(3.14159);             // Rust f64 to Ruby Float
    let rb_bool: Boolean = Boolean::from(true);                 // Rust bool to Ruby true/false

    // Convert Ruby types to Rust
    let rust_string: String = rb_string.to_string()?;           // Ruby String to Rust String
    let rust_int: i64 = rb_int.to_i64()?;                       // Ruby Integer to Rust i64
    let rust_float: f64 = rb_float.to_f64()?;                   // Ruby Float to Rust f64
    let rust_bool: bool = rb_bool.to_bool();                    // Ruby true/false to Rust bool

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="checking-types"><a class="header" href="#checking-types">Checking Types</a></h3>
<p>When working with Ruby objects, you often need to check their types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{RString, Ruby, Value, check_type};

fn process_value(ruby: &amp;Ruby, val: Value) -&gt; Result&lt;(), magnus::Error&gt; {
    if val.is_nil() {
        println!("Got nil");
    } else if let Ok(s) = RString::try_convert(val) {
        println!("Got string: {}", s.to_string()?);
    } else if check_type::&lt;Integer&gt;(val) {
        println!("Got integer: {}", Integer::from_value(val)?.to_i64()?);
    } else {
        println!("Got some other type");
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="strings-arrays-and-hashes"><a class="header" href="#strings-arrays-and-hashes">Strings, Arrays, and Hashes</a></h2>
<h3 id="working-with-ruby-strings"><a class="header" href="#working-with-ruby-strings">Working with Ruby Strings</a></h3>
<p>Ruby strings are encoded and have more complex behavior than Rust strings:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{RString, Ruby, Encoding};

fn string_operations(ruby: &amp;Ruby) -&gt; Result&lt;(), magnus::Error&gt; {
    // Create a new Ruby string
    let hello = RString::new(ruby, "Hello");

    // Concatenate strings
    let world = RString::new(ruby, " World!");
    let message = hello.concat(ruby, world)?;

    // Get the encoding
    let encoding = message.encoding();
    println!("String encoding: {}", encoding.name());

    // Convert to different encoding
    let utf16 = Encoding::find("UTF-16BE").unwrap();
    let utf16_str = message.encode(ruby, utf16, None)?;

    // Get bytes
    let bytes = message.as_bytes();
    println!("Bytes: {:?}", bytes);

    // Create from bytes with specific encoding
    let latin1 = Encoding::find("ISO-8859-1").unwrap();
    let bytes = [72, 101, 108, 108, 111]; // "Hello" in ASCII/Latin1
    let latin1_str = RString::from_slice(ruby, &amp;bytes, Some(latin1));

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="working-with-ruby-arrays"><a class="header" href="#working-with-ruby-arrays">Working with Ruby Arrays</a></h3>
<p>Ruby arrays can hold any kind of Ruby object:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{RArray, Ruby, Value};

fn array_operations(ruby: &amp;Ruby) -&gt; Result&lt;(), magnus::Error&gt; {
    // Create a new empty array
    let array = RArray::new(ruby);

    // Push elements
    array.push(ruby, 1)?;
    array.push(ruby, "two")?;
    array.push(ruby, 3.0)?;

    // Get length
    let length = array.len();
    println!("Array length: {}", length);

    // Access elements
    let first: i64 = array.get(0)?;
    let second: String = array.get(1)?;
    let third: f64 = array.get(2)?;

    // Iterate through elements
    for i in 0..array.len() {
        let item: Value = array.get(i)?;
        println!("Item {}: {:?}", i, item);
    }

    // Another way to iterate
    array.each(|val| {
        println!("Item: {:?}", val);
        Ok(())
    })?;

    // Create an array from Rust Vec
    let numbers = vec![1, 2, 3, 4, 5];
    let rb_array = RArray::from_iter(ruby, numbers);

    // Convert to a Rust Vec
    let vec: Vec&lt;i64&gt; = rb_array.to_vec()?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="working-with-ruby-hashes"><a class="header" href="#working-with-ruby-hashes">Working with Ruby Hashes</a></h3>
<p>Ruby hashes are similar to Rust's HashMap but can use any Ruby object as keys:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{RHash, Value, Symbol, Ruby};

fn hash_operations(ruby: &amp;Ruby) -&gt; Result&lt;(), magnus::Error&gt; {
    // Create a new hash
    let hash = RHash::new(ruby);

    // Add key-value pairs
    hash.aset(ruby, "name", "Alice")?;
    hash.aset(ruby, Symbol::new("age"), 30)?;
    hash.aset(ruby, 1, "one")?;

    // Get values
    let name: String = hash.get(ruby, "name")?;
    let age: i64 = hash.get(ruby, Symbol::new("age"))?;
    let one: String = hash.get(ruby, 1)?;

    // Check if key exists
    if hash.has_key(ruby, "name")? {
        println!("Has key 'name'");
    }

    // Delete a key
    hash.delete(ruby, 1)?;

    // Iterate over key-value pairs
    hash.foreach(|k, v| {
        println!("Key: {:?}, Value: {:?}", k, v);
        Ok(())
    })?;

    // Convert to a Rust HashMap (if keys and values are convertible)
    let map: std::collections::HashMap&lt;String, String&gt; = hash.to_hash()?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="handling-nil-values"><a class="header" href="#handling-nil-values">Handling nil Values</a></h2>
<p>Ruby's <code>nil</code> is a special value that requires careful handling:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{Value, Ruby, RNil};

fn handle_nil(ruby: &amp;Ruby, val: Value) -&gt; Result&lt;(), magnus::Error&gt; {
    // Check if a value is nil
    if val.is_nil() {
        println!("Value is nil");
    }

    // Get nil
    let nil = ruby.nil();

    // Options and nil
    let maybe_string: Option&lt;String&gt; = val.try_convert()?;
    match maybe_string {
        Some(s) =&gt; println!("Got string: {}", s),
        None =&gt; println!("No string (was nil or couldn't convert)"),
    }

    // Explicitly return nil from a function
    fn returns_nil() -&gt; RNil {
        RNil::get()
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="converting-between-ruby-and-rust-types"><a class="header" href="#converting-between-ruby-and-rust-types">Converting Between Ruby and Rust Types</a></h2>
<p>Magnus provides powerful type conversion traits that make it easy to convert between Ruby and Rust types.</p>
<h3 id="from-rust-to-ruby-tryconvert"><a class="header" href="#from-rust-to-ruby-tryconvert">From Rust to Ruby (TryConvert)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{Value, Ruby, TryConvert, Error};

// Convert custom Rust types to Ruby objects
struct Person {
    name: String,
    age: u32,
}

impl TryConvert for Person {
    fn try_convert(val: Value) -&gt; Result&lt;Self, Error&gt; {
        let ruby = unsafe { Ruby::get_unchecked() };
        let hash = RHash::try_convert(val)?;

        let name: String = hash.get(ruby, "name")?;
        let age: u32 = hash.get(ruby, "age")?;

        Ok(Person { name, age })
    }
}

// Usage
fn process_person(val: Value) -&gt; Result&lt;(), Error&gt; {
    let person: Person = val.try_convert()?;
    println!("Person: {} ({})", person.name, person.age);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="from-ruby-to-rust-intovalue"><a class="header" href="#from-ruby-to-rust-intovalue">From Ruby to Rust (IntoValue)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{Value, Ruby, IntoValue, Error};

struct Point {
    x: f64,
    y: f64,
}

impl IntoValue for Point {
    fn into_value_with(self, ruby: &amp;Ruby) -&gt; Result&lt;Value, Error&gt; {
        let hash = RHash::new(ruby);
        hash.aset(ruby, "x", self.x)?;
        hash.aset(ruby, "y", self.y)?;
        Ok(hash.as_value())
    }
}

// Usage
fn create_point(ruby: &amp;Ruby) -&gt; Result&lt;Value, Error&gt; {
    let point = Point { x: 10.5, y: 20.7 };
    point.into_value_with(ruby)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="creating-ruby-objects-from-rust"><a class="header" href="#creating-ruby-objects-from-rust">Creating Ruby Objects from Rust</a></h2>
<h3 id="creating-simple-objects"><a class="header" href="#creating-simple-objects">Creating Simple Objects</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{RObject, Ruby, Value, class, method};

fn create_objects(ruby: &amp;Ruby) -&gt; Result&lt;(), magnus::Error&gt; {
    // Create a basic Ruby Object
    let obj = RObject::new(ruby, ruby.class_object())?;

    // Instantiate a specific class
    let time_class = ruby.class_object::&lt;Time&gt;()?;
    let now = time_class.funcall(ruby, "now", ())?;

    // Create a Date object
    let date_class = class::object("Date")?;
    let today = date_class.funcall(ruby, "today", ())?;

    // Call methods on the object
    let formatted: String = today.funcall(ruby, "strftime", ("%Y-%m-%d",))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="creating-objects-with-instance-variables"><a class="header" href="#creating-objects-with-instance-variables">Creating Objects with Instance Variables</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{RObject, Ruby, Symbol};

fn create_with_ivars(ruby: &amp;Ruby) -&gt; Result&lt;(), magnus::Error&gt; {
    // Create a Ruby object
    let obj = RObject::new(ruby, ruby.class_object())?;

    // Set instance variables
    obj.ivar_set(ruby, "@name", "Alice")?;
    obj.ivar_set(ruby, "@age", 30)?;

    // Get instance variables
    let name: String = obj.ivar_get(ruby, "@name")?;
    let age: i64 = obj.ivar_get(ruby, "@age")?;

    // Alternatively, use symbols
    let name_sym = Symbol::new("@name");
    let name_value = obj.ivar_get(ruby, name_sym)?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="working-with-ruby-methods"><a class="header" href="#working-with-ruby-methods">Working with Ruby Methods</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{RObject, Ruby, prelude::*};

fn call_methods(ruby: &amp;Ruby) -&gt; Result&lt;(), magnus::Error&gt; {
    let array_class = ruby.class_object::&lt;RArray&gt;()?;

    // Creating an array with methods
    let array = array_class.funcall(ruby, "new", (5, "hello"))?;

    // Call methods with different argument patterns
    array.funcall(ruby, "&lt;&lt;", ("world",))?; // One argument
    array.funcall(ruby, "insert", (1, "inserted"))?; // Multiple arguments

    // Call with a block using a closure
    let mapped = array.funcall_with_block(ruby, "map", (), |arg| {
        if let Ok(s) = String::try_convert(arg) {
            Ok(s.len())
        } else {
            Ok(0)
        }
    })?;

    // Methods with keyword arguments
    let hash_class = ruby.class_object::&lt;RHash&gt;()?;
    let merge_opts = [(
        Symbol::new("overwrite"),
        true
    )];
    let hash = RHash::new(ruby);
    let other = RHash::new(ruby);
    hash.funcall_kw(ruby, "merge", (other,), merge_opts)?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-techniques"><a class="header" href="#advanced-techniques">Advanced Techniques</a></h2>
<h3 id="handling-arbitrary-ruby-values"><a class="header" href="#handling-arbitrary-ruby-values">Handling Arbitrary Ruby Values</a></h3>
<p>Sometimes you need to work with Ruby values without knowing their type in advance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{Value, Ruby, CheckType, Error};

fn describe_value(val: Value) -&gt; Result&lt;String, Error&gt; {
    let ruby = unsafe { Ruby::get_unchecked() };

    if val.is_nil() {
        return Ok("nil".to_string());
    }

    if let Ok(s) = String::try_convert(val) {
        return Ok(format!("String: {}", s));
    }

    if let Ok(i) = i64::try_convert(val) {
        return Ok(format!("Integer: {}", i));
    }

    if let Ok(f) = f64::try_convert(val) {
        return Ok(format!("Float: {}", f));
    }

    if val.respond_to(ruby, "each")? {
        return Ok("Enumerable object".to_string());
    }

    // Get the class name
    let class_name: String = val.class().name();
    Ok(format!("Object of class: {}", class_name))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="working-with-duck-types"><a class="header" href="#working-with-duck-types">Working with Duck Types</a></h3>
<p>Ruby often uses duck typing rather than relying on concrete classes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{Error, Value, Ruby};

fn process_enumerable(ruby: &amp;Ruby, val: Value) -&gt; Result&lt;Value, Error&gt; {
    // Check if the object responds to 'each'
    if !val.respond_to(ruby, "each")? {
        return Err(Error::new(
            ruby.exception_type_error(),
            "Expected an object that responds to 'each'"
        ));
    }

    // We can now safely call 'map' which most enumerables support
    val.funcall_with_block(ruby, "map", (), |item| {
        if let Ok(n) = i64::try_convert(item) {
            Ok(n * 2)
        } else {
            Ok(item)  // Pass through unchanged if not a number
        }
    })
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li>
<p><strong>Always Handle Errors</strong>: Type conversions can fail, wrap them in proper error handling.</p>
</li>
<li>
<p><strong>Use try_convert</strong>: Prefer <code>try_convert</code> over direct conversions to safely handle type mismatches.</p>
</li>
<li>
<p><strong>Remember Boxing Rules</strong>: All Ruby objects are reference types, while many Rust types are value types.</p>
</li>
<li>
<p><strong>Be Careful with Magic Methods</strong>: Some Ruby methods like <code>method_missing</code> might not behave as expected when called
from Rust.</p>
</li>
<li>
<p><strong>Cache Ruby Objects</strong>: If you're repeatedly using the same Ruby objects (like classes or symbols), consider caching
them using <code>Lazy</code> or similar mechanisms.</p>
</li>
<li>
<p><strong>Check for nil</strong>: Always check for nil values before attempting conversions that don't handle nil.</p>
</li>
<li>
<p><strong>Use Type Annotations</strong>: Explicitly specifying types when converting Ruby values to Rust can make your code clearer
and avoid potential runtime errors.</p>
</li>
<li>
<p><strong>Pass Ruby State</strong>: Always pass the <code>Ruby</code> instance through your functions when needed rather than using
<code>Ruby::get()</code> repeatedly, as this is more performant and clearer about dependencies.</p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" style="margin-bottom: 0;" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="development-approaches.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="classes-and-modules.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                    
                    <div class="footer-note" style="margin: 3rem 0 0 0; padding: 2rem; font-size: 1.1rem; color: #555; border-top: 1px solid #ddd; display: flex; justify-content: center; align-items: center; font-family: inherit;">
                        <div style="max-width: 800px; text-align: center; line-height: 1.6;">
                            This documentation was created with assistance from an LLM.<br>
                            If you spot any issues, please <a href="https://github.com/oxidize-rb/rb-sys/issues" style="color: #3184a8; text-decoration: none; font-weight: bold;">submit a fix or report it</a>.<br>
                            We appreciate your help in improving these docs!
                        </div>
                    </div>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="development-approaches.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="classes-and-modules.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/js/custom.js"></script>


    </div>
    </body>
</html>
