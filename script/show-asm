#!/usr/bin/env ruby
# frozen_string_literal: true

#
# Show assembly output for stable_api methods
#
# This script generates Rust code on-demand and compiles it directly with rustc,
# extracting the assembly for the specified function(s).
#
# Usage:
#   ./script/show-asm symbol_p
#   ./script/show-asm --list
#   ./script/show-asm --all
#   ./script/show-asm --count --all
#

require "pathname"
require "optparse"
require "fileutils"
require "tempfile"
require "open3"

REPO_ROOT = Pathname.new(__dir__).parent

# Function definitions with co-located Rust and C implementations
#
# Each entry contains:
#   - name: Function name (used for test function naming)
#   - rust: Rust implementation details
#     - unsafe: Whether the Rust function is unsafe
#     - ret: Return type
#     - expr: Rust expression (uses rb_sys macros)
#     - custom_body: Optional full function body for complex cases
#   - c: C implementation details (nil if no C equivalent)
#     - expr: C expression
#     - ret: C return type
#   - ruby_source: Reference to canonical Ruby source location
#
FUNCTIONS = [
  # Safe predicates (no pointer dereference)
  {
    name: "nil_p",
    rust: {unsafe: false, ret: "bool", expr: "rb_sys::NIL_P(v)"},
    c: {expr: "NIL_P(v)", ret: "int"},
    ruby_source: "include/ruby/internal/special_consts.h:RB_NIL_P"
  },
  {
    name: "fixnum_p",
    rust: {unsafe: false, ret: "bool", expr: "rb_sys::FIXNUM_P(v)"},
    c: {expr: "FIXNUM_P(v)", ret: "int"},
    ruby_source: "include/ruby/internal/special_consts.h:RB_FIXNUM_P"
  },
  {
    name: "static_sym_p",
    rust: {unsafe: false, ret: "bool", expr: "rb_sys::STATIC_SYM_P(v)"},
    c: {expr: "STATIC_SYM_P(v)", ret: "int"},
    ruby_source: "include/ruby/internal/special_consts.h:RB_STATIC_SYM_P"
  },
  {
    name: "flonum_p",
    rust: {unsafe: false, ret: "bool", expr: "rb_sys::FLONUM_P(v)"},
    c: {expr: "RB_FLONUM_P(v)", ret: "int"},
    ruby_source: "include/ruby/internal/special_consts.h:RB_FLONUM_P"
  },
  {
    name: "immediate_p",
    rust: {unsafe: false, ret: "bool", expr: "rb_sys::IMMEDIATE_P(v)"},
    c: {expr: "RB_IMMEDIATE_P(v)", ret: "int"},
    ruby_source: "include/ruby/internal/special_consts.h:RB_IMMEDIATE_P"
  },
  {
    name: "special_const_p",
    rust: {unsafe: false, ret: "bool", expr: "rb_sys::SPECIAL_CONST_P(v)"},
    c: {expr: "RB_SPECIAL_CONST_P(v)", ret: "int"},
    ruby_source: "include/ruby/internal/special_consts.h:RB_SPECIAL_CONST_P"
  },
  {
    name: "rb_test",
    rust: {unsafe: false, ret: "bool", expr: "rb_sys::TEST(v)"},
    c: {expr: "RB_TEST(v)", ret: "int"},
    ruby_source: "include/ruby/internal/special_consts.h:RB_TEST"
  },

  # Unsafe predicates (may dereference pointer)
  {
    name: "symbol_p",
    rust: {unsafe: true, ret: "bool", expr: "rb_sys::RB_SYMBOL_P(v)"},
    c: {expr: "RB_SYMBOL_P(v)", ret: "int"},
    ruby_source: "include/ruby/internal/value_type.h:RB_SYMBOL_P"
  },
  {
    name: "dynamic_sym_p",
    rust: {unsafe: true, ret: "bool", expr: "rb_sys::RB_DYNAMIC_SYM_P(v)"},
    c: {expr: "RB_DYNAMIC_SYM_P(v)", ret: "int"},
    ruby_source: "include/ruby/internal/value_type.h:RB_DYNAMIC_SYM_P"
  },
  {
    name: "float_type_p",
    rust: {unsafe: true, ret: "bool", expr: "rb_sys::RB_FLOAT_TYPE_P(v)"},
    c: {expr: "RB_FLOAT_TYPE_P(v)", ret: "int"},
    ruby_source: "include/ruby/internal/value_type.h:RB_FLOAT_TYPE_P"
  },
  {
    name: "integer_type_p",
    rust: {unsafe: true, ret: "bool", expr: "rb_sys::RB_INTEGER_TYPE_P(v)"},
    c: {expr: "RB_INTEGER_TYPE_P(v)", ret: "int"},
    ruby_source: "include/ruby/internal/value_type.h:rb_integer_type_p"
  },

  # type_p for heap types (all generate same asm except for type constant)
  {
    name: "type_p_heap",
    rust: {unsafe: true, ret: "bool", expr: "rb_sys::RB_TYPE_P(v, rb_sys::ruby_value_type::RUBY_T_STRING)"},
    c: {expr: "RB_TYPE_P(v, T_STRING)", ret: "int"},
    ruby_source: "include/ruby/internal/value_type.h:RB_TYPE_P"
  },

  # Type inspection
  {
    name: "builtin_type",
    rust: {unsafe: true, ret: "rb_sys::ruby_value_type", expr: "rb_sys::RB_BUILTIN_TYPE(v)"},
    c: {expr: "RB_BUILTIN_TYPE(v)", ret: "int"},
    ruby_source: "include/ruby/internal/value_type.h:RB_BUILTIN_TYPE"
  },
  {
    name: "rb_type",
    rust: {unsafe: true, ret: "rb_sys::ruby_value_type", expr: "rb_sys::RB_TYPE(v)"},
    c: {expr: "rb_type(v)", ret: "int"},
    ruby_source: "include/ruby/internal/value_type.h:rb_type"
  },

  # String operations
  {
    name: "rstring_len",
    rust: {unsafe: true, ret: "c_long", expr: "rb_sys::RSTRING_LEN(v)"},
    c: {expr: "RSTRING_LEN(v)", ret: "long"},
    ruby_source: "include/ruby/internal/core/rstring.h:RSTRING_LEN"
  },
  {
    name: "rstring_ptr",
    rust: {unsafe: true, ret: "*const c_char", expr: "rb_sys::RSTRING_PTR(v)"},
    c: {expr: "RSTRING_PTR(v)", ret: "const char *"},
    ruby_source: "include/ruby/internal/core/rstring.h:RSTRING_PTR"
  },
  {
    name: "rstring_interned_p",
    rust: {unsafe: true, ret: "bool", expr: "{ let api = rb_sys::stable_api::get_default(); api.rstring_interned_p(v) }"},
    c: {expr: "(RBASIC(v)->flags & RSTRING_FSTR) != 0", ret: "int"},
    ruby_source: "include/ruby/internal/core/rstring.h:RSTRING_FSTR"
  },

  # Array operations
  {
    name: "rarray_len",
    rust: {unsafe: true, ret: "c_long", expr: "rb_sys::RARRAY_LEN(v)"},
    c: {expr: "RARRAY_LEN(v)", ret: "long"},
    ruby_source: "include/ruby/internal/core/rarray.h:RARRAY_LEN"
  },
  {
    name: "rarray_const_ptr",
    rust: {unsafe: true, ret: "*const VALUE", expr: "rb_sys::RARRAY_CONST_PTR(v)"},
    c: {expr: "RARRAY_CONST_PTR(v)", ret: "const VALUE *"},
    ruby_source: "include/ruby/internal/core/rarray.h:RARRAY_CONST_PTR"
  },
  {
    name: "rarray_aref",
    rust: {unsafe: true, ret: "VALUE", expr: "rb_sys::RARRAY_AREF(v, 0)"},
    c: {expr: "RARRAY_AREF(v, 0)", ret: "VALUE"},
    ruby_source: "include/ruby/internal/core/rarray.h:RARRAY_AREF"
  },
  {
    name: "rarray_aset",
    rust: {
      unsafe: true,
      ret: "VALUE",
      custom_body: <<~RUST
        // Set element at index 0 to Qnil
        rb_sys::RARRAY_ASET(v, 0, rb_sys::Qnil as VALUE);
        // Return the array for consistency
        v
      RUST
    },
    c: {
      custom_body: <<~C,
        // Set element at index 0 to Qnil
        RARRAY_ASET(v, 0, Qnil);
        // Return the array for consistency
        return v;
      C
      ret: "VALUE"
    },
    ruby_source: "include/ruby/internal/core/rarray.h:RARRAY_ASET"
  },

  # Object operations
  {
    name: "rbasic_class",
    rust: {unsafe: true, ret: "VALUE", expr: "{ let api = rb_sys::stable_api::get_default(); api.rbasic_class(v).map(|p| p.as_ptr() as VALUE).unwrap_or(0 as VALUE) }"},
    c: {expr: "RBASIC_CLASS(v)", ret: "VALUE"},
    ruby_source: "include/ruby/internal/core/rbasic.h:RBASIC_CLASS"
  },
  {
    name: "frozen_p",
    rust: {unsafe: true, ret: "bool", expr: "{ let api = rb_sys::stable_api::get_default(); api.frozen_p(v) }"},
    c: {expr: "RB_OBJ_FROZEN(v)", ret: "int"},
    ruby_source: "include/ruby/internal/fl_type.h:RB_OBJ_FROZEN"
  },

  # Bignum operations
  {
    name: "bignum_positive_p",
    rust: {unsafe: true, ret: "bool", expr: "rb_sys::RBIGNUM_POSITIVE_P(v)"},
    c: {expr: "RBIGNUM_POSITIVE_P(v)", ret: "int"},
    ruby_source: "include/ruby/internal/core/rbignum.h:RBIGNUM_POSITIVE_P"
  },
  {
    name: "bignum_negative_p",
    rust: {unsafe: true, ret: "bool", expr: "rb_sys::RBIGNUM_NEGATIVE_P(v)"},
    c: {expr: "RBIGNUM_NEGATIVE_P(v)", ret: "int"},
    ruby_source: "include/ruby/internal/core/rbignum.h:RBIGNUM_NEGATIVE_P"
  },

  # Typed data operations
  {
    name: "rtypeddata_p",
    rust: {unsafe: true, ret: "bool", expr: "rb_sys::RTYPEDDATA_P(v)"},
    c: {expr: "RTYPEDDATA_P(v)", ret: "int"},
    ruby_source: "include/ruby/internal/core/rtypeddata.h:RTYPEDDATA_P"
  },
  {
    name: "rtypeddata_embedded_p",
    rust: {unsafe: true, ret: "bool", expr: "rb_sys::RTYPEDDATA_EMBEDDED_P(v)"},
    c: {expr: "RTYPEDDATA_EMBEDDED_P(v)", ret: "int"},
    ruby_source: "include/ruby/internal/core/rtypeddata.h:RTYPEDDATA_EMBEDDED_P"
  },
  {
    name: "rtypeddata_type",
    rust: {unsafe: true, ret: "*const rb_sys::rb_data_type_t", expr: "rb_sys::RTYPEDDATA_TYPE(v)"},
    c: {expr: "RTYPEDDATA_TYPE(v)", ret: "const rb_data_type_t *"},
    ruby_source: "include/ruby/internal/core/rtypeddata.h:RTYPEDDATA_TYPE"
  },
  {
    name: "rtypeddata_get_data",
    rust: {unsafe: true, ret: "*mut c_void", expr: "rb_sys::RTYPEDDATA_GET_DATA(v)"},
    c: {expr: "RTYPEDDATA_GET_DATA(v)", ret: "void *"},
    ruby_source: "include/ruby/internal/core/rtypeddata.h:RTYPEDDATA_GET_DATA"
  },

  # GC guard (macro, not StableApiDefinition method)
  # Uses a realistic pattern: extract pointer, call function that might GC, use guard
  {
    name: "rb_gc_guard",
    rust: {
      unsafe: true,
      ret: "VALUE",
      custom_body: <<~RUST
        // Extract raw pointer from Ruby string
        let ptr = rb_sys::RSTRING_PTR(v);

        // rb_str_new_cstr allocates memory and might trigger GC.
        // Without rb_gc_guard!, the compiler sees 'v' as dead after rstring_ptr,
        // so it might not keep it on the stack. If GC runs during this call,
        // 'v' could be collected and 'ptr' would become a dangling pointer.
        let new_str = rb_sys::rb_str_new_cstr(ptr);

        // Guard keeps 'v' alive on the stack until this point
        rb_sys::rb_gc_guard!(v);

        // Return new_str to prevent it from being optimized away
        new_str
      RUST
    },
    c: {
      custom_body: <<~C,
        // Extract raw pointer from Ruby string
        const char *ptr = RSTRING_PTR(str);

        // rb_str_new_cstr allocates memory and might trigger GC.
        // Without RB_GC_GUARD, the compiler sees 'str' as dead after
        // RSTRING_PTR, so it might not keep it on the stack. If GC runs
        // during this call, 'str' could be collected and 'ptr' would
        // become a dangling pointer.
        VALUE new_str = rb_str_new_cstr(ptr);

        // Guard keeps 'str' alive on the stack until this point
        RB_GC_GUARD(str);

        // Return new_str to prevent it from being optimized away
        return new_str;
      C
      ret: "VALUE",
      arg_name: "str"
    },
    ruby_source: "include/ruby/internal/memory.h:RB_GC_GUARD"
  }
].freeze

# Build a hash for quick lookup by name
FUNCTIONS_BY_NAME = FUNCTIONS.each_with_object({}) { |f, h| h[f[:name]] = f }.freeze

# ARM64 instruction patterns to count
INSTRUCTION_PATTERN = /^\s+(mov|ldr|str|add|sub|cmp|tst|and|orr|eor|b\.|bl|ret|cbz|cbnz|cset|ccmp|csinc|adrp|stp|ldp|ror|lsr|tbz|csel)/

class ShowAsm
  def initialize(repo_root)
    @repo_root = repo_root
    @target_dir = repo_root.join("target/release")
    @deps_dir = @target_dir.join("deps")
  end

  def ensure_rb_sys_built
    warn "Building rb-sys (release)..."
    Dir.chdir(@repo_root) do
      system("./script/run", "cargo", "build", "-p", "rb-sys", "--release",
        out: $stderr, err: $stderr) or abort "ERROR: Failed to build rb-sys"
    end
  end

  def cfg_flags
    @cfg_flags ||= begin
      output_files = Dir.glob(@repo_root.join("target/release/build/rb-sys-*/output"))
      abort "ERROR: No rb-sys build output found. Run: cargo build -p rb-sys --release" if output_files.empty?

      flags = []
      output_files.each do |file|
        File.foreach(file) do |line|
          if line.start_with?("cargo:rustc-cfg=")
            cfg = line.sub("cargo:rustc-cfg=", "").strip
            flags << cfg unless cfg.empty?
          end
        end
      end
      flags.uniq
    end
  end

  def generate_rust_code(func_name, rust_def)
    unsafe_kw = rust_def[:unsafe] ? "unsafe " : ""

    # Support custom_body for complex test patterns (like rb_gc_guard)
    body = if rust_def[:custom_body]
      rust_def[:custom_body]
    elsif rust_def[:expr]
      rust_def[:unsafe] ? rust_def[:expr] : "unsafe { #{rust_def[:expr]} }"
    else
      raise "Function #{func_name} needs either :expr or :custom_body"
    end

    # For custom_body, we need to handle the return type declaration
    ret_type = rust_def[:ret] || "VALUE"

    <<~RUST
      #![allow(unused_unsafe)]
      extern crate rb_sys;

      use rb_sys::{stable_api, StableApiDefinition, VALUE};
      use std::ffi::c_void;
      use std::os::raw::{c_char, c_long};
      use std::ptr::NonNull;

      #[inline(never)]
      #[no_mangle]
      pub #{unsafe_kw}fn test_#{func_name}(v: VALUE) -> #{ret_type} {
          #{body}
      }
    RUST
  end

  def generate_c_code(func_name, c_def)
    return nil unless c_def

    func_name_c = "test_#{func_name}_c"
    ret_type = c_def[:ret] || "int"
    arg_name = c_def[:arg_name] || "v"

    if c_def[:custom_body]
      <<~C
        #include <ruby.h>

        __attribute__((noinline))
        #{ret_type} #{func_name_c}(VALUE #{arg_name}) {
            #{c_def[:custom_body]}
        }
      C
    else
      <<~C
        #include <ruby.h>

        __attribute__((noinline))
        #{ret_type} #{func_name_c}(VALUE #{arg_name}) {
            return #{c_def[:expr]};
        }
      C
    end
  end

  def compile_to_asm(rust_code)
    Tempfile.create(["show_asm", ".rs"]) do |src_file|
      src_file.write(rust_code)
      src_file.flush

      Tempfile.create(["show_asm", ".s"]) do |asm_file|
        cmd = ["rustc", src_file.path,
          "--crate-type=lib",
          "--emit=asm",
          "-C", "opt-level=3",
          "-C", "lto=fat",
          "-C", "codegen-units=1",
          "--extern=rb_sys=#{@target_dir.join("librb_sys.rlib")}",
          "-L=dependency=#{@deps_dir}",
          "-o", asm_file.path]

        cfg_flags.each { |cfg| cmd << "--cfg" << cfg }

        _, stderr, status = Open3.capture3(*cmd)
        unless status.success?
          abort "ERROR: rustc failed:\n#{stderr}"
        end

        File.read(asm_file.path)
      end
    end
  end

  def extract_function(asm, func_name)
    lines = []
    found = false

    asm.each_line do |line|
      if line.match?(/^_test_#{Regexp.escape(func_name)}:/)
        found = true
        lines << line
        next
      end

      if found
        lines << line
        break if line.include?(".cfi_endproc")
        break if lines.size > 1 && line.match?(/^_[a-zA-Z]/)
      end
    end

    found ? lines.join : nil
  end

  def count_instructions(asm)
    asm.lines.count { |line| line.match?(INSTRUCTION_PATTERN) }
  end

  def display_result(func_name, func_asm, instr_count, c_result, count_only:)
    if count_only
      # Handled by show_all for tabular output
      return
    end

    puts "=" * 80
    puts "Function: test_#{func_name} (Rust)"
    puts "Instructions: #{instr_count}"
    puts "=" * 80
    puts
    puts func_asm
    puts

    if c_result
      puts "=" * 80
      puts "Function: #{c_result[:func_name]} (C)"
      puts "Instructions: #{c_result[:instr_count]}"
      puts "=" * 80
      puts
      puts c_result[:asm]
      puts
    end
  end

  def display_count_row(func_name, rust_count, c_count)
    if c_count
      diff = rust_count - c_count
      pct = ((diff.to_f / c_count) * 100).round(0)
      sign = (diff >= 0) ? "+" : ""
      printf "%-25s %8d %8d %8s\n", func_name, rust_count, c_count, "#{sign}#{pct}%"
    else
      printf "%-25s %8d %8s %8s\n", func_name, rust_count, "-", "-"
    end
  end

  def compile_and_extract(func_entry)
    func_name = func_entry[:name]
    rust_def = func_entry[:rust]
    c_def = func_entry[:c]

    rust_code = generate_rust_code(func_name, rust_def)
    full_asm = compile_to_asm(rust_code)
    func_asm = extract_function(full_asm, func_name)

    return nil unless func_asm

    instr_count = count_instructions(func_asm)
    c_result = show_c_comparison(func_name, c_def)

    {func_asm: func_asm, instr_count: instr_count, c_result: c_result}
  end

  def show_all(count_only: false)
    ensure_rb_sys_built

    if count_only
      printf "%-25s %8s %8s %8s\n", "Function", "Rust", "C", "Diff"
      puts "-" * 53
    end

    FUNCTIONS.sort_by { |f| f[:name] }.each do |func_entry|
      func_name = func_entry[:name]
      result = compile_and_extract(func_entry)

      unless result
        warn "WARN: Function 'test_#{func_name}' not found in assembly"
        next
      end

      if count_only
        c_count = result[:c_result] ? result[:c_result][:instr_count] : nil
        display_count_row(func_name, result[:instr_count], c_count)
      else
        display_result(func_name, result[:func_asm], result[:instr_count], result[:c_result], count_only: false)
      end
    end
  end

  def list_functions
    puts "Available functions:"
    puts
    printf "%-25s %-8s %-12s %s\n", "Name", "Safety", "C Equivalent", "Return Type"
    puts "-" * 80
    FUNCTIONS.sort_by { |f| f[:name] }.each do |func_entry|
      name = func_entry[:name]
      rust_def = func_entry[:rust]
      safety = rust_def[:unsafe] ? "unsafe" : "safe"
      has_c = func_entry[:c] ? "yes" : "-"
      printf "%-25s %-8s %-12s %s\n", name, safety, has_c, rust_def[:ret]
    end
  end

  def ruby_config
    @ruby_config ||= begin
      require "rbconfig"
      RbConfig::CONFIG
    end
  end

  def compile_c_to_asm(c_code)
    Tempfile.create(["show_asm", ".c"]) do |src_file|
      src_file.write(c_code)
      src_file.flush

      Tempfile.create(["show_asm", ".s"]) do |asm_file|
        cc = ruby_config["CC"]
        hdrdir = ruby_config["rubyhdrdir"]
        archhdrdir = ruby_config["rubyarchhdrdir"]

        cmd = [cc, src_file.path,
          "-S",                     # Output assembly
          "-O3",                    # Optimize
          "-fno-stack-protector",   # Disable stack canary for fair comparison
          "-I#{hdrdir}",
          "-I#{archhdrdir}",
          "-o", asm_file.path]

        _, stderr, status = Open3.capture3(*cmd)
        unless status.success?
          abort "ERROR: C compiler failed:\n#{stderr}"
        end

        File.read(asm_file.path)
      end
    end
  end

  def extract_c_function(asm, func_name)
    lines = []
    found = false

    asm.each_line do |line|
      # Match function label (with or without leading underscore)
      if line.match?(/^_?#{Regexp.escape(func_name)}:/)
        found = true
        lines << line
        next
      end

      if found
        lines << line
        break if line.include?(".cfi_endproc")
        # Stop at next function label, but ignore local labels:
        # - Lloh* (linker optimization hints)
        # - LBB* (basic block labels)
        # - Ltmp* (temporary labels)
        # Local labels start with 'L' (clang) or '.L' (gcc)
        next if line.match?(/^\.?L[A-Za-z]/)
        break if lines.size > 1 && line.match?(/^_?[a-zA-Z][a-zA-Z0-9_]*:/)
      end
    end

    found ? lines.join : nil
  end

  def show_c_comparison(func_name, c_def)
    return nil unless c_def

    c_code = generate_c_code(func_name, c_def)
    return nil unless c_code

    func_name_c = "test_#{func_name}_c"
    full_asm = compile_c_to_asm(c_code)
    func_asm = extract_c_function(full_asm, func_name_c)

    unless func_asm
      warn "WARN: C function '#{func_name_c}' not found in assembly"
      return nil
    end

    instr_count = count_instructions(func_asm)

    {asm: func_asm, instr_count: instr_count, func_name: func_name_c}
  end

  def show_function(func_name, count_only: false)
    func_entry = FUNCTIONS_BY_NAME[func_name]
    abort "ERROR: Unknown function '#{func_name}'. Use --list to see available functions." unless func_entry

    ensure_rb_sys_built

    result = compile_and_extract(func_entry)

    unless result
      abort "ERROR: Function 'test_#{func_name}' not found in assembly output"
    end

    if count_only
      printf "%-25s %8s %8s %8s\n", "Function", "Rust", "C", "Diff"
      puts "-" * 53
      c_count = result[:c_result] ? result[:c_result][:instr_count] : nil
      display_count_row(func_name, result[:instr_count], c_count)
    else
      display_result(func_name, result[:func_asm], result[:instr_count], result[:c_result], count_only: false)
    end
  end
end

def main
  options = {
    mode: :show,
    count_only: false
  }

  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: #{File.basename($0)} [OPTIONS] [FUNCTION]

      Show assembly output for stable_api methods.
      Generates Rust code on-demand and compiles directly with rustc.
      C equivalents are automatically shown when available.

    BANNER

    opts.on("--list", "List all available functions") do
      options[:mode] = :list
    end

    opts.on("--all", "Show assembly for all functions") do
      options[:mode] = :all
    end

    opts.on("--count", "Show instruction count only") do
      options[:count_only] = true
    end

    opts.on("-h", "--help", "Show this help message") do
      puts opts
      puts
      puts "Examples:"
      puts "  # Show assembly for symbol_p"
      puts "  #{File.basename($0)} symbol_p"
      puts
      puts "  # Show instruction counts for all functions"
      puts "  #{File.basename($0)} --count --all"
      puts
      puts "  # Show rb_gc_guard (includes C comparison automatically)"
      puts "  #{File.basename($0)} rb_gc_guard"
      puts
      exit 0
    end
  end

  parser.parse!

  show_asm = ShowAsm.new(REPO_ROOT)

  case options[:mode]
  when :list
    show_asm.list_functions
  when :all
    show_asm.show_all(count_only: options[:count_only])
  when :show
    if ARGV.empty?
      warn "ERROR: Function name required"
      puts
      puts parser
      exit 1
    end

    show_asm.show_function(ARGV[0], count_only: options[:count_only])
  end
end

main if __FILE__ == $0
