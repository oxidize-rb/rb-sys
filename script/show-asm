#!/usr/bin/env ruby
# frozen_string_literal: true

#
# Show assembly output for stable_api methods
#
# This script generates Rust code on-demand and compiles it directly with rustc,
# extracting the assembly for the specified function(s).
#
# Usage:
#   ./script/show-asm symbol_p
#   ./script/show-asm --list
#   ./script/show-asm --all
#   ./script/show-asm --count --all
#

require "pathname"
require "optparse"
require "fileutils"
require "tempfile"
require "open3"

REPO_ROOT = Pathname.new(__dir__).parent

# Function definitions parsed from StableApiDefinition trait
# Format: name => { unsafe: bool, args: "arg: Type, ...", ret: "ReturnType", expr: "expression" }
#
# The `expr` uses `api` to refer to `get_default()` and `v` for the VALUE argument
FUNCTIONS = {
  # Safe predicates (no pointer dereference)
  "nil_p" => {unsafe: false, ret: "bool", expr: "api.nil_p(v)"},
  "fixnum_p" => {unsafe: false, ret: "bool", expr: "api.fixnum_p(v)"},
  "static_sym_p" => {unsafe: false, ret: "bool", expr: "api.static_sym_p(v)"},
  "flonum_p" => {unsafe: false, ret: "bool", expr: "api.flonum_p(v)"},
  "immediate_p" => {unsafe: false, ret: "bool", expr: "api.immediate_p(v)"},
  "special_const_p" => {unsafe: false, ret: "bool", expr: "api.special_const_p(v)"},
  "rb_test" => {unsafe: false, ret: "bool", expr: "api.rb_test(v)"},

  # Unsafe predicates (may dereference pointer)
  "symbol_p" => {unsafe: true, ret: "bool", expr: "api.symbol_p(v)"},
  "dynamic_sym_p" => {unsafe: true, ret: "bool", expr: "api.dynamic_sym_p(v)"},
  "float_type_p" => {unsafe: true, ret: "bool", expr: "api.float_type_p(v)"},
  "integer_type_p" => {unsafe: true, ret: "bool", expr: "api.integer_type_p(v)"},

  # type_p for heap types (all generate same asm except for type constant)
  "type_p_heap" => {unsafe: true, ret: "bool", expr: "api.type_p(v, rb_sys::ruby_value_type::RUBY_T_STRING)"},

  # Type inspection
  "builtin_type" => {unsafe: true, ret: "rb_sys::ruby_value_type", expr: "api.builtin_type(v)"},
  "rb_type" => {unsafe: true, ret: "rb_sys::ruby_value_type", expr: "api.rb_type(v)"},

  # String operations
  "rstring_len" => {unsafe: true, ret: "c_long", expr: "api.rstring_len(v)"},
  "rstring_ptr" => {unsafe: true, ret: "*const c_char", expr: "api.rstring_ptr(v)"},
  "rstring_interned_p" => {unsafe: true, ret: "bool", expr: "api.rstring_interned_p(v)"},

  # Array operations
  "rarray_len" => {unsafe: true, ret: "c_long", expr: "api.rarray_len(v)"},
  "rarray_const_ptr" => {unsafe: true, ret: "*const VALUE", expr: "api.rarray_const_ptr(v)"},

  # Object operations
  "rbasic_class" => {unsafe: true, ret: "Option<NonNull<VALUE>>", expr: "api.rbasic_class(v)"},
  "frozen_p" => {unsafe: true, ret: "bool", expr: "api.frozen_p(v)"},

  # Bignum operations
  "bignum_positive_p" => {unsafe: true, ret: "bool", expr: "api.bignum_positive_p(v)"},
  "bignum_negative_p" => {unsafe: true, ret: "bool", expr: "api.bignum_negative_p(v)"},

  # Typed data operations
  "rtypeddata_p" => {unsafe: true, ret: "bool", expr: "api.rtypeddata_p(v)"},
  "rtypeddata_embedded_p" => {unsafe: true, ret: "bool", expr: "api.rtypeddata_embedded_p(v)"},
  "rtypeddata_type" => {unsafe: true, ret: "*const rb_sys::rb_data_type_t", expr: "api.rtypeddata_type(v)"},
  "rtypeddata_get_data" => {unsafe: true, ret: "*mut c_void", expr: "api.rtypeddata_get_data(v)"},

  # GC guard (macro, not StableApiDefinition method)
  # Uses a realistic pattern: extract pointer, call function that might GC, use guard
  "rb_gc_guard" => {unsafe: true, ret: "VALUE", custom_body: <<~RUST}
    // Extract raw pointer from Ruby string
    let ptr = api.rstring_ptr(v);

    // rb_str_new_cstr allocates memory and might trigger GC.
    // Without rb_gc_guard!, the compiler sees 'v' as dead after rstring_ptr,
    // so it might not keep it on the stack. If GC runs during this call,
    // 'v' could be collected and 'ptr' would become a dangling pointer.
    let new_str = rb_sys::rb_str_new_cstr(ptr);

    // Guard keeps 'v' alive on the stack until this point
    rb_sys::rb_gc_guard!(v);

    // Return new_str to prevent it from being optimized away
    new_str
  RUST
}.freeze

# ARM64 instruction patterns to count
INSTRUCTION_PATTERN = /^\s+(mov|ldr|str|add|sub|cmp|tst|and|orr|eor|b\.|bl|ret|cbz|cbnz|cset|ccmp|csinc|adrp|stp|ldp|ror|lsr|tbz|csel)/

# C equivalents for comparison (functions that have a C macro counterpart)
#
# The rb_gc_guard test simulates a realistic dangerous pattern:
#   1. Create a Ruby string
#   2. Extract the raw C pointer (RSTRING_PTR)
#   3. Call a function that might trigger GC (simulated by may_trigger_gc)
#   4. Use the raw pointer after the potential GC point
#
# Without RB_GC_GUARD, the compiler might:
#   - Optimize away the VALUE since it's "dead" after RSTRING_PTR
#   - Allow GC to collect the string, leaving ptr as a dangling pointer
#
# With RB_GC_GUARD, the VALUE is kept alive on the stack until after
# the guard point, ensuring the GC can see it during its conservative scan.
C_EQUIVALENTS = {
  "rb_gc_guard" => {
    code: <<~C,
      #include <ruby.h>

      // Realistic pattern: extract pointer, do work that might GC, use pointer
      // This is the pattern RB_GC_GUARD is designed to protect
      __attribute__((noinline))
      VALUE test_rb_gc_guard_c(VALUE str) {
          // Extract raw pointer from Ruby string
          const char *ptr = RSTRING_PTR(str);

          // rb_str_new_cstr allocates memory and might trigger GC.
          // Without RB_GC_GUARD, the compiler sees 'str' as dead after
          // RSTRING_PTR, so it might not keep it on the stack. If GC runs
          // during this call, 'str' could be collected and 'ptr' would
          // become a dangling pointer.
          VALUE new_str = rb_str_new_cstr(ptr);

          // Guard keeps 'str' alive on the stack until this point
          RB_GC_GUARD(str);

          // Return new_str to prevent it from being optimized away
          return new_str;
      }
    C
    func_name: "test_rb_gc_guard_c"
  }
}.freeze

class ShowAsm
  def initialize(repo_root)
    @repo_root = repo_root
    @target_dir = repo_root.join("target/release")
    @deps_dir = @target_dir.join("deps")
  end

  def ensure_rb_sys_built
    warn "Building rb-sys (release)..."
    Dir.chdir(@repo_root) do
      system("./script/run", "cargo", "build", "-p", "rb-sys", "--release",
        out: $stderr, err: $stderr) or abort "ERROR: Failed to build rb-sys"
    end
  end

  def cfg_flags
    @cfg_flags ||= begin
      output_files = Dir.glob(@repo_root.join("target/release/build/rb-sys-*/output"))
      abort "ERROR: No rb-sys build output found. Run: cargo build -p rb-sys --release" if output_files.empty?

      flags = []
      output_files.each do |file|
        File.foreach(file) do |line|
          if line.start_with?("cargo:rustc-cfg=")
            cfg = line.sub("cargo:rustc-cfg=", "").strip
            flags << cfg unless cfg.empty?
          end
        end
      end
      flags.uniq
    end
  end

  def generate_rust_code(func_name, func_def)
    unsafe_kw = func_def[:unsafe] ? "unsafe " : ""

    # Support custom_body for complex test patterns (like rb_gc_guard)
    body = if func_def[:custom_body]
      func_def[:custom_body]
    elsif func_def[:expr]
      func_def[:unsafe] ? func_def[:expr] : "unsafe { #{func_def[:expr]} }"
    else
      raise "Function #{func_name} needs either :expr or :custom_body"
    end

    # For custom_body, we need to handle the return type declaration
    ret_type = func_def[:ret] || "VALUE"

    <<~RUST
      #![allow(unused_unsafe)]
      extern crate rb_sys;

      use rb_sys::{stable_api::get_default, StableApiDefinition, VALUE};
      use std::ffi::c_void;
      use std::os::raw::{c_char, c_long};
      use std::ptr::NonNull;

      #[inline(never)]
      #[no_mangle]
      pub #{unsafe_kw}fn test_#{func_name}(v: VALUE) -> #{ret_type} {
          let api = get_default();
          #{body}
      }
    RUST
  end

  def compile_to_asm(rust_code)
    Tempfile.create(["show_asm", ".rs"]) do |src_file|
      src_file.write(rust_code)
      src_file.flush

      Tempfile.create(["show_asm", ".s"]) do |asm_file|
        cmd = ["rustc", src_file.path,
          "--crate-type=lib",
          "--emit=asm",
          "-C", "opt-level=3",
          "-C", "lto=fat",
          "-C", "codegen-units=1",
          "--extern=rb_sys=#{@target_dir.join("librb_sys.rlib")}",
          "-L=dependency=#{@deps_dir}",
          "-o", asm_file.path]

        cfg_flags.each { |cfg| cmd << "--cfg" << cfg }

        _, stderr, status = Open3.capture3(*cmd)
        unless status.success?
          abort "ERROR: rustc failed:\n#{stderr}"
        end

        File.read(asm_file.path)
      end
    end
  end

  def extract_function(asm, func_name)
    lines = []
    found = false

    asm.each_line do |line|
      if line.match?(/^_test_#{Regexp.escape(func_name)}:/)
        found = true
        lines << line
        next
      end

      if found
        lines << line
        break if line.include?(".cfi_endproc")
        break if lines.size > 1 && line.match?(/^_[a-zA-Z]/)
      end
    end

    found ? lines.join : nil
  end

  def count_instructions(asm)
    asm.lines.count { |line| line.match?(INSTRUCTION_PATTERN) }
  end

  def display_result(func_name, func_asm, instr_count, c_result, count_only:)
    if count_only
      printf "%-45s %8d\n", "test_#{func_name} (Rust)", instr_count
      if c_result
        printf "%-45s %8d\n", "#{c_result[:func_name]} (C)", c_result[:instr_count]
      end
    else
      puts "=" * 80
      puts "Function: test_#{func_name} (Rust)"
      puts "Instructions: #{instr_count}"
      puts "=" * 80
      puts
      puts func_asm
      puts

      if c_result
        puts "=" * 80
        puts "Function: #{c_result[:func_name]} (C)"
        puts "Instructions: #{c_result[:instr_count]}"
        puts "=" * 80
        puts
        puts c_result[:asm]
        puts
      end
    end
  end

  def compile_and_extract(func_name)
    func_def = FUNCTIONS[func_name]
    return nil unless func_def

    rust_code = generate_rust_code(func_name, func_def)
    full_asm = compile_to_asm(rust_code)
    func_asm = extract_function(full_asm, func_name)

    return nil unless func_asm

    instr_count = count_instructions(func_asm)
    c_result = C_EQUIVALENTS.key?(func_name) ? show_c_comparison(func_name) : nil

    {func_asm: func_asm, instr_count: instr_count, c_result: c_result}
  end

  def show_all(count_only: false)
    ensure_rb_sys_built

    if count_only
      printf "%-45s %8s\n", "Function", "Instructions"
      puts "-" * 80
    end

    FUNCTIONS.keys.sort.each do |func_name|
      result = compile_and_extract(func_name)

      unless result
        warn "WARN: Function 'test_#{func_name}' not found in assembly"
        next
      end

      display_result(func_name, result[:func_asm], result[:instr_count], result[:c_result], count_only: count_only)
    end
  end

  def list_functions
    puts "Available functions:"
    puts
    printf "%-25s %-8s %-12s %s\n", "Name", "Safety", "C Equivalent", "Return Type"
    puts "-" * 80
    FUNCTIONS.keys.sort.each do |name|
      func = FUNCTIONS[name]
      safety = func[:unsafe] ? "unsafe" : "safe"
      has_c = C_EQUIVALENTS.key?(name) ? "yes" : "-"
      printf "%-25s %-8s %-12s %s\n", name, safety, has_c, func[:ret]
    end
  end

  def ruby_config
    @ruby_config ||= begin
      require "rbconfig"
      RbConfig::CONFIG
    end
  end

  def compile_c_to_asm(c_code)
    Tempfile.create(["show_asm", ".c"]) do |src_file|
      src_file.write(c_code)
      src_file.flush

      Tempfile.create(["show_asm", ".s"]) do |asm_file|
        cc = ruby_config["CC"]
        hdrdir = ruby_config["rubyhdrdir"]
        archhdrdir = ruby_config["rubyarchhdrdir"]

        cmd = [cc, src_file.path,
          "-S",                     # Output assembly
          "-O3",                    # Optimize
          "-fno-stack-protector",   # Disable stack canary for fair comparison
          "-I#{hdrdir}",
          "-I#{archhdrdir}",
          "-o", asm_file.path]

        _, stderr, status = Open3.capture3(*cmd)
        unless status.success?
          abort "ERROR: C compiler failed:\n#{stderr}"
        end

        File.read(asm_file.path)
      end
    end
  end

  def extract_c_function(asm, func_name)
    lines = []
    found = false

    asm.each_line do |line|
      # Match function label (with or without leading underscore)
      if line.match?(/^_?#{Regexp.escape(func_name)}:/)
        found = true
        lines << line
        next
      end

      if found
        lines << line
        break if line.include?(".cfi_endproc")
        # Stop at next function label, but ignore local labels:
        # - Lloh* (linker optimization hints)
        # - LBB* (basic block labels)
        # - Ltmp* (temporary labels)
        # Local labels start with 'L' (clang) or '.L' (gcc)
        next if line.match?(/^\.?L[A-Za-z]/)
        break if lines.size > 1 && line.match?(/^_?[a-zA-Z][a-zA-Z0-9_]*:/)
      end
    end

    found ? lines.join : nil
  end

  def show_c_comparison(func_name)
    c_def = C_EQUIVALENTS[func_name]
    return nil unless c_def

    full_asm = compile_c_to_asm(c_def[:code])
    func_asm = extract_c_function(full_asm, c_def[:func_name])

    unless func_asm
      warn "WARN: C function '#{c_def[:func_name]}' not found in assembly"
      return nil
    end

    instr_count = count_instructions(func_asm)

    {asm: func_asm, instr_count: instr_count, func_name: c_def[:func_name]}
  end

  def show_function(func_name, count_only: false)
    abort "ERROR: Unknown function '#{func_name}'. Use --list to see available functions." unless FUNCTIONS.key?(func_name)

    ensure_rb_sys_built

    result = compile_and_extract(func_name)

    unless result
      abort "ERROR: Function 'test_#{func_name}' not found in assembly output"
    end

    display_result(func_name, result[:func_asm], result[:instr_count], result[:c_result], count_only: count_only)
  end
end

def main
  options = {
    mode: :show,
    count_only: false
  }

  parser = OptionParser.new do |opts|
    opts.banner = <<~BANNER
      Usage: #{File.basename($0)} [OPTIONS] [FUNCTION]

      Show assembly output for stable_api methods.
      Generates Rust code on-demand and compiles directly with rustc.
      C equivalents are automatically shown when available.

    BANNER

    opts.on("--list", "List all available functions") do
      options[:mode] = :list
    end

    opts.on("--all", "Show assembly for all functions") do
      options[:mode] = :all
    end

    opts.on("--count", "Show instruction count only") do
      options[:count_only] = true
    end

    opts.on("-h", "--help", "Show this help message") do
      puts opts
      puts
      puts "Examples:"
      puts "  # Show assembly for symbol_p"
      puts "  #{File.basename($0)} symbol_p"
      puts
      puts "  # Show instruction counts for all functions"
      puts "  #{File.basename($0)} --count --all"
      puts
      puts "  # Show rb_gc_guard (includes C comparison automatically)"
      puts "  #{File.basename($0)} rb_gc_guard"
      puts
      exit 0
    end
  end

  parser.parse!

  show_asm = ShowAsm.new(REPO_ROOT)

  case options[:mode]
  when :list
    show_asm.list_functions
  when :all
    show_asm.show_all(count_only: options[:count_only])
  when :show
    if ARGV.empty?
      warn "ERROR: Function name required"
      puts
      puts parser
      exit 1
    end

    show_asm.show_function(ARGV[0], count_only: options[:count_only])
  end
end

main if __FILE__ == $0
