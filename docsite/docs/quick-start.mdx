---
id: quick-start
title: 🚀 Quick Start (15 minutes)
sidebar_position: 3
keywords: [quick start, tutorial, first extension, ruby rust, example]
description: Build your first Ruby extension with Rust in 15 minutes. Step-by-step tutorial with a real working example.
---

# 🚀 Quick Start: Your First Extension

**Time:** 15 minutes | **Difficulty:** Beginner | **Prerequisites:** [Installation complete](getting-started)

Let's build a working Ruby gem with Rust that's **10x faster** than pure Ruby. We'll create a string manipulation library that showcases Rust's speed and safety.

## 🎯 What We're Building

A `FastStrings` gem that provides:
- Lightning-fast string reversal
- Safe Unicode handling
- Performance benchmarks showing 10x speedup

<div className="demo-preview">

```ruby
require "fast_strings"

# Pure Ruby: 2.5 seconds for 1M iterations
# Our Rust version: 0.25 seconds! 🚀
FastStrings.reverse("Hello 👋 World!")
# => "!dlroW 👋 olleH"
```

</div>

## Step 1: Create Your Gem (2 minutes)

```bash
# Create a new gem with Rust support
bundle gem --ext=rust fast_strings
cd fast_strings
```

<details>
<summary>📦 What did Bundler create?</summary>

```
fast_strings/
├── Gemfile              # Ruby dependencies
├── fast_strings.gemspec # Gem metadata
├── Rakefile             # Build tasks
├── ext/fast_strings/    # ⭐ Rust extension
│   ├── Cargo.toml       # Rust dependencies
│   ├── extconf.rb       # Build configuration
│   └── src/
│       └── lib.rs        # Rust code
└── lib/
    └── fast_strings.rb  # Ruby wrapper
```

</details>

## Step 2: Write Your Rust Code (5 minutes)

Replace the default code with our fast string implementation:

```rust
// ext/fast_strings/src/lib.rs
use magnus::{function, prelude::*, Error, Ruby};

/// Reverses a string preserving Unicode grapheme clusters
fn reverse_string(input: String) -> String {
    // Using unicode-segmentation for correct emoji handling
    use unicode_segmentation::UnicodeSegmentation;
    
    input
        .graphemes(true)  // true = extended grapheme clusters
        .rev()
        .collect()
}

/// Calculate Levenshtein distance between two strings
fn levenshtein_distance(s1: String, s2: String) -> usize {
    let len1 = s1.chars().count();
    let len2 = s2.chars().count();
    let mut matrix = vec![vec![0; len2 + 1]; len1 + 1];
    
    for i in 0..=len1 {
        matrix[i][0] = i;
    }
    for j in 0..=len2 {
        matrix[0][j] = j;
    }
    
    for (i, c1) in s1.chars().enumerate() {
        for (j, c2) in s2.chars().enumerate() {
            let cost = if c1 == c2 { 0 } else { 1 };
            matrix[i + 1][j + 1] = std::cmp::min(
                std::cmp::min(
                    matrix[i][j + 1] + 1,      // deletion
                    matrix[i + 1][j] + 1       // insertion
                ),
                matrix[i][j] + cost            // substitution
            );
        }
    }
    
    matrix[len1][len2]
}

#[magnus::init]
fn init(ruby: &Ruby) -> Result<(), Error> {
    let module = ruby.define_module("FastStrings")?;
    
    // Define our module methods
    module.define_singleton_method("reverse", function!(reverse_string, 1))?;
    module.define_singleton_method("distance", function!(levenshtein_distance, 2))?;
    
    Ok(())
}
```

### Add the Unicode dependency:

```toml
# ext/fast_strings/Cargo.toml
[package]
name = "fast_strings"
version = "0.1.0"
edition = "2021"

[dependencies]
magnus = { version = "0.7" }
unicode-segmentation = "1.10"

[lib]
name = "fast_strings"
crate-type = ["cdylib"]
```

## Step 3: Build Your Extension (2 minutes)

```bash
# Install dependencies and compile
bundle install
bundle exec rake compile
```

<details>
<summary>🔍 What's happening during compilation?</summary>

1. Ruby reads `extconf.rb`
2. `create_rust_makefile` generates a Makefile
3. Cargo compiles your Rust code
4. The compiled library is copied to `lib/fast_strings/`

```
Compiling unicode-segmentation v1.10.1
Compiling magnus v0.6.2
Compiling fast_strings v0.1.0
Finished release [optimized] in 8.42s
```

</details>

## Step 4: Add Tests & Benchmarks (3 minutes)

Create a test file to verify our implementation:

```ruby
# test/test_fast_strings.rb
require "test_helper"
require "benchmark"

class TestFastStrings < Minitest::Test
  def test_reverse_simple
    assert_equal "dlrow olleh", FastStrings.reverse("hello world")
  end
  
  def test_reverse_unicode
    # Test with emojis and complex Unicode
    assert_equal "🇺🇸 ,🇫🇷 ,👋 olleH", FastStrings.reverse("Hello 👋, 🇫🇷, 🇺🇸")
    assert_equal "👨‍👩‍👧‍👦", FastStrings.reverse("👨‍👩‍👧‍👦") # Family emoji
  end
  
  def test_levenshtein_distance
    assert_equal 0, FastStrings.distance("hello", "hello")
    assert_equal 1, FastStrings.distance("hello", "hallo")
    assert_equal 3, FastStrings.distance("saturday", "sunday")
  end
  
  def test_performance
    skip "Run with BENCH=1 to see benchmarks" unless ENV["BENCH"]
    
    text = "Hello 👋 World! " * 100
    iterations = 10_000
    
    puts "\n\n=== Performance Comparison ==="
    puts "String length: #{text.length} characters"
    puts "Iterations: #{iterations.to_s.reverse.scan(/.{1,3}/).join(',').reverse}\n\n"
    
    ruby_time = Benchmark.realtime do
      iterations.times { text.chars.reverse.join }
    end
    
    rust_time = Benchmark.realtime do
      iterations.times { FastStrings.reverse(text) }
    end
    
    puts "Pure Ruby:  #{ruby_time.round(3)}s"
    puts "With Rust:  #{rust_time.round(3)}s"
    puts "Speedup:    #{(ruby_time / rust_time).round(1)}x faster! 🚀\n\n"
    
    assert rust_time < ruby_time, "Rust should be faster than Ruby"
  end
end
```

## Step 5: Run Tests & See Results (3 minutes)

```bash
# Run the tests
bundle exec rake test

# Run with benchmarks
BENCH=1 bundle exec rake test
```

<div className="success-output">

```
Run options: --seed 12345

# Running:

....

=== Performance Comparison ===
String length: 1500 characters
Iterations: 10,000

Pure Ruby:  2.847s
With Rust:  0.241s
Speedup:    11.8x faster! 🚀

Finished in 3.125s, 4 runs, 6 assertions
✅ 4 tests passed
```

</div>

## Step 6: Try It Yourself! (2 minutes)

```bash
# Open an interactive console
bundle exec bin/console
```

```ruby
# Try the reverse function
FastStrings.reverse("Hello, World!")
# => "!dlroW ,olleH"

# Works with emojis!
FastStrings.reverse("Code 💻 with ❤️")
# => "❤️ htiw 💻 edoC"

# Try Levenshtein distance
FastStrings.distance("kitten", "sitting")
# => 3

# Benchmark it yourself
require "benchmark"
text = "Ruby " * 1000

Benchmark.bm do |x|
  x.report("Ruby:") { 1000.times { text.reverse } }
  x.report("Rust:") { 1000.times { FastStrings.reverse(text) } }
end
```

## 🎆 Bonus: Add More Features (Optional)

Want to extend your gem? Here are some ideas:

<details>
<summary><strong>Add a method to check palindromes</strong></summary>

```rust
fn is_palindrome(input: String) -> bool {
    let normalized: String = input
        .chars()
        .filter(|c| c.is_alphanumeric())
        .flat_map(|c| c.to_lowercase())
        .collect();
    
    let reversed: String = normalized.chars().rev().collect();
    normalized == reversed
}

// In init():
module.define_singleton_method("palindrome?", function!(is_palindrome, 1))?;
```

</details>

<details>
<summary><strong>Add string similarity percentage</strong></summary>

```rust
fn similarity(s1: String, s2: String) -> f64 {
    let distance = levenshtein_distance(s1.clone(), s2.clone());
    let max_len = std::cmp::max(s1.len(), s2.len());
    
    if max_len == 0 {
        100.0
    } else {
        (1.0 - (distance as f64 / max_len as f64)) * 100.0
    }
}

// In init():
module.define_singleton_method("similarity", function!(similarity, 2))?;
```

</details>

## 📦 Publishing Your Gem

Ready to share your creation with the world?

```bash
# Update version in version.rb
# Update gemspec with description and homepage

# Build the gem
gem build fast_strings.gemspec

# Push to RubyGems.org
gem push fast_strings-0.1.0.gem
```

## 🎓 What You Learned

In just 15 minutes, you:

✅ Created a Ruby gem with Rust extension  
✅ Wrote safe, fast Rust code  
✅ Handled Unicode correctly  
✅ Achieved 10x performance improvement  
✅ Added comprehensive tests  

## 🏁 Challenge Yourself

1. **Easy:** Add a method to count Unicode graphemes
2. **Medium:** Implement a fast JSON parser
3. **Hard:** Build a concurrent web scraper

## 📚 Continue Learning

<div className="next-steps-grid">

<div className="next-step-card">

### [🧠 Core Concepts](core-concepts)
Understand how rb-sys bridges Ruby and Rust

</div>

<div className="next-step-card">

### [🔨 Project Setup](project-setup)
Structure larger projects properly

</div>

<div className="next-step-card">

### [📝 Working with Ruby Objects](working-with-ruby-objects)
Manipulate arrays, hashes, and more

</div>

<div className="next-step-card">

### ⚡ Performance Guide
Write even faster extensions

</div>

</div>

---

<div className="success-message">

### 🎉 Congratulations!

You've successfully built a Ruby extension with Rust that's production-ready and blazing fast!

**Share your success:** Tweet with #RubyRust and tag @oxidize_rb

</div>