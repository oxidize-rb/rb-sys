"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[136],{3355:(e,n,r)=>{r.d(n,{A:()=>l});r(6540);const t={languageCallout:"languageCallout_VNpC",ruby:"ruby_iFYN",rust:"rust_PB7z",header:"header_itAP",icon:"icon_vHP_",title:"title_Bire",content:"content_ZrzH"};var s=r(4164),i=r(4848);function l(e){let{language:n,icon:r=!0,title:l,children:a}=e;const o=l||("ruby"===n?"Ruby":"Rust");return(0,i.jsxs)("div",{className:(0,s.A)(t.languageCallout,t[n]),children:[(0,i.jsxs)("div",{className:t.header,children:[r&&(0,i.jsx)("div",{className:t.icon,children:"ruby"===n?(0,i.jsxs)("svg",{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"1.5",height:"20",width:"20",children:[(0,i.jsx)("path",{d:"M6 3h12l4 6-10 12L2 9l4-6z",strokeLinejoin:"round"}),(0,i.jsx)("path",{d:"M12 21L2 9h20",strokeLinejoin:"round"})]}):(0,i.jsxs)("svg",{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"1.5",height:"20",width:"20",children:[(0,i.jsx)("circle",{cx:"12",cy:"12",r:"8"}),(0,i.jsx)("path",{d:"M12 4v2M12 18v2M4 12H6M18 12h2M6.34 6.34l1.42 1.42M16.24 16.24l1.42 1.42M6.34 17.66l1.42-1.42M16.24 7.76l1.42-1.42"}),(0,i.jsx)("path",{d:"M9 12a3 3 0 1 0 6 0 3 3 0 0 0-6 0z"})]})}),(0,i.jsx)("div",{className:t.title,children:o})]}),(0,i.jsx)("div",{className:t.content,children:a})]})}},7599:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"project-setup","title":"Project Setup","description":"In this chapter, we\'ll explore how to set up and organize a Ruby gem with a Rust extension. We\'ll focus on practical patterns and highlight how to leverage valuable Rust libraries without introducing unnecessary complexity.","source":"@site/docs/project-setup.mdx","sourceDirName":".","slug":"/project-setup","permalink":"/docs/project-setup","draft":false,"unlisted":false,"editUrl":"https://github.com/oxidize-rb/rb-sys/tree/main/docsite/docs/project-setup.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Quick Start - Your First Extension","permalink":"/docs/quick-start"},"next":{"title":"Hello Rusty Documentation","permalink":"/docs/hello-rusty-documentation"}}');var s=r(4848),i=r(8453),l=r(3355);const a={sidebar_position:2},o="Project Setup",c={},u=[{value:"Enhanced Project Structure",id:"enhanced-project-structure",level:2},{value:"Example: URL Parsing with the <code>url</code> crate",id:"example-url-parsing-with-the-url-crate",level:2},{value:"1. Extension Cargo.toml",id:"1-extension-cargotoml",level:3},{value:"2. Main Rust Implementation",id:"2-main-rust-implementation",level:3},{value:"3. Ruby Integration",id:"3-ruby-integration",level:3},{value:"4. Simple Tests",id:"4-simple-tests",level:3},{value:"Key Aspects of this Project",id:"key-aspects-of-this-project",level:2},{value:"1. Simplicity with Value",id:"1-simplicity-with-value",level:3},{value:"2. Why Use Rust for URL Parsing?",id:"2-why-use-rust-for-url-parsing",level:3},{value:"3. Project Organization Principles",id:"3-project-organization-principles",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"project-setup",children:"Project Setup"})}),"\n","\n",(0,s.jsx)(n.p,{children:"In this chapter, we'll explore how to set up and organize a Ruby gem with a Rust extension. We'll focus on practical patterns and highlight how to leverage valuable Rust libraries without introducing unnecessary complexity."}),"\n",(0,s.jsx)(l.A,{}),"\n",(0,s.jsx)(n.h2,{id:"enhanced-project-structure",children:"Enhanced Project Structure"}),"\n",(0,s.jsxs)(n.p,{children:["Building on the structure created by ",(0,s.jsx)(n.code,{children:"bundle gem --ext=rust"}),", a well-organized rb-sys project typically looks like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-plaintext",children:"my_gem/\n\u251c\u2500\u2500 Cargo.toml                # Rust workspace configuration\n\u251c\u2500\u2500 Gemfile                   # Ruby dependencies\n\u251c\u2500\u2500 Rakefile                  # Build tasks\n\u251c\u2500\u2500 my_gem.gemspec            # Gem specification\n\u251c\u2500\u2500 ext/\n\u2502   \u2514\u2500\u2500 my_gem/\n\u2502       \u251c\u2500\u2500 Cargo.toml        # Rust crate configuration\n\u2502       \u251c\u2500\u2500 extconf.rb        # Ruby extension configuration\n\u2502       \u2514\u2500\u2500 src/\n\u2502           \u2514\u2500\u2500 lib.rs        # Main Rust entry point\n\u251c\u2500\u2500 lib/\n\u2502   \u251c\u2500\u2500 my_gem.rb             # Main Ruby file\n\u2502   \u2514\u2500\u2500 my_gem/\n\u2502       \u2514\u2500\u2500 version.rb        # Version information\n\u2514\u2500\u2500 test/                     # Tests\n"})}),"\n",(0,s.jsx)(n.p,{children:"Let's examine a practical example using a useful but simple Rust library."}),"\n",(0,s.jsxs)(n.h2,{id:"example-url-parsing-with-the-url-crate",children:["Example: URL Parsing with the ",(0,s.jsx)(n.code,{children:"url"})," crate"]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.a,{href:"https://crates.io/crates/url",children:"url"})," crate, developed by the Servo team, is a robust implementation of the URL Standard. It provides accurate URL parsing that would be complex to implement from scratch. Here's a simple example:"]}),"\n",(0,s.jsx)(n.h3,{id:"1-extension-cargotoml",children:"1. Extension Cargo.toml"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'# ext/url_parser/Cargo.toml\n[package]\nname = "url_parser"\nversion = "0.1.0"\nedition = "2021"\nauthors = ["Your Name <your.email@example.com>"]\nlicense = "MIT"\npublish = false\n\n[lib]\ncrate-type = ["cdylib"]\n\n[dependencies]\n# High-level Ruby bindings with rb-sys feature\nmagnus = { version = "0.7", features = ["rb-sys"] }\n\n# The main Rust library we\'re wrapping\nurl = "2.4"\n\n[build-dependencies]\nrb-sys-env = "0.1"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-main-rust-implementation",children:"2. Main Rust Implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// ext/url_parser/src/lib.rs\nuse magnus::{define_module, define_class, function, method, prelude::*, Error, Ruby};\nuse url::Url;\n\n// Simple URL wrapper class\nstruct UrlWrapper {\n    inner: Url,\n}\n\n#[magnus::wrap(class = "UrlParser::URL")]\nimpl UrlWrapper {\n    // Parse a URL string\n    fn parse(url_str: String) -> Result<Self, Error> {\n        match Url::parse(&url_str) {\n            Ok(url) => Ok(UrlWrapper { inner: url }),\n            Err(err) => {\n                Err(Error::new(magnus::exception::arg_error(), format!("Invalid URL: {}", err)))\n            }\n        }\n    }\n\n    // Basic getters\n    fn scheme(&self) -> String {\n        self.inner.scheme().to_string()\n    }\n\n    fn host(&self) -> Option<String> {\n        self.inner.host_str().map(|s| s.to_string())\n    }\n\n    fn path(&self) -> String {\n        self.inner.path().to_string()\n    }\n\n    fn query(&self) -> Option<String> {\n        self.inner.query().map(|s| s.to_string())\n    }\n\n    // String representation of the URL\n    fn to_string(&self) -> String {\n        self.inner.to_string()\n    }\n}\n\n// Module-level utilities\nfn is_valid_url(url_str: String) -> bool {\n    Url::parse(&url_str).is_ok()\n}\n\n// Module init function - Ruby extension entry point\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), Error> {\n    // Define the main module\n    let module = ruby.define_module("UrlParser")?;\n\n    // Add utility function at module level\n    module.define_singleton_method("valid_url?", function!(is_valid_url, 1))?;\n\n    // Define and configure the URL class\n    let class = module.define_class("URL", ruby.class_object())?;\n    class.define_singleton_method("parse", function!(UrlWrapper::parse, 1))?;\n\n    // Instance methods\n    class.define_method("scheme", method!(UrlWrapper::scheme, 0))?;\n    class.define_method("host", method!(UrlWrapper::host, 0))?;\n    class.define_method("path", method!(UrlWrapper::path, 0))?;\n    class.define_method("query", method!(UrlWrapper::query, 0))?;\n    class.define_method("to_s", method!(UrlWrapper::to_string, 0))?;\n\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"3-ruby-integration",children:"3. Ruby Integration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:'# lib/url_parser.rb\nrequire_relative "url_parser/version"\nrequire_relative "url_parser/url_parser"\n\nmodule UrlParser\n  class Error < StandardError; end\n\n  # Parse a URL string and return a URL object\n  def self.parse(url_string)\n    URL.parse(url_string)\n  rescue => e\n    raise Error, "Failed to parse URL: #{e.message}"\n  end\n\n  # Check if a URL has an HTTPS scheme\n  def self.https?(url_string)\n    return false unless valid_url?(url_string)\n    url = parse(url_string)\n    url.scheme == "https"\n  end\nend\n'})}),"\n",(0,s.jsx)(n.h3,{id:"4-simple-tests",children:"4. Simple Tests"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ruby",children:'# test/test_url_parser.rb\nrequire "test_helper"\n\nclass TestUrlParser < Minitest::Test\n  def test_basic_url_parsing\n    url = UrlParser::URL.parse("https://example.com/path?query=value")\n\n    assert_equal "https", url.scheme\n    assert_equal "example.com", url.host\n    assert_equal "/path", url.path\n    assert_equal "query=value", url.query\n  end\n\n  def test_url_validation\n    assert UrlParser.valid_url?("https://example.com")\n    refute UrlParser.valid_url?("not a url")\n  end\n\n  def test_https_check\n    assert UrlParser.https?("https://example.com")\n    refute UrlParser.https?("http://example.com")\n  end\n\n  def test_invalid_url_raises_error\n    assert_raises UrlParser::Error do\n      UrlParser.parse("not://a.valid/url")\n    end\n  end\nend\n'})}),"\n",(0,s.jsx)(n.h2,{id:"key-aspects-of-this-project",children:"Key Aspects of this Project"}),"\n",(0,s.jsx)(n.h3,{id:"1-simplicity-with-value",children:"1. Simplicity with Value"}),"\n",(0,s.jsx)(n.p,{children:"This example demonstrates how to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Wrap a useful Rust library (",(0,s.jsx)(n.code,{children:"url"}),") with minimal code"]}),"\n",(0,s.jsx)(n.li,{children:"Expose only the most essential functionality"}),"\n",(0,s.jsx)(n.li,{children:"Handle errors properly"}),"\n",(0,s.jsx)(n.li,{children:"Integrate with Ruby idiomatically"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-why-use-rust-for-url-parsing",children:"2. Why Use Rust for URL Parsing?"}),"\n",(0,s.jsxs)(n.p,{children:["Ruby has URI handling in its standard library, but the Rust ",(0,s.jsx)(n.code,{children:"url"})," crate offers advantages:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Full compliance with the URL standard used by browsers"}),"\n",(0,s.jsx)(n.li,{children:"Better handling of internationalized domain names (IDNs)"}),"\n",(0,s.jsx)(n.li,{children:"Robust error detection"}),"\n",(0,s.jsx)(n.li,{children:"Significant performance benefits for URL-heavy applications"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-project-organization-principles",children:"3. Project Organization Principles"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Keep dependencies minimal"}),": Just what you need, nothing more"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Clean public API"}),": Expose only what users need"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Proper error handling"}),": Map Rust errors to meaningful Ruby exceptions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Simple tests"}),": Verify both functionality and edge cases"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>a});var t=r(6540);const s={},i=t.createContext(s);function l(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);