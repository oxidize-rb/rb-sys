"use strict";(self.webpackChunkdocsite=self.webpackChunkdocsite||[]).push([[46],{3355:(n,e,t)=>{t.d(e,{A:()=>a});t(6540);const r={languageCallout:"languageCallout_VNpC",ruby:"ruby_iFYN",rust:"rust_PB7z",header:"header_itAP",icon:"icon_vHP_",title:"title_Bire",content:"content_ZrzH"};var s=t(4164),i=t(4848);function a(n){let{language:e,icon:t=!0,title:a,children:l}=n;const o=a||("ruby"===e?"Ruby":"Rust");return(0,i.jsxs)("div",{className:(0,s.A)(r.languageCallout,r[e]),children:[(0,i.jsxs)("div",{className:r.header,children:[t&&(0,i.jsx)("div",{className:r.icon,children:"ruby"===e?(0,i.jsxs)("svg",{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"1.5",height:"20",width:"20",children:[(0,i.jsx)("path",{d:"M6 3h12l4 6-10 12L2 9l4-6z",strokeLinejoin:"round"}),(0,i.jsx)("path",{d:"M12 21L2 9h20",strokeLinejoin:"round"})]}):(0,i.jsxs)("svg",{viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:"1.5",height:"20",width:"20",children:[(0,i.jsx)("circle",{cx:"12",cy:"12",r:"8"}),(0,i.jsx)("path",{d:"M12 4v2M12 18v2M4 12H6M18 12h2M6.34 6.34l1.42 1.42M16.24 16.24l1.42 1.42M6.34 17.66l1.42-1.42M16.24 7.76l1.42-1.42"}),(0,i.jsx)("path",{d:"M9 12a3 3 0 1 0 6 0 3 3 0 0 0-6 0z"})]})}),(0,i.jsx)("div",{className:r.title,children:o})]}),(0,i.jsx)("div",{className:r.content,children:l})]})}},7547:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>u,contentTitle:()=>o,default:()=>y,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"working-with-ruby-objects","title":"Working with Ruby Objects","description":"When writing Ruby extensions in Rust, one of the most common tasks is converting between Ruby and Rust types. The magnus crate provides a comprehensive set of conversion functions for this purpose.","source":"@site/docs/working-with-ruby-objects.mdx","sourceDirName":".","slug":"/working-with-ruby-objects","permalink":"/docs/working-with-ruby-objects","draft":false,"unlisted":false,"editUrl":"https://github.com/oxidize-rb/rb-sys/tree/main/docsite/docs/working-with-ruby-objects.mdx","tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"docsSidebar","previous":{"title":"Development Approaches","permalink":"/docs/development-approaches"},"next":{"title":"Ruby Classes and Modules","permalink":"/docs/classes-and-modules"}}');var s=t(4848),i=t(8453),a=t(3355);const l={sidebar_position:7},o="Working with Ruby Objects",u={},c=[{value:"Basic Type Conversions",id:"basic-type-conversions",level:2},{value:"Primitive Types",id:"primitive-types",level:3},{value:"Checking Types",id:"checking-types",level:3},{value:"Strings, Arrays, and Hashes",id:"strings-arrays-and-hashes",level:2},{value:"Working with Ruby Strings",id:"working-with-ruby-strings",level:3},{value:"Working with Ruby Arrays",id:"working-with-ruby-arrays",level:3},{value:"Working with Ruby Hashes",id:"working-with-ruby-hashes",level:3},{value:"Handling nil Values",id:"handling-nil-values",level:2},{value:"Converting Between Ruby and Rust Types",id:"converting-between-ruby-and-rust-types",level:2},{value:"From Rust to Ruby (TryConvert)",id:"from-rust-to-ruby-tryconvert",level:3},{value:"From Ruby to Rust (IntoValue)",id:"from-ruby-to-rust-intovalue",level:3},{value:"Best Practices",id:"best-practices",level:2}];function h(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"working-with-ruby-objects",children:"Working with Ruby Objects"})}),"\n","\n",(0,s.jsx)(e.p,{children:"When writing Ruby extensions in Rust, one of the most common tasks is converting between Ruby and Rust types. The magnus crate provides a comprehensive set of conversion functions for this purpose."}),"\n",(0,s.jsx)(a.A,{}),"\n",(0,s.jsx)(e.h2,{id:"basic-type-conversions",children:"Basic Type Conversions"}),"\n",(0,s.jsx)(e.h3,{id:"primitive-types",children:"Primitive Types"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use magnus::{RString, Ruby, Value, Integer, Float, Boolean};\n\n#[magnus::init]\nfn init(ruby: &Ruby) -> Result<(), magnus::Error> {\n    // Convert Rust types to Ruby \n    let rb_string: RString = RString::new(ruby, "Hello, Ruby!");  // Rust &str to Ruby String\n    let rb_int: Integer = Integer::from_i64(42);                 // Rust i64 to Ruby Integer\n    let rb_float: Float = Float::from_f64(3.14159);             // Rust f64 to Ruby Float\n    let rb_bool: Boolean = Boolean::from(true);                 // Rust bool to Ruby true/false\n\n    // Convert Ruby types to Rust\n    let rust_string: String = rb_string.to_string()?;           // Ruby String to Rust String\n    let rust_int: i64 = rb_int.to_i64()?;                       // Ruby Integer to Rust i64 \n    let rust_float: f64 = rb_float.to_f64()?;                   // Ruby Float to Rust f64\n    let rust_bool: bool = rb_bool.to_bool();                    // Ruby true/false to Rust bool\n\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"checking-types",children:"Checking Types"}),"\n",(0,s.jsx)(e.p,{children:"When working with Ruby objects, you often need to check their types:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use magnus::{RString, Ruby, Value, check_type};\n\nfn process_value(ruby: &Ruby, val: Value) -> Result<(), magnus::Error> {\n    if val.is_nil() {\n        println!("Got nil");\n    } else if let Ok(s) = RString::try_convert(val) {\n        println!("Got string: {}", s.to_string()?);\n    } else if check_type::<Integer>(val) {\n        println!("Got integer: {}", Integer::from_value(val)?.to_i64()?);\n    } else {\n        println!("Got some other type");\n    }\n\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"strings-arrays-and-hashes",children:"Strings, Arrays, and Hashes"}),"\n",(0,s.jsx)(e.h3,{id:"working-with-ruby-strings",children:"Working with Ruby Strings"}),"\n",(0,s.jsx)(e.p,{children:"Ruby strings are encoded and have more complex behavior than Rust strings:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use magnus::{RString, Ruby, Encoding};\n\nfn string_operations(ruby: &Ruby) -> Result<(), magnus::Error> {\n    // Create a new Ruby string\n    let hello = RString::new(ruby, "Hello");\n\n    // Concatenate strings\n    let world = RString::new(ruby, " World!");\n    let message = hello.concat(ruby, world)?;\n\n    // Get the encoding\n    let encoding = message.encoding();\n    println!("String encoding: {}", encoding.name());\n\n    // Convert to different encoding\n    let utf16 = Encoding::find("UTF-16BE").unwrap();\n    let utf16_str = message.encode(ruby, utf16, None)?;\n\n    // Get bytes\n    let bytes = message.as_bytes();\n    println!("Bytes: {:?}", bytes);\n\n    // Create from bytes with specific encoding\n    let latin1 = Encoding::find("ISO-8859-1").unwrap();\n    let bytes = [72, 101, 108, 108, 111]; // "Hello" in ASCII/Latin1\n    let latin1_str = RString::from_slice(ruby, &bytes, Some(latin1));\n\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"working-with-ruby-arrays",children:"Working with Ruby Arrays"}),"\n",(0,s.jsx)(e.p,{children:"Ruby arrays can hold any kind of Ruby object:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use magnus::{RArray, Ruby, Value};\n\nfn array_operations(ruby: &Ruby) -> Result<(), magnus::Error> {\n    // Create a new empty array\n    let array = RArray::new(ruby);\n\n    // Push elements\n    array.push(ruby, 1)?;\n    array.push(ruby, "two")?;\n    array.push(ruby, 3.0)?;\n\n    // Get length\n    let length = array.len();\n    println!("Array length: {}", length);\n\n    // Access elements\n    let first: i64 = array.get(0)?;\n    let second: String = array.get(1)?;\n    let third: f64 = array.get(2)?;\n\n    // Iterate through elements\n    for i in 0..array.len() {\n        let item: Value = array.get(i)?;\n        println!("Item {}: {:?}", i, item);\n    }\n\n    // Another way to iterate\n    array.each(|val| {\n        println!("Item: {:?}", val);\n        Ok(())\n    })?;\n\n    // Create an array from Rust Vec\n    let numbers = vec![1, 2, 3, 4, 5];\n    let rb_array = RArray::from_iter(ruby, numbers);\n\n    // Convert to a Rust Vec\n    let vec: Vec<i64> = rb_array.to_vec()?;\n\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"working-with-ruby-hashes",children:"Working with Ruby Hashes"}),"\n",(0,s.jsx)(e.p,{children:"Ruby hashes are similar to Rust's HashMap but can use any Ruby object as keys:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use magnus::{RHash, Value, Symbol, Ruby};\n\nfn hash_operations(ruby: &Ruby) -> Result<(), magnus::Error> {\n    // Create a new hash\n    let hash = RHash::new(ruby);\n\n    // Add key-value pairs\n    hash.aset(ruby, "name", "Alice")?;\n    hash.aset(ruby, Symbol::new("age"), 30)?;\n    hash.aset(ruby, 1, "one")?;\n\n    // Get values\n    let name: String = hash.get(ruby, "name")?;\n    let age: i64 = hash.get(ruby, Symbol::new("age"))?;\n    let one: String = hash.get(ruby, 1)?;\n\n    // Check if key exists\n    if hash.has_key(ruby, "name")? {\n        println!("Has key \'name\'");\n    }\n\n    // Delete a key\n    hash.delete(ruby, 1)?;\n\n    // Iterate over key-value pairs\n    hash.foreach(|k, v| {\n        println!("Key: {:?}, Value: {:?}", k, v);\n        Ok(())\n    })?;\n\n    // Convert to a Rust HashMap (if keys and values are convertible)\n    let map: std::collections::HashMap<String, String> = hash.to_hash()?;\n\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"handling-nil-values",children:"Handling nil Values"}),"\n",(0,s.jsxs)(e.p,{children:["Ruby's ",(0,s.jsx)(e.code,{children:"nil"})," is a special value that requires careful handling:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use magnus::{Value, Ruby, RNil};\n\nfn handle_nil(ruby: &Ruby, val: Value) -> Result<(), magnus::Error> {\n    // Check if a value is nil\n    if val.is_nil() {\n        println!("Value is nil");\n    }\n\n    // Get nil\n    let nil = ruby.nil();\n\n    // Options and nil\n    let maybe_string: Option<String> = val.try_convert()?;\n    match maybe_string {\n        Some(s) => println!("Got string: {}", s),\n        None => println!("No string (was nil or couldn\'t convert)"),\n    }\n\n    // Explicitly return nil from a function\n    fn returns_nil() -> RNil {\n        RNil::get()\n    }\n\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"converting-between-ruby-and-rust-types",children:"Converting Between Ruby and Rust Types"}),"\n",(0,s.jsx)(e.p,{children:"Magnus provides powerful type conversion traits that make it easy to convert between Ruby and Rust types."}),"\n",(0,s.jsx)(e.h3,{id:"from-rust-to-ruby-tryconvert",children:"From Rust to Ruby (TryConvert)"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use magnus::{Value, Ruby, TryConvert, Error};\n\n// Convert custom Rust types to Ruby objects\nstruct Person {\n    name: String,\n    age: u32,\n}\n\nimpl TryConvert for Person {\n    fn try_convert(val: Value) -> Result<Self, Error> {\n        let ruby = unsafe { Ruby::get_unchecked() };\n        let hash = RHash::try_convert(val)?;\n\n        let name: String = hash.get(ruby, "name")?;\n        let age: u32 = hash.get(ruby, "age")?;\n\n        Ok(Person { name, age })\n    }\n}\n\n// Usage\nfn process_person(val: Value) -> Result<(), Error> {\n    let person: Person = val.try_convert()?;\n    println!("Person: {} ({})", person.name, person.age);\n    Ok(())\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"from-ruby-to-rust-intovalue",children:"From Ruby to Rust (IntoValue)"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use magnus::{Value, Ruby, IntoValue, Error};\n\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\nimpl IntoValue for Point {\n    fn into_value_with(self, ruby: &Ruby) -> Result<Value, Error> {\n        let hash = RHash::new(ruby);\n        hash.aset(ruby, "x", self.x)?;\n        hash.aset(ruby, "y", self.y)?;\n        Ok(hash.as_value())\n    }\n}\n\n// Usage\nfn create_point(ruby: &Ruby) -> Result<Value, Error> {\n    let point = Point { x: 10.5, y: 20.7 };\n    point.into_value_with(ruby)\n}\n'})}),"\n",(0,s.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Always Handle Errors"}),": Type conversions can fail, wrap them in proper error handling."]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Use try_convert"}),": Prefer ",(0,s.jsx)(e.code,{children:"try_convert"})," over direct conversions to safely handle type mismatches."]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Remember Boxing Rules"}),": All Ruby objects are reference types, while many Rust types are value types."]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Be Careful with Magic Methods"}),": Some Ruby methods like ",(0,s.jsx)(e.code,{children:"method_missing"})," might not behave as expected when called from Rust."]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Cache Ruby Objects"}),": If you're repeatedly using the same Ruby objects (like classes or symbols), consider caching them using ",(0,s.jsx)(e.code,{children:"Lazy"})," or similar mechanisms."]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Check for nil"}),": Always check for nil values before attempting conversions that don't handle nil."]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Use Type Annotations"}),": Explicitly specifying types when converting Ruby values to Rust can make your code clearer and avoid potential runtime errors."]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Pass Ruby State"}),": Always pass the ",(0,s.jsx)(e.code,{children:"Ruby"})," instance through your functions when needed rather than using ",(0,s.jsx)(e.code,{children:"Ruby::get()"})," repeatedly, as this is more performant and clearer about dependencies."]}),"\n"]}),"\n"]})]})}function y(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(h,{...n})}):h(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>a,x:()=>l});var r=t(6540);const s={},i=r.createContext(s);function a(n){const e=r.useContext(i);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:a(n.components),r.createElement(i.Provider,{value:e},n.children)}}}]);