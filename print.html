<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Ruby on Rust Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="A comprehensive guide to building Ruby extensions with Rust using rb-sys">
        <meta name="keywords" content="ruby, rust, ffi, bindings, rb-sys, ruby on rust">
        <meta name="author" content="">
        
        <!-- Open Graph / Facebook -->
        <meta property="og:type" content="website">
        <meta property="og:url" content="">
        <meta property="og:title" content="The Ruby on Rust Book">
        <meta property="og:description" content="A comprehensive guide to building Ruby extensions with Rust using rb-sys">
        
        <!-- Twitter -->
        <meta property="twitter:card" content="summary_large_image">
        <meta property="twitter:url" content="">
        <meta property="twitter:title" content="The Ruby on Rust Book">
        <meta property="twitter:description" content="A comprehensive guide to building Ruby extensions with Rust using rb-sys">
        
        <!-- Canonical URL -->
        <link rel="canonical" href="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Ruby on Rust Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/oxidize-rb/rb-sys" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the rb-sys guide. This book will show you how to build Ruby extensions in Rust that are both powerful and
reliable.</p>
<p>The primary goal of <code>rb-sys</code> is to make building native Ruby extensions in Rust <strong>easier</strong> than it would be in C. If
it's not easy, it's a bug.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li>Battle-tested Rust bindings for the Ruby C API</li>
<li>Support for Ruby 2.6+</li>
<li>Support for all major platforms (Linux, macOS, Windows)</li>
<li>Cross-compilation support for gems</li>
<li>Integration with <code>rake-compiler</code></li>
<li>Test helpers for Ruby extensions</li>
</ul>
<h2 id="why-rust-for-ruby-extensions"><a class="header" href="#why-rust-for-ruby-extensions">Why Rust for Ruby Extensions?</a></h2>
<p>Ruby extensions have traditionally been written in C, requiring manual memory management and careful handling of Ruby's
internals. This approach is error-prone and often results in security vulnerabilities, memory leaks, and crashes.</p>
<div class="note">
<p>While C extensions offer flexibility and minimal dependencies, Rust extensions provide a superior developer experience
with improved safety guarantees and access to a rich ecosystem of libraries.</p>
</div>
<p>Rust offers a compelling alternative with several advantages:</p>
<ul>
<li><strong>Memory safety without garbage collection</strong></li>
<li><strong>Strong type system that catches errors at compile time</strong></li>
<li><strong>Modern language features like pattern matching and traits</strong></li>
<li><strong>Access to the vast Rust ecosystem via crates.io</strong></li>
<li><strong>Strong tooling for testing, documentation, and deployment</strong></li>
</ul>
<div class="warning">
<p>Importantly, performance should not be the sole motivation for using Rust. With Ruby's YJIT compiler, pure Ruby code is
now faster than ever. Instead, consider Rust when you need memory safety, type safety, or want to leverage the rich Rust
ecosystem's capabilities.</p>
</div>
<h2 id="the-rb-sys-project-ecosystem"><a class="header" href="#the-rb-sys-project-ecosystem">The rb-sys Project Ecosystem</a></h2>
<p>rb-sys consists of several components working together:</p>
<ol>
<li><strong>rb-sys crate</strong>: Provides low-level Rust bindings to Ruby's C API</li>
<li><strong>rb_sys gem</strong>: Handles the Ruby side of extension compilation</li>
<li><strong>Magnus</strong>: A higher-level, ergonomic API for Rust/Ruby interoperability</li>
<li><strong>rb-sys-dock</strong>: Docker-based cross-compilation tooling</li>
<li><strong>GitHub Actions</strong>: Setup and cross-compilation automation for CI workflows</li>
</ol>
<div class="tip">
<p>Most developers will use the Magnus API when building their extensions, as it provides a much more ergonomic interface
than using rb-sys directly.</p>
</div>
<p>Here's how these components interact when building a typical Ruby gem with Rust:</p>
<pre><code class="language-diagram hidelines=~">Your Ruby Code (.rb files)
       ↓
  Your Rust Code (.rs files)
       ↓
<span class="boring">   Magnus API
</span>       ↓
<span class="boring">  rb-sys crate
</span>       ↓
<span class="boring">Ruby C API Bindings
</span>       ↓
<span class="boring">  Ruby VM
</span></code></pre>
<p>During compilation:</p>
<pre><code class="language-diagram hidelines=~"><span class="boring">  Your gem's extconf.rb
</span>       ↓
<span class="boring">  rb_sys gem's create_rust_makefile
</span>       ↓
<span class="boring">  Cargo build process using rb-sys crate
</span>       ↓
<span class="boring">  Native extension (.so/.bundle/.dll)
</span></code></pre>
<p>You can click the eye icon (<i class="fa fa-eye"></i>) to see the hidden details in these diagrams.</p>
<h2 id="comparison-with-traditional-c-extensions"><a class="header" href="#comparison-with-traditional-c-extensions">Comparison with Traditional C Extensions</a></h2>
<p>Let's compare writing extensions in Rust versus C:</p>
<div class="table-wrapper"><table><thead><tr><th>Aspect</th><th>C Extensions</th><th>Rust Extensions</th></tr></thead><tbody>
<tr><td><strong>Memory Safety</strong></td><td>Manual memory management</td><td>Guaranteed memory safety at compile time</td></tr>
<tr><td><strong>Type Safety</strong></td><td>Weak typing, runtime errors</td><td>Strong static typing, compile-time checks</td></tr>
<tr><td><strong>API Ergonomics</strong></td><td>Low-level C API</td><td>High-level Magnus API</td></tr>
<tr><td><strong>Development Speed</strong></td><td>Slower, more error-prone</td><td>Faster, safer development cycle</td></tr>
<tr><td><strong>Ecosystem Access</strong></td><td>Limited to C libraries</td><td>Full access to Rust crates</td></tr>
<tr><td><strong>Debugging</strong></td><td>Harder to debug memory issues</td><td>Easier to debug with Rust's safety guarantees</td></tr>
<tr><td><strong>Cross-Compilation</strong></td><td>Complex manual configuration</td><td>Simplified with rb-sys-dock</td></tr>
</tbody></table>
</div>
<p>While C extensions offer flexibility and minimal dependencies, Rust extensions provide a superior developer experience
with improved safety guarantees and access to a rich ecosystem of libraries.</p>
<h2 id="real-world-examples"><a class="header" href="#real-world-examples">Real-World Examples</a></h2>
<p>These gems demonstrate rb-sys in action:</p>
<ul>
<li><a href="https://github.com/yoshoku/lz4-ruby">lz4-ruby</a> - LZ4 compression library with rb-sys</li>
<li><a href="https://github.com/bytecodealliance/wasmtime-rb">wasmtime-rb</a> - WebAssembly runtime with rb-sys and Magnus</li>
<li><a href="https://github.com/oxidize-rb/oxi-test">oxi-test</a> - Canonical example of how to use rb-sys (minimal, fully tested,
cross-compiled)</li>
<li><a href="https://github.com/oxidize-rb/blake3-ruby">blake3-ruby</a> - Fast cryptographic hash function with full cross-platform
support</li>
</ul>
<h2 id="supported-toolchains"><a class="header" href="#supported-toolchains">Supported Toolchains</a></h2>
<ul>
<li>Ruby: 2.6+ (for full compatibility with Rubygems)</li>
<li>Rust: 1.65+</li>
</ul>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>To build a Ruby extension in Rust, you'll need:</p>
<ul>
<li>Ruby development headers (usually part of ruby-dev packages)</li>
<li>Rust (via rustup)</li>
<li>libclang (for bindgen)
<ul>
<li>On macOS: <code>brew install llvm</code></li>
<li>On Linux: <code>apt-get install libclang-dev</code></li>
</ul>
</li>
</ul>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<p>If you have questions, please join our <a href="https://join.slack.com/t/oxidize-rb/shared_invite/zt-16zv5tqte-Vi7WfzxCesdo2TqF_RYBCw">Slack channel</a> or <a href="https://github.com/oxidize-rb/rb-sys/issues">open an issue on GitHub</a>.</p>
<h2 id="contributing-to-this-book"><a class="header" href="#contributing-to-this-book">Contributing to this book</a></h2>
<p>This book is open source! Find a typo? Did we overlook something? <a href="https://github.com/oxidize-rb/rb-sys"><strong>Send us a pull request!</strong></a>. Help wanted!</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>rb-sys is licensed under either:</p>
<ul>
<li>Apache License, Version 2.0</li>
<li>MIT license</li>
</ul>
<p>at your option.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li>Proceed to <a href="getting-started.html">Getting Started</a> to set up your development environment.</li>
<li>Try the <a href="quick-start.html">Quick Start</a> to build your first extension.</li>
<li>Explore core concepts in <a href="build-process.html">Build Process</a> and <a href="memory-management.html">Memory Management &amp; Safety</a>.</li>
<li>Learn advanced topics like <a href="cross-platform.html">Cross-Platform Development</a> and <a href="testing.html">Testing Extensions</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prerequisites-and-installation"><a class="header" href="#prerequisites-and-installation">Prerequisites and Installation</a></h1>
<p>This chapter provides a streamlined setup guide for building Ruby extensions with Rust.</p>
<h2 id="tldr"><a class="header" href="#tldr">TL;DR</a></h2>
<h3 id="1-install-prerequisites"><a class="header" href="#1-install-prerequisites">1. Install Prerequisites</a></h3>
<pre><code class="language-bash"># Install Ruby (3.0+ recommended)
# Using your preferred manager: rbenv, rvm, asdf, etc.

# Install Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Install rb_sys gem
gem install rb_sys
</code></pre>
<h3 id="2-create-a-new-gem-with-rust-extension"><a class="header" href="#2-create-a-new-gem-with-rust-extension">2. Create a New Gem with Rust Extension</a></h3>
<pre><code class="language-bash"># Generate a new gem with Rust extension support
bundle gem --ext=rust mygem
cd mygem

# Build the extension
bundle install
bundle exec rake compile

# Try it out
bundle exec rake
</code></pre>
<p>That's it! You now have a working Ruby gem with Rust extension.</p>
<h2 id="detailed-installation"><a class="header" href="#detailed-installation">Detailed Installation</a></h2>
<p>If you encounter issues with the quick start above, here are the detailed requirements:</p>
<h3 id="ruby-requirements"><a class="header" href="#ruby-requirements">Ruby Requirements</a></h3>
<ul>
<li>Ruby 3.0+ recommended (2.6+ supported)</li>
<li>Ruby development headers (usually part of official packages)</li>
<li>Bundler (<code>gem install bundler</code>)</li>
</ul>
<h3 id="rust-requirements"><a class="header" href="#rust-requirements">Rust Requirements</a></h3>
<ul>
<li>Rust 1.65.0+ via <a href="https://rustup.rs/">rustup</a></li>
<li>Make sure Cargo is in your PATH (typically <code>~/.cargo/bin</code>)</li>
</ul>
<h3 id="c-compiler-requirements"><a class="header" href="#c-compiler-requirements">C Compiler Requirements</a></h3>
<ul>
<li><strong>macOS</strong>: Xcode Command Line Tools (<code>xcode-select --install</code>)</li>
<li><strong>Linux</strong>: build-essential (Debian/Ubuntu) or Development Tools (Fedora/RHEL)</li>
<li><strong>Windows</strong>: Microsoft Visual Studio C++ Build Tools</li>
</ul>
<h3 id="libclang-for-rubyrust-ffi-bindings"><a class="header" href="#libclang-for-rubyrust-ffi-bindings">libclang (for Ruby/Rust FFI bindings)</a></h3>
<p>Simplest approach: add to your Gemfile</p>
<pre><code class="language-ruby">gem "libclang", "~&gt; 14.0"
</code></pre>
<h2 id="verifying-your-setup"><a class="header" href="#verifying-your-setup">Verifying Your Setup</a></h2>
<p>The simplest way to verify your setup is to create a test gem:</p>
<pre><code class="language-bash">bundle gem --ext=rust hello_rusty
cd hello_rusty
bundle install
bundle exec rake compile
bundle exec rake test
</code></pre>
<p>If everything runs without errors, your environment is correctly set up.</p>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<p>If you encounter issues:</p>
<ol>
<li><strong>Missing libclang</strong>: Add the <code>libclang</code> gem to your Gemfile</li>
<li><strong>Missing C compiler</strong>: Install appropriate build tools for your platform</li>
<li><strong>Ruby headers not found</strong>: Install Ruby development package</li>
</ol>
<p>For detailed troubleshooting, consult the <a href="https://github.com/oxidize-rb/rb-sys/wiki/Troubleshooting">rb-sys wiki</a>.</p>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li>Validate your setup with the <a href="quick-start.html">Quick Start</a>.</li>
<li>Dive into <a href="build-process.html">Build Process</a> for deeper compilation insights.</li>
<li>Explore <a href="project-setup.html">Project Setup</a> patterns.</li>
<li>Learn <a href="testing.html">Testing Extensions</a> to add tests.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start-your-first-extension"><a class="header" href="#quick-start-your-first-extension">Quick Start: Your First Extension</a></h1>
<p>This chapter shows you how to create a Ruby gem with a Rust extension using Bundler's built-in Rust support.</p>
<h2 id="creating-a-gem-with-bundler"><a class="header" href="#creating-a-gem-with-bundler">Creating a Gem with Bundler</a></h2>
<p>The easiest way to create a new gem with a Rust extension is with Bundler:</p>
<pre><code class="language-bash"># Create a new gem with a Rust extension
bundle gem --ext=rust hello_rusty
cd hello_rusty
</code></pre>
<p>This command generates everything you need to build a Ruby gem with a Rust extension.</p>
<h2 id="understanding-the-generated-files"><a class="header" href="#understanding-the-generated-files">Understanding the Generated Files</a></h2>
<p>Let's examine the key files Bundler created:</p>
<pre><code>hello_rusty/
├── ext/hello_rusty/          # Rust extension directory
│   ├── Cargo.toml            # Rust dependencies
│   ├── extconf.rb            # Ruby extension config
│   └── src/lib.rs            # Rust code
├── lib/hello_rusty.rb        # Main Ruby file
└── hello_rusty.gemspec       # Gem specification
</code></pre>
<h3 id="the-rust-code-librs"><a class="header" href="#the-rust-code-librs">The Rust Code (lib.rs)</a></h3>
<p>Bundler generates a simple "Hello World" implementation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">// ext/hello_rusty/src/lib.rs
</span>use magnus::{define_module, function, prelude::*, Error};

#[magnus::init]
fn init() -&gt; Result&lt;(), Error&gt; {
    let module = define_module("HelloRusty")?;
    module.define_singleton_method("hello", function!(|| "Hello from Rust!", 0))?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<div class="note">
<p>You can click the "play" button on code blocks to try them out in the Rust Playground where appropriate. For code that
depends on the Ruby API, you won't be able to run it directly, but you can experiment with Rust syntax and standard
library functions.</p>
</div>
<h3 id="the-extension-configuration-extconfrb"><a class="header" href="#the-extension-configuration-extconfrb">The Extension Configuration (extconf.rb)</a></h3>
<pre><code class="language-ruby"># ext/hello_rusty/extconf.rb
require "mkmf"
require "rb_sys/mkmf"

create_rust_makefile("hello_rusty/hello_rusty")
</code></pre>
<p>This file connects Ruby's build system to Cargo.</p>
<h2 id="enhancing-the-default-implementation"><a class="header" href="#enhancing-the-default-implementation">Enhancing the Default Implementation</a></h2>
<p>Let's improve the default implementation by adding a simple class:</p>
<pre><code class="language-rust noplayground hidelines=#"><span class="boring">// This is our enhanced implementation
</span>use magnus::{define_module, define_class, function, method, prelude::*, Error, Ruby};

// Define a struct to hold state
struct Greeter {
    name: String,
}

// Implement Ruby wrapper for the struct
#[magnus::wrap(class = "HelloRusty::Greeter")]
impl Greeter {
    // Constructor
    fn new(name: String) -&gt; Self {
        Greeter { name }
    }

    // Instance method
    fn greet(&amp;self) -&gt; String {
        format!("Hello, {}!", self.name)
    }
}

<span class="boring">// Let's also add a method that takes a parameter
</span><span class="boring">impl Greeter {
</span><span class="boring">    fn greet_with_prefix(&amp;self, prefix: String) -&gt; String {
</span><span class="boring">        format!("{} Hello, {}!", prefix, self.name)
</span><span class="boring">    }
</span><span class="boring">}
</span>
// Module initialization function
#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let module = ruby.define_module("HelloRusty")?;

    // Define and configure the Greeter class
    let class = module.define_class("Greeter", ruby.class_object())?;
    class.define_singleton_method("new", function!(Greeter::new, 1))?;
    class.define_method("greet", method!(Greeter::greet, 0))?;

<span class="boring">    // We could also expose the additional method
</span><span class="boring">    // class.define_method("greet_with_prefix", method!(Greeter::greet_with_prefix, 1))?;
</span>
    Ok(())
}</code></pre>
<div class="tip">
<p>Click the eye icon (<i class="fa fa-eye"></i>) to reveal commented lines with additional functionality that you could
add to your implementation.</p>
</div>
<h2 id="building-and-testing"><a class="header" href="#building-and-testing">Building and Testing</a></h2>
<h3 id="compile-the-extension"><a class="header" href="#compile-the-extension">Compile the Extension</a></h3>
<pre><code class="language-bash"># Install dependencies and compile
bundle install
bundle exec rake compile
</code></pre>
<p>What happens during compilation:</p>
<ol>
<li>Ruby's <code>mkmf</code> reads your <code>extconf.rb</code></li>
<li><code>create_rust_makefile</code> generates a Makefile with Cargo commands</li>
<li>Cargo compiles your Rust code to a dynamic library</li>
<li>The binary is copied to <code>lib/hello_rusty/hello_rusty.{so,bundle,dll}</code></li>
</ol>
<h3 id="run-the-tests"><a class="header" href="#run-the-tests">Run the Tests</a></h3>
<p>Bundler generates a basic test file. Let's update it:</p>
<pre><code class="language-ruby hidelines=#"><span class="boring"> test/test_hello_rusty.rb
</span>require "test_helper"

class TestHelloRusty &lt; Minitest::Test
  def test_that_it_has_a_version_number
    refute_nil ::HelloRusty::VERSION
  end

  def test_greeter
    greeter = HelloRusty::Greeter.new("Rustacean")
    assert_equal "Hello, Rustacean!", greeter.greet
  end

<span class="boring">   # If we implemented the additional method, we could test it
</span><span class="boring">   def test_greeter_with_prefix
</span><span class="boring">     greeter = HelloRusty::Greeter.new("Rustacean")
</span><span class="boring">     assert_equal "Howdy! Hello, Rustacean!", greeter.greet_with_prefix("Howdy!")
</span><span class="boring">   end
</span>end
</code></pre>
<p>Run the tests:</p>
<pre><code class="language-bash hidelines=#"><span class="boring"> Run the standard test suite
</span>bundle exec rake test

<span class="boring"> You can also run specific tests
</span><span class="boring"> bundle exec ruby -Ilib:test test/test_hello_rusty.rb -n test_greeter
</span></code></pre>
<h3 id="try-it-in-the-console"><a class="header" href="#try-it-in-the-console">Try It in the Console</a></h3>
<pre><code class="language-bash hidelines=#"><span class="boring"> Start the console
</span>bundle exec bin/console

<span class="boring"> You can also use irb directly
</span><span class="boring"> bundle exec irb -Ilib -rhello_rusty
</span></code></pre>
<p>Once in the console, you can interact with your extension:</p>
<pre><code class="language-ruby hidelines=#"><span class="boring"> Create a new greeter object
</span>greeter = HelloRusty::Greeter.new("World")

<span class="boring"> Call the greet method
</span>puts greeter.greet  # =&gt; "Hello, World!"

<span class="boring"> # If you added the additional method, you could call it
</span><span class="boring"> puts greeter.greet_with_prefix("Howdy!")  # =&gt; "Howdy! Hello, World!"
</span></code></pre>
<h2 id="customizing-the-build"><a class="header" href="#customizing-the-build">Customizing the Build</a></h2>
<p>You can customize the build process with environment variables:</p>
<pre><code class="language-bash hidelines=#"><span class="boring"> Release build (optimized)
</span>RB_SYS_CARGO_PROFILE=release bundle exec rake compile

<span class="boring"> With specific Cargo features
</span>RB_SYS_CARGO_FEATURES=feature1,feature2 bundle exec rake compile

<span class="boring"> You can also combine variables
</span><span class="boring"> RB_SYS_CARGO_PROFILE=release RB_SYS_CARGO_FEATURES=feature1 bundle exec rake compile
</span>
<span class="boring"> For more verbose output
</span><span class="boring"> RB_SYS_CARGO_VERBOSE=1 bundle exec rake compile
</span></code></pre>
<div class="warning">
<p>Remember that building in release mode will produce optimized, faster code but will increase compilation time.</p>
</div>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>Congratulations! You've created a Ruby gem with a Rust extension. In the next chapters, we'll explore:</p>
<ul>
<li>Better project organization</li>
<li>Working with Ruby objects in Rust</li>
<li>Memory management and safety</li>
<li>Performance optimization</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h1>
<p>In this chapter, we'll explore how to set up and organize a Ruby gem with a Rust extension. We'll focus on practical
patterns and highlight how to leverage valuable Rust libraries without introducing unnecessary complexity.</p>
<h2 id="enhanced-project-structure"><a class="header" href="#enhanced-project-structure">Enhanced Project Structure</a></h2>
<p>Building on the structure created by <code>bundle gem --ext=rust</code>, a well-organized rb-sys project typically looks like this:</p>
<pre><code>my_gem/
├── Cargo.toml                # Rust workspace configuration
├── Gemfile                   # Ruby dependencies
├── Rakefile                  # Build tasks
├── my_gem.gemspec            # Gem specification
├── ext/
│   └── my_gem/
│       ├── Cargo.toml        # Rust crate configuration
│       ├── extconf.rb        # Ruby extension configuration
│       └── src/
│           └── lib.rs        # Main Rust entry point
├── lib/
│   ├── my_gem.rb             # Main Ruby file
│   └── my_gem/
│       └── version.rb        # Version information
└── test/                     # Tests
</code></pre>
<p>Let's examine a practical example using a useful but simple Rust library.</p>
<h2 id="example-url-parsing-with-the-url-crate"><a class="header" href="#example-url-parsing-with-the-url-crate">Example: URL Parsing with the <code>url</code> crate</a></h2>
<p>The <a href="https://crates.io/crates/url">url</a> crate, developed by the Servo team, is a robust implementation of the URL
Standard. It provides accurate URL parsing that would be complex to implement from scratch. Here's a simple example:</p>
<h3 id="1-extension-cargotoml"><a class="header" href="#1-extension-cargotoml">1. Extension Cargo.toml</a></h3>
<pre><code class="language-toml"># ext/url_parser/Cargo.toml
[package]
name = "url_parser"
version = "0.1.0"
edition = "2021"
authors = ["Your Name &lt;your.email@example.com&gt;"]
license = "MIT"
publish = false

[lib]
crate-type = ["cdylib"]

[dependencies]
# High-level Ruby bindings with rb-sys feature
magnus = { version = "0.7", features = ["rb-sys"] }

# The main Rust library we're wrapping
url = "2.4"

[build-dependencies]
rb-sys-env = "0.1"
</code></pre>
<h3 id="2-main-rust-implementation"><a class="header" href="#2-main-rust-implementation">2. Main Rust Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ext/url_parser/src/lib.rs
use magnus::{define_module, define_class, function, method, prelude::*, Error, Ruby};
use url::Url;

// Simple URL wrapper class
struct UrlWrapper {
    inner: Url,
}

#[magnus::wrap(class = "UrlParser::URL")]
impl UrlWrapper {
    // Parse a URL string
    fn parse(url_str: String) -&gt; Result&lt;Self, Error&gt; {
        match Url::parse(&amp;url_str) {
            Ok(url) =&gt; Ok(UrlWrapper { inner: url }),
            Err(err) =&gt; {
                Err(Error::new(magnus::exception::arg_error(), format!("Invalid URL: {}", err)))
            }
        }
    }

    // Basic getters
    fn scheme(&amp;self) -&gt; String {
        self.inner.scheme().to_string()
    }

    fn host(&amp;self) -&gt; Option&lt;String&gt; {
        self.inner.host_str().map(|s| s.to_string())
    }

    fn path(&amp;self) -&gt; String {
        self.inner.path().to_string()
    }

    fn query(&amp;self) -&gt; Option&lt;String&gt; {
        self.inner.query().map(|s| s.to_string())
    }

    // String representation of the URL
    fn to_string(&amp;self) -&gt; String {
        self.inner.to_string()
    }
}

// Module-level utilities
fn is_valid_url(url_str: String) -&gt; bool {
    Url::parse(&amp;url_str).is_ok()
}

// Module init function - Ruby extension entry point
#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    // Define the main module
    let module = ruby.define_module("UrlParser")?;

    // Add utility function at module level
    module.define_singleton_method("valid_url?", function!(is_valid_url, 1))?;

    // Define and configure the URL class
    let class = module.define_class("URL", ruby.class_object())?;
    class.define_singleton_method("parse", function!(UrlWrapper::parse, 1))?;

    // Instance methods
    class.define_method("scheme", method!(UrlWrapper::scheme, 0))?;
    class.define_method("host", method!(UrlWrapper::host, 0))?;
    class.define_method("path", method!(UrlWrapper::path, 0))?;
    class.define_method("query", method!(UrlWrapper::query, 0))?;
    class.define_method("to_s", method!(UrlWrapper::to_string, 0))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-ruby-integration"><a class="header" href="#3-ruby-integration">3. Ruby Integration</a></h3>
<pre><code class="language-ruby"># lib/url_parser.rb
require_relative "url_parser/version"
require_relative "url_parser/url_parser"

module UrlParser
  class Error &lt; StandardError; end

  # Parse a URL string and return a URL object
  def self.parse(url_string)
    URL.parse(url_string)
  rescue =&gt; e
    raise Error, "Failed to parse URL: #{e.message}"
  end

  # Check if a URL has an HTTPS scheme
  def self.https?(url_string)
    return false unless valid_url?(url_string)
    url = parse(url_string)
    url.scheme == "https"
  end
end
</code></pre>
<h3 id="4-simple-tests"><a class="header" href="#4-simple-tests">4. Simple Tests</a></h3>
<pre><code class="language-ruby"># test/test_url_parser.rb
require "test_helper"

class TestUrlParser &lt; Minitest::Test
  def test_basic_url_parsing
    url = UrlParser::URL.parse("https://example.com/path?query=value")

    assert_equal "https", url.scheme
    assert_equal "example.com", url.host
    assert_equal "/path", url.path
    assert_equal "query=value", url.query
  end

  def test_url_validation
    assert UrlParser.valid_url?("https://example.com")
    refute UrlParser.valid_url?("not a url")
  end

  def test_https_check
    assert UrlParser.https?("https://example.com")
    refute UrlParser.https?("http://example.com")
  end

  def test_invalid_url_raises_error
    assert_raises UrlParser::Error do
      UrlParser.parse("not://a.valid/url")
    end
  end
end
</code></pre>
<h2 id="key-aspects-of-this-project"><a class="header" href="#key-aspects-of-this-project">Key Aspects of this Project</a></h2>
<h3 id="1-simplicity-with-value"><a class="header" href="#1-simplicity-with-value">1. Simplicity with Value</a></h3>
<p>This example demonstrates how to:</p>
<ul>
<li>Wrap a useful Rust library (<code>url</code>) with minimal code</li>
<li>Expose only the most essential functionality</li>
<li>Handle errors properly</li>
<li>Integrate with Ruby idiomatically</li>
</ul>
<h3 id="2-why-use-rust-for-url-parsing"><a class="header" href="#2-why-use-rust-for-url-parsing">2. Why Use Rust for URL Parsing?</a></h3>
<p>Ruby has URI handling in its standard library, but the Rust <code>url</code> crate offers advantages:</p>
<ul>
<li>Full compliance with the URL standard used by browsers</li>
<li>Better handling of internationalized domain names (IDNs)</li>
<li>Robust error detection</li>
<li>Significant performance benefits for URL-heavy applications</li>
</ul>
<h3 id="3-project-organization-principles"><a class="header" href="#3-project-organization-principles">3. Project Organization Principles</a></h3>
<ul>
<li><strong>Keep dependencies minimal</strong>: Just what you need, nothing more</li>
<li><strong>Clean public API</strong>: Expose only what users need</li>
<li><strong>Proper error handling</strong>: Map Rust errors to meaningful Ruby exceptions</li>
<li><strong>Simple tests</strong>: Verify both functionality and edge cases</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anatomy-of-a-rusty-ruby-gem-hello_rusty"><a class="header" href="#anatomy-of-a-rusty-ruby-gem-hello_rusty">Anatomy of a Rusty Ruby Gem: hello_rusty</a></h1>
<p>This documentation provides a comprehensive walkthrough of the <code>hello_rusty</code> gem, a simple but complete Ruby gem that
uses Rust for its native extension. This example demonstrates the key components of creating a Ruby gem with Rust using
rb-sys and magnus.</p>
<h2 id="project-structure-1"><a class="header" href="#project-structure-1">Project Structure</a></h2>
<p>A properly structured Rusty Ruby Gem follows the standard Ruby gem conventions with the addition of Rust-specific
elements. Here's the structure of the <code>hello_rusty</code> gem:</p>
<pre><code>hello_rusty/
├── bin/                      # Executable files
├── ext/                      # Native extension code
│   └── hello_rusty/          # The Rust extension directory
│       ├── Cargo.toml        # Rust package manifest
│       ├── extconf.rb        # Ruby extension configuration
│       └── src/
│           └── lib.rs        # Rust implementation
├── lib/                      # Ruby code
│   ├── hello_rusty.rb        # Main Ruby file
│   └── hello_rusty/
│       └── version.rb        # Version definition
├── sig/                      # RBS type signatures
│   └── hello_rusty.rbs       # Type definitions
├── test/                     # Test files
│   ├── test_hello_rusty.rb   # Test for the gem
│   └── test_helper.rb        # Test setup
├── Cargo.lock                # Rust dependency lock file
├── Cargo.toml                # Workspace-level Rust config (optional)
├── Gemfile                   # Ruby dependencies
├── LICENSE.txt               # License file
├── Rakefile                  # Build tasks
├── README.md                 # Documentation
└── hello_rusty.gemspec       # Gem specification
</code></pre>
<h2 id="key-components"><a class="header" href="#key-components">Key Components</a></h2>
<h3 id="1-ruby-components"><a class="header" href="#1-ruby-components">1. Ruby Components</a></h3>
<h4 id="gemspec-hello_rustygemspec"><a class="header" href="#gemspec-hello_rustygemspec">Gemspec (<code>hello_rusty.gemspec</code>)</a></h4>
<p>The gemspec defines metadata about the gem and specifies build requirements:</p>
<pre><code class="language-ruby"># frozen_string_literal: true

require_relative "lib/hello_rusty/version"

Gem::Specification.new do |spec|
  spec.name = "hello_rusty"
  spec.version = HelloRusty::VERSION
  spec.authors = ["Ian Ker-Seymer"]
  spec.email = ["hello@ianks.com"]

  # ... metadata ...

  spec.required_ruby_version = "&gt;= 3.0.0"

  # Files to include in the gem
  spec.files = [...]

  # IMPORTANT: This line tells RubyGems that this gem has a native extension
  # and where to find the build configuration
  spec.extensions = ["ext/hello_rusty/Cargo.toml"]

  spec.require_paths = ["lib"]
end
</code></pre>
<p>Key points:</p>
<ul>
<li>The <code>extensions</code> field points to the Cargo.toml file</li>
<li>Version is defined in a separate Ruby file</li>
<li>Required Ruby version is specified</li>
</ul>
<h4 id="main-ruby-file-libhello_rustyrb"><a class="header" href="#main-ruby-file-libhello_rustyrb">Main Ruby file (<code>lib/hello_rusty.rb</code>)</a></h4>
<pre><code class="language-ruby"># frozen_string_literal: true

require_relative "hello_rusty/version"
require_relative "hello_rusty/hello_rusty"  # Loads the compiled Rust extension

module HelloRusty
  class Error &lt; StandardError; end
  # Additional Ruby code can go here
end
</code></pre>
<p>Key points:</p>
<ul>
<li>Requires the version file</li>
<li>Requires the compiled native extension</li>
<li>Defines a module matching the Rust module</li>
</ul>
<h4 id="version-file-libhello_rustyversionrb"><a class="header" href="#version-file-libhello_rustyversionrb">Version file (<code>lib/hello_rusty/version.rb</code>)</a></h4>
<pre><code class="language-ruby"># frozen_string_literal: true

module HelloRusty
  VERSION = "0.1.0"
end
</code></pre>
<h4 id="type-definitions-sighello_rustyrbs"><a class="header" href="#type-definitions-sighello_rustyrbs">Type Definitions (<code>sig/hello_rusty.rbs</code>)</a></h4>
<p>RBS type definitions for better IDE support and type checking:</p>
<pre><code class="language-rbs">module HelloRusty
  VERSION: String
  # Add type signatures for your methods here
end
</code></pre>
<h3 id="2-rust-components"><a class="header" href="#2-rust-components">2. Rust Components</a></h3>
<h4 id="cargo-configuration-exthello_rustycargotoml"><a class="header" href="#cargo-configuration-exthello_rustycargotoml">Cargo Configuration (<code>ext/hello_rusty/Cargo.toml</code>)</a></h4>
<pre><code class="language-toml">[package]
name = "hello_rusty"
version = "0.1.0"
edition = "2021"
authors = ["Ian Ker-Seymer &lt;hello@ianks.com&gt;"]
license = "MIT"
publish = false

[lib]
crate-type = ["cdylib"]  # Outputs a dynamic library

[dependencies]
magnus = { version = "0.6.2" }  # High-level Ruby bindings
</code></pre>
<p>Key points:</p>
<ul>
<li>Uses <code>cdylib</code> crate type to build a dynamic library</li>
<li>Depends on <code>magnus</code> for high-level Ruby bindings</li>
<li>Version should match the Ruby gem version</li>
</ul>
<h4 id="rust-implementation-exthello_rustysrclibrs"><a class="header" href="#rust-implementation-exthello_rustysrclibrs">Rust Implementation (<code>ext/hello_rusty/src/lib.rs</code>)</a></h4>
<p>Here's the actual implementation from our example code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{function, prelude::*, Error, Ruby};

fn hello(subject: String) -&gt; String {
    format!("Hello from Rust, {subject}!")
}

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let module = ruby.define_module("HelloRusty")?;
    module.define_singleton_method("hello", function!(hello, 1))?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<div class="note">
<p>This code is included directly from the example project file. When the source file is updated, this documentation will
automatically reflect those changes.</p>
</div>
<p>Key points:</p>
<ul>
<li>Uses the <code>magnus</code> crate for Ruby integration</li>
<li>The <code>#[magnus::init]</code> macro marks the entry point for the extension</li>
<li>Defines a Ruby module matching the gem name</li>
<li>Exposes the <code>hello</code> Rust function as a Ruby method</li>
</ul>
<h3 id="3-build-system"><a class="header" href="#3-build-system">3. Build System</a></h3>
<h4 id="extension-configuration-exthello_rustyextconfrb"><a class="header" href="#extension-configuration-exthello_rustyextconfrb">Extension Configuration (<code>ext/hello_rusty/extconf.rb</code>)</a></h4>
<pre><code class="language-ruby"># frozen_string_literal: true

require "mkmf"
require "rb_sys/mkmf"

create_rust_makefile("hello_rusty/hello_rusty")
</code></pre>
<p>Key points:</p>
<ul>
<li>Uses <code>rb_sys/mkmf</code> to handle Rust compilation</li>
<li>Creates a makefile for the native extension</li>
</ul>
<h4 id="rakefile-rakefile"><a class="header" href="#rakefile-rakefile">Rakefile (<code>Rakefile</code>)</a></h4>
<p>Here's the actual Rakefile from our example project:</p>
<pre><code class="language-ruby hidelines=#"><span class="boring"> frozen_string_literal: true
</span>
require "bundler/gem_tasks"
require "minitest/test_task"

Minitest::TestTask.create

require "rubocop/rake_task"

RuboCop::RakeTask.new

require "rb_sys/extensiontask"

task build: :compile

GEMSPEC = Gem::Specification.load("hello_rusty.gemspec")

RbSys::ExtensionTask.new("hello_rusty", GEMSPEC) do |ext|
  ext.lib_dir = "lib/hello_rusty"
end

task default: %i[compile test rubocop]

<span class="boring"> You can customize the build further:
</span><span class="boring"> RbSys::ExtensionTask.new("hello_rusty", GEMSPEC) do |ext|
</span><span class="boring">   ext.lib_dir = "lib/hello_rusty"
</span><span class="boring">   ext.cross_compile = true  # Enable cross-compilation
</span><span class="boring">   ext.cross_platform = ['x86_64-linux', 'x86_64-darwin']  # Platforms to target
</span><span class="boring"> end
</span></code></pre>
<div class="tip">
<p>The eye icon (<i class="fa fa-eye"></i>) reveals additional configuration options you can use in your Rakefile.</p>
</div>
<p>Key points:</p>
<ul>
<li>Uses <code>RbSys::ExtensionTask</code> to manage Rust compilation</li>
<li>Sets the output directory to <code>lib/hello_rusty</code></li>
<li>Defines standard tasks for building, testing, and linting</li>
</ul>
<h3 id="4-testing"><a class="header" href="#4-testing">4. Testing</a></h3>
<h4 id="test-file-testtest_hello_rustyrb"><a class="header" href="#test-file-testtest_hello_rustyrb">Test File (<code>test/test_hello_rusty.rb</code>)</a></h4>
<pre><code class="language-ruby"># frozen_string_literal: true

require "test_helper"

class TestHelloRusty &lt; Minitest::Test
  def test_that_it_has_a_version_number
    refute_nil ::HelloRusty::VERSION
  end

  def test_hello
    result = HelloRusty.hello("World")
    assert_equal "Hello from Rust, World!", result
  end
end
</code></pre>
<p>Key points:</p>
<ul>
<li>Tests basic functionality of the gem</li>
<li>Verifies the version is defined</li>
<li>Tests the Rust-implemented <code>hello</code> method</li>
</ul>
<h2 id="build-process"><a class="header" href="#build-process">Build Process</a></h2>
<p>When building a Rusty Ruby Gem, the following steps occur:</p>
<ol>
<li><code>rake compile</code> is run (either directly or through <code>rake build</code>)</li>
<li>The <code>RbSys::ExtensionTask</code> processes the extension:
<ul>
<li>It reads the <code>ext/hello_rusty/Cargo.toml</code> file</li>
<li>It sets up the appropriate build environment</li>
<li>It runs <code>cargo build</code> with the appropriate options</li>
<li>It copies the resulting <code>.so</code>/<code>.bundle</code>/<code>.dll</code> to <code>lib/hello_rusty/</code></li>
</ul>
</li>
<li>The compiled binary is then packaged into the gem</li>
</ol>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Once installed, this gem can be used in Ruby code as follows:</p>
<pre><code class="language-ruby">require "hello_rusty"

# Call the Rust-implemented method
greeting = HelloRusty.hello("Rusty Rubyist")
puts greeting  # =&gt; "Hello from Rust, Rusty Rubyist!"
</code></pre>
<h2 id="key-concepts-demonstrated"><a class="header" href="#key-concepts-demonstrated">Key Concepts Demonstrated</a></h2>
<ol>
<li><strong>Module Structure</strong>: The gem defines a Ruby module that's implemented in Rust</li>
<li><strong>Function Exposure</strong>: Rust functions are exposed as Ruby methods</li>
<li><strong>Type Conversion</strong>: Rust handles string conversion automatically through magnus</li>
<li><strong>Error Handling</strong>: The Rust code uses <code>Result&lt;T, Error&gt;</code> for Ruby-compatible error handling</li>
<li><strong>Build Integration</strong>: The gem uses rb-sys to integrate with Ruby's build system</li>
<li><strong>Testing</strong>: Standard Ruby testing tools work with the Rust-implemented functionality</li>
</ol>
<h2 id="next-steps-for-expansion"><a class="header" href="#next-steps-for-expansion">Next Steps for Expansion</a></h2>
<p>To expand this basic example, you could:</p>
<ol>
<li>Add Ruby classes backed by Rust structs using TypedData</li>
<li>Implement more complex methods with various argument types</li>
<li>Add error handling with custom Ruby exceptions</li>
<li>Use the Ruby GVL (Global VM Lock) for thread safety</li>
<li>Implement memory management through proper object marking</li>
<li>Add benchmarks to demonstrate performance characteristics</li>
</ol>
<p>This example provides a solid foundation for understanding the structure and implementation of Rusty Ruby Gems with
rb-sys.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="development-approaches"><a class="header" href="#development-approaches">Development Approaches</a></h1>
<p>When building Ruby extensions with Rust and rb-sys, you have two main approaches to choose from:</p>
<ol>
<li><strong>Direct rb-sys usage</strong>: Working directly with Ruby's C API through the rb-sys bindings</li>
<li><strong>Higher-level wrappers</strong>: Using libraries like Magnus that build on top of rb-sys</li>
</ol>
<p>This chapter will help you understand when to use each approach and how to mix them when needed.</p>
<h2 id="direct-rb-sys-usage"><a class="header" href="#direct-rb-sys-usage">Direct rb-sys Usage</a></h2>
<p>The rb-sys crate provides low-level bindings to Ruby's C API. This approach gives you complete control over how your
Rust code interacts with Ruby.</p>
<h3 id="when-to-use-direct-rb-sys"><a class="header" href="#when-to-use-direct-rb-sys">When to Use Direct rb-sys</a></h3>
<ul>
<li>When you need maximum control over Ruby VM interaction</li>
<li>For specialized extensions that need access to low-level Ruby internals</li>
<li>When performance is absolutely critical and you need to eliminate any overhead</li>
<li>When implementing functionality not yet covered by higher-level wrappers</li>
</ul>
<h3 id="example-simple-extension-with-direct-rb-sys"><a class="header" href="#example-simple-extension-with-direct-rb-sys">Example: Simple Extension with Direct rb-sys</a></h3>
<p>Here's a simple example of a Ruby extension using direct rb-sys:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rb_sys::{
    rb_define_module, rb_define_module_function, rb_str_new_cstr,
    rb_string_value_cstr, VALUE
};
use std::ffi::CString;
use std::os::raw::c_char;

// Helper macro for creating C strings
macro_rules! cstr {
    ($s:expr) =&gt; {
        concat!($s, "\0").as_ptr() as *const c_char
    };
}

// Reverse a string
unsafe extern "C" fn reverse(_: VALUE, s: VALUE) -&gt; VALUE {
    let c_str = rb_string_value_cstr(&amp;s);
    let rust_str = std::ffi::CStr::from_ptr(c_str).to_str().unwrap();
    let reversed = rust_str.chars().rev().collect::&lt;String&gt;();

    let c_string = CString::new(reversed).unwrap();
    rb_str_new_cstr(c_string.as_ptr())
}

// Module initialization function
#[no_mangle]
pub extern "C" fn Init_string_utils() {
    unsafe {
        let module = rb_define_module(cstr!("StringUtils"));

        rb_define_module_function(
            module,
            cstr!("reverse"),
            Some(reverse as unsafe extern "C" fn(VALUE, VALUE) -&gt; VALUE),
            1,
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-rb_thread_call_without_gvl-for-performance"><a class="header" href="#using-rb_thread_call_without_gvl-for-performance">Using rb_thread_call_without_gvl for Performance</a></h3>
<p>When performing computationally intensive operations, it's important to release Ruby's Global VM Lock (GVL) to allow
other threads to run. The <code>rb_thread_call_without_gvl</code> function provides this capability:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{Error, Ruby, RString};
use rb_sys::rb_thread_call_without_gvl;
use std::{ffi::c_void, panic::{self, AssertUnwindSafe}, ptr::null_mut};

/// Execute a function without holding the Global VM Lock (GVL).
/// This allows other Ruby threads to run while performing CPU-intensive tasks.
///
/// # Safety
///
/// The passed function must not interact with the Ruby VM or Ruby objects
/// as it runs without the GVL, which is required for safe Ruby operations.
///
/// # Returns
///
/// Returns the result of the function or a magnus::Error if the function panics.
pub fn nogvl&lt;F, R&gt;(func: F) -&gt; Result&lt;R, Error&gt;
where
    F: FnOnce() -&gt; R,
    R: Send + 'static,
{
    struct CallbackData&lt;F, R&gt; {
        func: Option&lt;F&gt;,
        result: Option&lt;Result&lt;R, String&gt;&gt;, // Store either the result or a panic message
    }

    extern "C" fn call_without_gvl&lt;F, R&gt;(data: *mut c_void) -&gt; *mut c_void
    where
        F: FnOnce() -&gt; R,
        R: Send + 'static,
    {
        // Safety: We know this pointer is valid because we just created it below
        let data = unsafe { &amp;mut *(data as *mut CallbackData&lt;F, R&gt;) };

        // Use take() to move out of the Option, ensuring we don't try to run the function twice
        if let Some(func) = data.func.take() {
            // Use panic::catch_unwind to prevent Ruby process termination if the Rust code panics
            match panic::catch_unwind(AssertUnwindSafe(func)) {
                Ok(result) =&gt; data.result = Some(Ok(result)),
                Err(panic_info) =&gt; {
                    // Convert panic info to a string message
                    let panic_msg = if let Some(s) = panic_info.downcast_ref::&lt;&amp;'static str&gt;() {
                        s.to_string()
                    } else if let Some(s) = panic_info.downcast_ref::&lt;String&gt;() {
                        s.clone()
                    } else {
                        "Unknown panic occurred in Rust code".to_string()
                    };

                    data.result = Some(Err(panic_msg));
                }
            }
        }

        null_mut()
    }

    // Create a data structure to pass the function and receive the result
    let mut data = CallbackData {
        func: Some(func),
        result: None,
    };

    unsafe {
        // Release the GVL and call our function
        rb_thread_call_without_gvl(
            Some(call_without_gvl::&lt;F, R&gt;),
            &amp;mut data as *mut _ as *mut c_void,
            None,  // No unblock function
            null_mut(),
        );
    }

    // Extract the result or create an error if the function failed
    match data.result {
        Some(Ok(result)) =&gt; Ok(result),
        Some(Err(panic_msg)) =&gt; {
            // Convert the panic message to a Ruby RuntimeError
            let ruby = unsafe { Ruby::get_unchecked() };
            Err(Error::new(
                ruby.exception_runtime_error(),
                format!("Rust panic in nogvl: {}", panic_msg)
            ))
        },
        None =&gt; {
            // This should never happen if the callback runs, but handle it anyway
            let ruby = unsafe { Ruby::get_unchecked() };
            Err(Error::new(
                ruby.exception_runtime_error(),
                "nogvl function was not executed"
            ))
        }
    }
}

// For checking large inputs
pub fn nogvl_if_large&lt;F, R&gt;(input_len: usize, func: F) -&gt; Result&lt;R, Error&gt;
where
    F: FnOnce() -&gt; R,
    R: Send + 'static,
{
    const MAX_INPUT_LEN: usize = 8192; // Threshold for using GVL release

    if input_len &gt; MAX_INPUT_LEN {
        nogvl(func)
    } else {
        // If the input is small, just run the function directly
        // but still wrap the result in a Result for consistency
        match panic::catch_unwind(AssertUnwindSafe(func)) {
            Ok(result) =&gt; Ok(result),
            Err(_) =&gt; {
                let ruby = unsafe { Ruby::get_unchecked() };
                Err(Error::new(
                    ruby.exception_runtime_error(),
                    "Rust panic in small input path"
                ))
            }
        }
    }
}

// Example: Using with Magnus API
fn compress(ruby: &amp;Ruby, data: RString) -&gt; Result&lt;RString, Error&gt; {
    let data_bytes = data.as_bytes();
    let data_len = data_bytes.len();

    // Use nogvl_if_large with proper error handling
    let compressed_bytes = nogvl_if_large(data_len, || {
        // CPU-intensive operation here that returns a Vec&lt;u8&gt;
        compression_algorithm(data_bytes)
    })?; // Propagate any errors

    // Create new Ruby string with compressed data
    let result = RString::from_slice(ruby, &amp;compressed_bytes);
    Ok(result)
}

// Example: Registering the method
#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let module = ruby.define_module("Compression")?;

    // Using method! for defining instance methods
    module.define_singleton_method("compress", function!(compress, 1))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="how-direct-rb-sys-works"><a class="header" href="#how-direct-rb-sys-works">How Direct rb-sys Works</a></h3>
<p>When using rb-sys directly:</p>
<ol>
<li>You define C-compatible functions with the <code>extern "C"</code> calling convention</li>
<li>You manually convert between Ruby's <code>VALUE</code> type and Rust types</li>
<li>You're responsible for memory management and type safety</li>
<li>You must use the <code>#[no_mangle]</code> attribute on the initialization function so Ruby can find it</li>
<li>All interactions with Ruby data happen through raw pointers and unsafe code</li>
</ol>
<h2 id="higher-level-wrappers-magnus"><a class="header" href="#higher-level-wrappers-magnus">Higher-level Wrappers (Magnus)</a></h2>
<p>Magnus provides a more ergonomic, Rust-like API on top of rb-sys. It handles many of the unsafe aspects of Ruby
integration for you.</p>
<h3 id="when-to-use-magnus"><a class="header" href="#when-to-use-magnus">When to Use Magnus</a></h3>
<ul>
<li>For most standard Ruby extensions where ease of development is important</li>
<li>When you want to avoid writing unsafe code</li>
<li>When you want idiomatic Rust error handling</li>
<li>For extensions with complex type conversions</li>
<li>When working with Ruby classes and objects in an object-oriented way</li>
</ul>
<h3 id="example-simple-extension-with-magnus"><a class="header" href="#example-simple-extension-with-magnus">Example: Simple Extension with Magnus</a></h3>
<p>Let's look at a simple example using Magnus, based on real-world usage patterns:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{function, prelude::*, Error, Ruby};

fn hello(subject: String) -&gt; String {
    format!("Hello from Rust, {subject}!")
}

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let module = ruby.define_module("StringUtils")?;
    module.define_singleton_method("hello", function!(hello, 1))?;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>Looking at a more complex example from a real-world project (lz4-flex-rb):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{function, prelude::*, Error, RModule, Ruby};

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let module = ruby.define_module("Lz4Flex")?;

    // Define error classes
    let base_error = module.define_error("Error", magnus::exception::standard_error())?;
    let _ = module.define_error("EncodeError", base_error)?;
    let _ = module.define_error("DecodeError", base_error)?;

    // Define methods
    module.define_singleton_method("compress", function!(compress, 1))?;
    module.define_singleton_method("decompress", function!(decompress, 1))?;

    // Define aliases
    module.singleton_class()?.define_alias("deflate", "compress")?;
    module.singleton_class()?.define_alias("inflate", "decompress")?;

    // Define nested module
    let varint_module = module.define_module("VarInt")?;
    varint_module.define_singleton_method("compress", function!(compress_varint, 1))?;
    varint_module.define_singleton_method("decompress", function!(decompress_varint, 1))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="how-magnus-works"><a class="header" href="#how-magnus-works">How Magnus Works</a></h3>
<p>Magnus builds on top of rb-sys and provides:</p>
<ol>
<li>Automatic type conversions between Ruby and Rust</li>
<li>Rust-like error handling with <code>Result</code> types</li>
<li>Memory safety through RAII patterns</li>
<li>More ergonomic APIs for defining modules, classes, and methods</li>
<li>A more familiar development experience for Rust programmers</li>
</ol>
<h2 id="when-to-choose-each-approach"><a class="header" href="#when-to-choose-each-approach">When to Choose Each Approach</a></h2>
<h3 id="choose-direct-rb-sys-when"><a class="header" href="#choose-direct-rb-sys-when">Choose Direct rb-sys When:</a></h3>
<ul>
<li><strong>Performance is absolutely critical</strong>: You need to eliminate every bit of overhead</li>
<li><strong>You need low-level control</strong>: Your extension needs to do things not possible with Magnus</li>
<li><strong>GVL management is important</strong>: You need fine-grained control over when to release the GVL</li>
<li><strong>Compatibility with older Ruby versions</strong>: You need version-specific behavior</li>
</ul>
<h3 id="choose-magnus-when"><a class="header" href="#choose-magnus-when">Choose Magnus When:</a></h3>
<ul>
<li><strong>Developer productivity is important</strong>: You want to write less code</li>
<li><strong>Memory safety is a priority</strong>: You want Rust's safety guarantees</li>
<li><strong>You're working with complex Ruby objects</strong>: You need convenient methods for Ruby class integration</li>
<li><strong>Error handling is complex</strong>: You want to leverage Rust's error handling</li>
</ul>
<h2 id="mixing-approaches"><a class="header" href="#mixing-approaches">Mixing Approaches</a></h2>
<p>You can also mix the two approaches when appropriate. Magnus provides access to the underlying rb-sys functionality when
needed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{function, prelude::*, Error, Ruby};
use rb_sys;
use std::os::raw::c_char;

fn high_level() -&gt; String {
    "High level".to_string()
}

unsafe extern "C" fn low_level(_: rb_sys::VALUE) -&gt; rb_sys::VALUE {
    // Direct rb-sys implementation
    let c_string = std::ffi::CString::new("Low level").unwrap();
    rb_sys::rb_str_new_cstr(c_string.as_ptr())
}

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let module = ruby.define_module("MixedExample")?;

    // Use Magnus for most things
    module.define_singleton_method("high_level", function!(high_level, 0))?;

    // Use rb-sys directly for special cases
    unsafe {
        rb_sys::rb_define_module_function(
            module.as_raw(),
            cstr!("low_level"),
            Some(low_level as unsafe extern "C" fn(rb_sys::VALUE) -&gt; rb_sys::VALUE),
            0,
        );
    }

    Ok(())
}

// Helper macro for C strings
macro_rules! cstr {
    ($s:expr) =&gt; {
        concat!($s, "\0").as_ptr() as *const c_char
    };
}
<span class="boring">}</span></code></pre></pre>
<h3 id="enabling-rb-sys-feature-in-magnus"><a class="header" href="#enabling-rb-sys-feature-in-magnus">Enabling rb-sys Feature in Magnus</a></h3>
<p>To access rb-sys through Magnus, enable the <code>rb-sys</code> feature:</p>
<pre><code class="language-toml"># Cargo.toml
[dependencies]
magnus = { version = "0.7", features = ["rb-sys"] }
</code></pre>
<h3 id="common-mixing-patterns"><a class="header" href="#common-mixing-patterns">Common Mixing Patterns</a></h3>
<ol>
<li>
<p><strong>Use Magnus for most functionality, rb-sys for specific optimizations</strong>:</p>
<ul>
<li>Define your public API using Magnus for safety and ease</li>
<li>Drop down to rb-sys in critical performance paths, especially when using <code>nogvl</code></li>
</ul>
</li>
<li>
<p><strong>Use rb-sys for core functionality, Magnus for complex conversions</strong>:</p>
<ul>
<li>Build core functionality with rb-sys for maximum control</li>
<li>Use Magnus for handling complex Ruby objects or collections</li>
</ul>
</li>
<li>
<p><strong>Start with Magnus, optimize with rb-sys over time</strong>:</p>
<ul>
<li>Begin development with Magnus for rapid progress</li>
<li>Profile your code and replace hot paths with direct rb-sys</li>
</ul>
</li>
</ol>
<h2 id="real-world-examples-1"><a class="header" href="#real-world-examples-1">Real-World Examples</a></h2>
<p>Let's look at how real projects decide between these approaches:</p>
<h3 id="blake3-ruby-direct-rb-sys"><a class="header" href="#blake3-ruby-direct-rb-sys">Blake3-Ruby (Direct rb-sys)</a></h3>
<p>Blake3-Ruby is a cryptographic hashing library that uses direct rb-sys to achieve maximum performance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Based on blake3-ruby
use rb_sys::{
    rb_define_module, rb_define_module_function, rb_string_value_cstr,
    rb_str_new_cstr, VALUE,
};

#[no_mangle]
pub extern "C" fn Init_blake3_ext() {
    unsafe {
        // Create module and class hierarchy
        let digest_module = /* ... */;
        let blake3_class = /* ... */;

        // Define methods directly using rb-sys for maximum performance
        rb_define_module_function(
            blake3_class,
            cstr!("digest"),
            Some(rb_blake3_digest as unsafe extern "C" fn(VALUE, VALUE) -&gt; VALUE),
            1,
        );

        // More method definitions...
    }
}

unsafe extern "C" fn rb_blake3_digest(_klass: VALUE, string: VALUE) -&gt; VALUE {
    // Extract data from Ruby VALUE
    let data_ptr = rb_string_value_cstr(&amp;string);
    let data_len = /* ... */;

    // Release GVL for CPU-intensive operation
    let hash = nogvl(|| {
        blake3::hash(/* ... */)
    });

    // Return result as Ruby string
    rb_str_new_cstr(/* ... */)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="lz4-flex-rb-mixed-approach"><a class="header" href="#lz4-flex-rb-mixed-approach">LZ4-Flex-RB (Mixed Approach)</a></h3>
<p>The LZ4-Flex-RB gem demonstrates a more sophisticated approach mixing Magnus with direct rb-sys calls:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Based on lz4-flex-rb
use magnus::{function, prelude::*, Error, RModule, Ruby};
use rb_sys::{rb_str_locktmp, rb_str_unlocktmp, rb_thread_call_without_gvl};

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let module = ruby.define_module("Lz4Flex")?;

    // High-level API using Magnus
    module.define_singleton_method("compress", function!(compress, 1))?;
    module.define_singleton_method("decompress", function!(decompress, 1))?;

    Ok(())
}

// Functions that mix high-level Magnus with low-level rb-sys
fn compress(input: LockedRString) -&gt; Result&lt;RString, Error&gt; {
    let bufsize = get_maximum_output_size(input.len());
    let mut output = RStringMut::buf_new(bufsize);

    // Use nogvl_if_large to release GVL for large inputs
    let outsize = nogvl_if_large(input.len(), || {
        lz4_flex::block::compress_into(input.as_slice(), output.as_mut_slice())
    }).map_err(|e| Error::new(encode_error_class(), e.to_string()))?;

    output.set_len(outsize);
    Ok(output.into_inner())
}

// Helper for locked RString (uses rb-sys directly)
struct LockedRString(RString);

impl LockedRString {
    fn new(string: RString) -&gt; Self {
        unsafe { rb_str_locktmp(string.as_raw()) };
        Self(string)
    }

    fn as_slice(&amp;self) -&gt; &amp;[u8] {
        // Implementation using rb-sys functions
    }
}

impl Drop for LockedRString {
    fn drop(&amp;mut self) {
        unsafe { rb_str_unlocktmp(self.0.as_raw()) };
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-ruby-objects"><a class="header" href="#working-with-ruby-objects">Working with Ruby Objects</a></h1>
<h2 id="basic-type-conversions"><a class="header" href="#basic-type-conversions">Basic Type Conversions</a></h2>
<p>When writing Ruby extensions in Rust, one of the most common tasks is converting between Ruby and Rust types. The magnus
crate provides a comprehensive set of conversion functions for this purpose.</p>
<h3 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{RString, Ruby, Value, Integer, Float, Boolean};

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), magnus::Error&gt; {
    // Convert Rust types to Ruby
    let rb_string: RString = RString::new(ruby, "Hello, Ruby!");  // Rust &amp;str to Ruby String
    let rb_int: Integer = Integer::from_i64(42);                 // Rust i64 to Ruby Integer
    let rb_float: Float = Float::from_f64(3.14159);             // Rust f64 to Ruby Float
    let rb_bool: Boolean = Boolean::from(true);                 // Rust bool to Ruby true/false

    // Convert Ruby types to Rust
    let rust_string: String = rb_string.to_string()?;           // Ruby String to Rust String
    let rust_int: i64 = rb_int.to_i64()?;                       // Ruby Integer to Rust i64
    let rust_float: f64 = rb_float.to_f64()?;                   // Ruby Float to Rust f64
    let rust_bool: bool = rb_bool.to_bool();                    // Ruby true/false to Rust bool

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="checking-types"><a class="header" href="#checking-types">Checking Types</a></h3>
<p>When working with Ruby objects, you often need to check their types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{RString, Ruby, Value, check_type};

fn process_value(ruby: &amp;Ruby, val: Value) -&gt; Result&lt;(), magnus::Error&gt; {
    if val.is_nil() {
        println!("Got nil");
    } else if let Ok(s) = RString::try_convert(val) {
        println!("Got string: {}", s.to_string()?);
    } else if check_type::&lt;Integer&gt;(val) {
        println!("Got integer: {}", Integer::from_value(val)?.to_i64()?);
    } else {
        println!("Got some other type");
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="strings-arrays-and-hashes"><a class="header" href="#strings-arrays-and-hashes">Strings, Arrays, and Hashes</a></h2>
<h3 id="working-with-ruby-strings"><a class="header" href="#working-with-ruby-strings">Working with Ruby Strings</a></h3>
<p>Ruby strings are encoded and have more complex behavior than Rust strings:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{RString, Ruby, Encoding};

fn string_operations(ruby: &amp;Ruby) -&gt; Result&lt;(), magnus::Error&gt; {
    // Create a new Ruby string
    let hello = RString::new(ruby, "Hello");

    // Concatenate strings
    let world = RString::new(ruby, " World!");
    let message = hello.concat(ruby, world)?;

    // Get the encoding
    let encoding = message.encoding();
    println!("String encoding: {}", encoding.name());

    // Convert to different encoding
    let utf16 = Encoding::find("UTF-16BE").unwrap();
    let utf16_str = message.encode(ruby, utf16, None)?;

    // Get bytes
    let bytes = message.as_bytes();
    println!("Bytes: {:?}", bytes);

    // Create from bytes with specific encoding
    let latin1 = Encoding::find("ISO-8859-1").unwrap();
    let bytes = [72, 101, 108, 108, 111]; // "Hello" in ASCII/Latin1
    let latin1_str = RString::from_slice(ruby, &amp;bytes, Some(latin1));

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="working-with-ruby-arrays"><a class="header" href="#working-with-ruby-arrays">Working with Ruby Arrays</a></h3>
<p>Ruby arrays can hold any kind of Ruby object:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{RArray, Ruby, Value};

fn array_operations(ruby: &amp;Ruby) -&gt; Result&lt;(), magnus::Error&gt; {
    // Create a new empty array
    let array = RArray::new(ruby);

    // Push elements
    array.push(ruby, 1)?;
    array.push(ruby, "two")?;
    array.push(ruby, 3.0)?;

    // Get length
    let length = array.len();
    println!("Array length: {}", length);

    // Access elements
    let first: i64 = array.get(0)?;
    let second: String = array.get(1)?;
    let third: f64 = array.get(2)?;

    // Iterate through elements
    for i in 0..array.len() {
        let item: Value = array.get(i)?;
        println!("Item {}: {:?}", i, item);
    }

    // Another way to iterate
    array.each(|val| {
        println!("Item: {:?}", val);
        Ok(())
    })?;

    // Create an array from Rust Vec
    let numbers = vec![1, 2, 3, 4, 5];
    let rb_array = RArray::from_iter(ruby, numbers);

    // Convert to a Rust Vec
    let vec: Vec&lt;i64&gt; = rb_array.to_vec()?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="working-with-ruby-hashes"><a class="header" href="#working-with-ruby-hashes">Working with Ruby Hashes</a></h3>
<p>Ruby hashes are similar to Rust's HashMap but can use any Ruby object as keys:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{RHash, Value, Symbol, Ruby};

fn hash_operations(ruby: &amp;Ruby) -&gt; Result&lt;(), magnus::Error&gt; {
    // Create a new hash
    let hash = RHash::new(ruby);

    // Add key-value pairs
    hash.aset(ruby, "name", "Alice")?;
    hash.aset(ruby, Symbol::new("age"), 30)?;
    hash.aset(ruby, 1, "one")?;

    // Get values
    let name: String = hash.get(ruby, "name")?;
    let age: i64 = hash.get(ruby, Symbol::new("age"))?;
    let one: String = hash.get(ruby, 1)?;

    // Check if key exists
    if hash.has_key(ruby, "name")? {
        println!("Has key 'name'");
    }

    // Delete a key
    hash.delete(ruby, 1)?;

    // Iterate over key-value pairs
    hash.foreach(|k, v| {
        println!("Key: {:?}, Value: {:?}", k, v);
        Ok(())
    })?;

    // Convert to a Rust HashMap (if keys and values are convertible)
    let map: std::collections::HashMap&lt;String, String&gt; = hash.to_hash()?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="handling-nil-values"><a class="header" href="#handling-nil-values">Handling nil Values</a></h2>
<p>Ruby's <code>nil</code> is a special value that requires careful handling:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{Value, Ruby, RNil};

fn handle_nil(ruby: &amp;Ruby, val: Value) -&gt; Result&lt;(), magnus::Error&gt; {
    // Check if a value is nil
    if val.is_nil() {
        println!("Value is nil");
    }

    // Get nil
    let nil = ruby.nil();

    // Options and nil
    let maybe_string: Option&lt;String&gt; = val.try_convert()?;
    match maybe_string {
        Some(s) =&gt; println!("Got string: {}", s),
        None =&gt; println!("No string (was nil or couldn't convert)"),
    }

    // Explicitly return nil from a function
    fn returns_nil() -&gt; RNil {
        RNil::get()
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="converting-between-ruby-and-rust-types"><a class="header" href="#converting-between-ruby-and-rust-types">Converting Between Ruby and Rust Types</a></h2>
<p>Magnus provides powerful type conversion traits that make it easy to convert between Ruby and Rust types.</p>
<h3 id="from-rust-to-ruby-tryconvert"><a class="header" href="#from-rust-to-ruby-tryconvert">From Rust to Ruby (TryConvert)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{Value, Ruby, TryConvert, Error};

// Convert custom Rust types to Ruby objects
struct Person {
    name: String,
    age: u32,
}

impl TryConvert for Person {
    fn try_convert(val: Value) -&gt; Result&lt;Self, Error&gt; {
        let ruby = unsafe { Ruby::get_unchecked() };
        let hash = RHash::try_convert(val)?;

        let name: String = hash.get(ruby, "name")?;
        let age: u32 = hash.get(ruby, "age")?;

        Ok(Person { name, age })
    }
}

// Usage
fn process_person(val: Value) -&gt; Result&lt;(), Error&gt; {
    let person: Person = val.try_convert()?;
    println!("Person: {} ({})", person.name, person.age);
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="from-ruby-to-rust-intovalue"><a class="header" href="#from-ruby-to-rust-intovalue">From Ruby to Rust (IntoValue)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{Value, Ruby, IntoValue, Error};

struct Point {
    x: f64,
    y: f64,
}

impl IntoValue for Point {
    fn into_value_with(self, ruby: &amp;Ruby) -&gt; Result&lt;Value, Error&gt; {
        let hash = RHash::new(ruby);
        hash.aset(ruby, "x", self.x)?;
        hash.aset(ruby, "y", self.y)?;
        Ok(hash.as_value())
    }
}

// Usage
fn create_point(ruby: &amp;Ruby) -&gt; Result&lt;Value, Error&gt; {
    let point = Point { x: 10.5, y: 20.7 };
    point.into_value_with(ruby)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="creating-ruby-objects-from-rust"><a class="header" href="#creating-ruby-objects-from-rust">Creating Ruby Objects from Rust</a></h2>
<h3 id="creating-simple-objects"><a class="header" href="#creating-simple-objects">Creating Simple Objects</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{RObject, Ruby, Value, class, method};

fn create_objects(ruby: &amp;Ruby) -&gt; Result&lt;(), magnus::Error&gt; {
    // Create a basic Ruby Object
    let obj = RObject::new(ruby, ruby.class_object())?;

    // Instantiate a specific class
    let time_class = ruby.class_object::&lt;Time&gt;()?;
    let now = time_class.funcall(ruby, "now", ())?;

    // Create a Date object
    let date_class = class::object("Date")?;
    let today = date_class.funcall(ruby, "today", ())?;

    // Call methods on the object
    let formatted: String = today.funcall(ruby, "strftime", ("%Y-%m-%d",))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="creating-objects-with-instance-variables"><a class="header" href="#creating-objects-with-instance-variables">Creating Objects with Instance Variables</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{RObject, Ruby, Symbol};

fn create_with_ivars(ruby: &amp;Ruby) -&gt; Result&lt;(), magnus::Error&gt; {
    // Create a Ruby object
    let obj = RObject::new(ruby, ruby.class_object())?;

    // Set instance variables
    obj.ivar_set(ruby, "@name", "Alice")?;
    obj.ivar_set(ruby, "@age", 30)?;

    // Get instance variables
    let name: String = obj.ivar_get(ruby, "@name")?;
    let age: i64 = obj.ivar_get(ruby, "@age")?;

    // Alternatively, use symbols
    let name_sym = Symbol::new("@name");
    let name_value = obj.ivar_get(ruby, name_sym)?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="working-with-ruby-methods"><a class="header" href="#working-with-ruby-methods">Working with Ruby Methods</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{RObject, Ruby, prelude::*};

fn call_methods(ruby: &amp;Ruby) -&gt; Result&lt;(), magnus::Error&gt; {
    let array_class = ruby.class_object::&lt;RArray&gt;()?;

    // Creating an array with methods
    let array = array_class.funcall(ruby, "new", (5, "hello"))?;

    // Call methods with different argument patterns
    array.funcall(ruby, "&lt;&lt;", ("world",))?; // One argument
    array.funcall(ruby, "insert", (1, "inserted"))?; // Multiple arguments

    // Call with a block using a closure
    let mapped = array.funcall_with_block(ruby, "map", (), |arg| {
        if let Ok(s) = String::try_convert(arg) {
            Ok(s.len())
        } else {
            Ok(0)
        }
    })?;

    // Methods with keyword arguments
    let hash_class = ruby.class_object::&lt;RHash&gt;()?;
    let merge_opts = [(
        Symbol::new("overwrite"),
        true
    )];
    let hash = RHash::new(ruby);
    let other = RHash::new(ruby);
    hash.funcall_kw(ruby, "merge", (other,), merge_opts)?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-techniques"><a class="header" href="#advanced-techniques">Advanced Techniques</a></h2>
<h3 id="handling-arbitrary-ruby-values"><a class="header" href="#handling-arbitrary-ruby-values">Handling Arbitrary Ruby Values</a></h3>
<p>Sometimes you need to work with Ruby values without knowing their type in advance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{Value, Ruby, CheckType, Error};

fn describe_value(val: Value) -&gt; Result&lt;String, Error&gt; {
    let ruby = unsafe { Ruby::get_unchecked() };

    if val.is_nil() {
        return Ok("nil".to_string());
    }

    if let Ok(s) = String::try_convert(val) {
        return Ok(format!("String: {}", s));
    }

    if let Ok(i) = i64::try_convert(val) {
        return Ok(format!("Integer: {}", i));
    }

    if let Ok(f) = f64::try_convert(val) {
        return Ok(format!("Float: {}", f));
    }

    if val.respond_to(ruby, "each")? {
        return Ok("Enumerable object".to_string());
    }

    // Get the class name
    let class_name: String = val.class().name();
    Ok(format!("Object of class: {}", class_name))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="working-with-duck-types"><a class="header" href="#working-with-duck-types">Working with Duck Types</a></h3>
<p>Ruby often uses duck typing rather than relying on concrete classes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{Error, Value, Ruby};

fn process_enumerable(ruby: &amp;Ruby, val: Value) -&gt; Result&lt;Value, Error&gt; {
    // Check if the object responds to 'each'
    if !val.respond_to(ruby, "each")? {
        return Err(Error::new(
            ruby.exception_type_error(),
            "Expected an object that responds to 'each'"
        ));
    }

    // We can now safely call 'map' which most enumerables support
    val.funcall_with_block(ruby, "map", (), |item| {
        if let Ok(n) = i64::try_convert(item) {
            Ok(n * 2)
        } else {
            Ok(item)  // Pass through unchanged if not a number
        }
    })
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li>
<p><strong>Always Handle Errors</strong>: Type conversions can fail, wrap them in proper error handling.</p>
</li>
<li>
<p><strong>Use try_convert</strong>: Prefer <code>try_convert</code> over direct conversions to safely handle type mismatches.</p>
</li>
<li>
<p><strong>Remember Boxing Rules</strong>: All Ruby objects are reference types, while many Rust types are value types.</p>
</li>
<li>
<p><strong>Be Careful with Magic Methods</strong>: Some Ruby methods like <code>method_missing</code> might not behave as expected when called
from Rust.</p>
</li>
<li>
<p><strong>Cache Ruby Objects</strong>: If you're repeatedly using the same Ruby objects (like classes or symbols), consider caching
them using <code>Lazy</code> or similar mechanisms.</p>
</li>
<li>
<p><strong>Check for nil</strong>: Always check for nil values before attempting conversions that don't handle nil.</p>
</li>
<li>
<p><strong>Use Type Annotations</strong>: Explicitly specifying types when converting Ruby values to Rust can make your code clearer
and avoid potential runtime errors.</p>
</li>
<li>
<p><strong>Pass Ruby State</strong>: Always pass the <code>Ruby</code> instance through your functions when needed rather than using
<code>Ruby::get()</code> repeatedly, as this is more performant and clearer about dependencies.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ruby-classes-and-modules"><a class="header" href="#ruby-classes-and-modules">Ruby Classes and Modules</a></h1>
<p>This chapter covers how to define and work with Ruby classes and modules from Rust. It explains different approaches for
creating Ruby objects, defining methods, and organizing your code.</p>
<h2 id="defining-modules"><a class="header" href="#defining-modules">Defining Modules</a></h2>
<p>Modules in Ruby are used to namespace functionality and define mixins. Here's how to create and use modules in your Rust
extension:</p>
<h3 id="creating-a-basic-module"><a class="header" href="#creating-a-basic-module">Creating a Basic Module</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{define_module, prelude::*, Error, Ruby};

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    // Create a top-level module
    let module = ruby.define_module("MyExtension")?;

    // Define a method on the module
    module.define_singleton_method("version", function!(|| "1.0.0", 0))?;

    // Create a nested module
    let utils = module.define_module("Utils")?;
    utils.define_singleton_method("helper", function!(|| "Helper function", 0))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>This creates a module structure that would look like this in Ruby:</p>
<pre><code class="language-ruby">module MyExtension
  def self.version
    "1.0.0"
  end

  module Utils
    def self.helper
      "Helper function"
    end
  end
end
</code></pre>
<h3 id="module-constants"><a class="header" href="#module-constants">Module Constants</a></h3>
<p>You can define constants in your modules:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{define_module, Module, Ruby, Error, Value, Symbol};

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let module = ruby.define_module("Config")?;

    // Define constants
    module.const_set::&lt;_, _, Value&gt;(ruby, "VERSION", "1.0.0")?;
    module.const_set::&lt;_, _, Value&gt;(ruby, "MAX_CONNECTIONS", 100)?;
    module.const_set::&lt;_, _, Value&gt;(ruby, "DEFAULT_MODE", Symbol::new("production"))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-module-attributes"><a class="header" href="#using-module-attributes">Using Module Attributes</a></h3>
<p>To maintain module state, a common pattern is storing attributes in the module itself:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{define_module, function, prelude::*, Error, Module, Ruby};
use std::sync::Mutex;
use std::sync::atomic::{AtomicUsize, Ordering};

// Store a counter in a static atomic
static REQUEST_COUNT: AtomicUsize = AtomicUsize::new(0);

// Store configuration in a mutex
static CONFIG: Mutex&lt;Option&lt;String&gt;&gt; = Mutex::new(None);

fn increment_counter() -&gt; usize {
    REQUEST_COUNT.fetch_add(1, Ordering::SeqCst)
}

fn get_config() -&gt; Result&lt;String, Error&gt; {
    match CONFIG.lock().unwrap().clone() {
        Some(config) =&gt; Ok(config),
        None =&gt; Ok("default".to_string()),
    }
}

fn set_config(value: String) -&gt; Result&lt;String, Error&gt; {
    let mut config = CONFIG.lock().unwrap();
    *config = Some(value.clone());
    Ok(value)
}

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let module = ruby.define_module("Stats")?;

    module.define_singleton_method("increment", function!(increment_counter, 0))?;
    module.define_singleton_method("count", function!(|| REQUEST_COUNT.load(Ordering::SeqCst), 0))?;

    // Configuration methods
    module.define_singleton_method("config", function!(get_config, 0))?;
    module.define_singleton_method("config=", function!(set_config, 1))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="creating-ruby-classes-from-rust-structs"><a class="header" href="#creating-ruby-classes-from-rust-structs">Creating Ruby Classes from Rust Structs</a></h2>
<p>Magnus provides several ways to define Ruby classes that wrap Rust structures. The approach you choose depends on your
specific needs.</p>
<h3 id="using-the-typeddata-trait-full-control"><a class="header" href="#using-the-typeddata-trait-full-control">Using the TypedData Trait (Full Control)</a></h3>
<p>For full control over memory management and Ruby integration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{class, define_class, method, prelude::*, DataTypeFunctions, TypedData, Error, Ruby};

// Define a Rust struct
#[derive(Debug, TypedData)]
#[magnus(class = "MyExtension::Point", free_immediately, size)]
struct Point {
    x: f64,
    y: f64,
}

// Implement required trait
impl DataTypeFunctions for Point {}

// Implement methods
impl Point {
    fn new(x: f64, y: f64) -&gt; Self {
        Point { x, y }
    }

    fn x(&amp;self) -&gt; f64 {
        self.x
    }

    fn y(&amp;self) -&gt; f64 {
        self.y
    }

    fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
        ((self.x - other.x).powi(2) + (self.y - other.y).powi(2)).sqrt()
    }

    fn to_s(&amp;self) -&gt; String {
        format!("Point({}, {})", self.x, self.y)
    }
}

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let module = ruby.define_module("MyExtension")?;
    let class = module.define_class("Point", ruby.class_object())?;

    // Define the constructor
    class.define_singleton_method("new", function!(|x: f64, y: f64| {
        Point::new(x, y)
    }, 2))?;

    // Define instance methods
    class.define_method("x", method!(Point::x, 0))?;
    class.define_method("y", method!(Point::y, 0))?;
    class.define_method("distance", method!(Point::distance, 1))?;
    class.define_method("to_s", method!(Point::to_s, 0))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-the-wrap-macro-simplified-approach"><a class="header" href="#using-the-wrap-macro-simplified-approach">Using the Wrap Macro (Simplified Approach)</a></h3>
<p>For a simpler approach with less boilerplate:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{define_class, function, method, prelude::*, Error, Ruby};

// Define a Rust struct
struct Rectangle {
    width: f64,
    height: f64,
}

// Use the wrap macro to handle the Ruby class mapping
#[magnus::wrap(class = "MyExtension::Rectangle")]
impl Rectangle {
    // Constructor
    fn new(width: f64, height: f64) -&gt; Self {
        Rectangle { width, height }
    }

    // Instance methods
    fn width(&amp;self) -&gt; f64 {
        self.width
    }

    fn height(&amp;self) -&gt; f64 {
        self.height
    }

    fn area(&amp;self) -&gt; f64 {
        self.width * self.height
    }

    fn perimeter(&amp;self) -&gt; f64 {
        2.0 * (self.width + self.height)
    }
}

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let module = ruby.define_module("MyExtension")?;
    let class = module.define_class("Rectangle", ruby.class_object())?;

    // Register class methods and instance methods
    class.define_singleton_method("new", function!(Rectangle::new, 2))?;
    class.define_method("width", method!(Rectangle::width, 0))?;
    class.define_method("height", method!(Rectangle::height, 0))?;
    class.define_method("area", method!(Rectangle::area, 0))?;
    class.define_method("perimeter", method!(Rectangle::perimeter, 0))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-refcell-for-mutable-rust-objects"><a class="header" href="#using-refcell-for-mutable-rust-objects">Using RefCell for Mutable Rust Objects</a></h3>
<p>For Ruby objects that need interior mutability:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;
use magnus::{define_class, function, method, prelude::*, Error, Ruby};

struct Counter {
    count: usize,
}

#[magnus::wrap(class = "MyExtension::Counter")]
struct MutCounter(RefCell&lt;Counter&gt;);

impl MutCounter {
    fn new(initial: usize) -&gt; Self {
        MutCounter(RefCell::new(Counter { count: initial }))
    }

    fn count(&amp;self) -&gt; usize {
        self.0.borrow().count
    }

    fn increment(&amp;self) -&gt; usize {
        let mut counter = self.0.borrow_mut();
        counter.count += 1;
        counter.count
    }

    fn increment_by(&amp;self, n: usize) -&gt; usize {
        let mut counter = self.0.borrow_mut();
        counter.count += n;
        counter.count
    }

    // AVOID this pattern which can cause BorrowMutError
    fn bad_increment_method(&amp;self) -&gt; Result&lt;usize, Error&gt; {
        // Don't do this - it keeps the borrowing active while trying to borrow_mut
        if self.0.borrow().count &gt; 10 {
            // This will panic with "already borrowed: BorrowMutError"
            self.0.borrow_mut().count += 100;
        } else {
            self.0.borrow_mut().count += 1;
        }

        Ok(self.0.borrow().count)
    }

    // CORRECT pattern - complete the first borrow before starting the second
    fn good_increment_method(&amp;self) -&gt; Result&lt;usize, Error&gt; {
        // Copy the value first
        let current_count = self.0.borrow().count;

        // Then the first borrow is dropped and we can borrow_mut safely
        if current_count &gt; 10 {
            self.0.borrow_mut().count += 100;
        } else {
            self.0.borrow_mut().count += 1;
        }

        Ok(self.0.borrow().count)
    }
}

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let module = ruby.define_module("MyExtension")?;
    let class = module.define_class("Counter", ruby.class_object())?;

    class.define_singleton_method("new", function!(MutCounter::new, 1))?;
    class.define_method("count", method!(MutCounter::count, 0))?;
    class.define_method("increment", method!(MutCounter::increment, 0))?;
    class.define_method("increment_by", method!(MutCounter::increment_by, 1))?;
    class.define_method("good_increment", method!(MutCounter::good_increment_method, 0))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="implementing-ruby-methods"><a class="header" href="#implementing-ruby-methods">Implementing Ruby Methods</a></h2>
<p>Magnus provides flexible macros to help define methods with various signatures.</p>
<h3 id="function-vs-method-macros"><a class="header" href="#function-vs-method-macros">Function vs Method Macros</a></h3>
<p>Magnus provides two primary macros for defining callable Ruby code:</p>
<ol>
<li><code>function!</code> - For singleton/class methods and module functions</li>
<li><code>method!</code> - For instance methods when you need access to the Rust object (<code>&amp;self</code>)</li>
</ol>
<p>Here's how to use each:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{function, method, define_class, prelude::*, Error, Ruby};

struct Calculator {}

#[magnus::wrap(class = "Calculator")]
impl Calculator {
    // Constructor - a class method
    fn new() -&gt; Self {
        Calculator {}
    }

    // Regular instance method that doesn't raise exceptions
    fn add(&amp;self, a: i64, b: i64) -&gt; i64 {
        a + b
    }

    // Method that needs the Ruby interpreter to raise an exception
    fn divide(ruby: &amp;Ruby, _rb_self: &amp;Self, a: i64, b: i64) -&gt; Result&lt;i64, Error&gt; {
        if b == 0 {
            return Err(Error::new(
                ruby.exception_zero_div_error(),
                "Division by zero"
            ));
        }
        Ok(a / b)
    }

    // Class method that doesn't need a Calculator instance
    fn version() -&gt; &amp;'static str {
        "1.0.0"
    }
}

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let class = ruby.define_class("Calculator", ruby.class_object())?;

    // Register the constructor with function!
    class.define_singleton_method("new", function!(Calculator::new, 0))?;

    // Register a class method with function!
    class.define_singleton_method("version", function!(Calculator::version, 0))?;

    // Register instance methods with method!
    class.define_method("add", method!(Calculator::add, 2))?;
    class.define_method("divide", method!(Calculator::divide, 2))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="method-signature-patterns"><a class="header" href="#method-signature-patterns">Method Signature Patterns</a></h3>
<p>There are several common method signature patterns depending on what your method needs to do:</p>
<h4 id="basic-method-no-ruby-access-no-exceptions"><a class="header" href="#basic-method-no-ruby-access-no-exceptions">Basic Method (no Ruby access, no exceptions)</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(&amp;self, a: i64, b: i64) -&gt; i64 {
    a + b
}
<span class="boring">}</span></code></pre></pre>
<h4 id="method-that-raises-exceptions"><a class="header" href="#method-that-raises-exceptions">Method that Raises Exceptions</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn divide(ruby: &amp;Ruby, _rb_self: &amp;Self, a: i64, b: i64) -&gt; Result&lt;i64, Error&gt; {
    if b == 0 {
        return Err(Error::new(
            ruby.exception_zero_div_error(),
            "Division by zero"
        ));
    }
    Ok(a / b)
}
<span class="boring">}</span></code></pre></pre>
<h4 id="method-that-needs-to-access-self-by-value"><a class="header" href="#method-that-needs-to-access-self-by-value">Method that Needs to Access Self by Value</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Usually for cloning or consuming self
fn clone_and_modify(rb_self: Value) -&gt; Result&lt;Value, Error&gt; {
    let ruby = unsafe { Ruby::get_unchecked() };
    let obj = ruby.class_object::&lt;Calculator&gt;()?.new_instance(())?;
    // Modify obj...
    Ok(obj)
}
<span class="boring">}</span></code></pre></pre>
<h4 id="method-with-ruby-block"><a class="header" href="#method-with-ruby-block">Method with Ruby Block</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn with_retries(ruby: &amp;Ruby, _rb_self: &amp;Self, max_retries: usize, block: Proc) -&gt; Result&lt;Value, Error&gt; {
    let mut retries = 0;
    loop {
        match block.call(ruby, ()) {
            Ok(result) =&gt; return Ok(result),
            Err(e) if retries &lt; max_retries =&gt; {
                retries += 1;
                // Maybe backoff or log error
            },
            Err(e) =&gt; return Err(e),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="class-inheritance-and-mixins"><a class="header" href="#class-inheritance-and-mixins">Class Inheritance and Mixins</a></h2>
<p>Ruby supports a rich object model with single inheritance and multiple module inclusion. Magnus allows you to replicate
this model in your Rust extension.</p>
<h3 id="creating-a-subclass"><a class="header" href="#creating-a-subclass">Creating a Subclass</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{Module, class, define_class, method, prelude::*, Error, Ruby};

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    // Get the parent class (Ruby's built-in Array)
    let array_class = ruby.class_object::&lt;RArray&gt;()?;

    // Create a subclass
    let sorted_array = ruby.define_class("SortedArray", array_class)?;

    // Override the &lt;&lt; (push) method to keep the array sorted
    sorted_array.define_method("&lt;&lt;", method!(|ruby, rb_self: Value, item: Value| {
        let array = RArray::from_value(rb_self)?;
        array.push(ruby, item)?;

        // Call sort! to keep the array sorted
        array.funcall(ruby, "sort!", ())?;

        Ok(rb_self) // Return self for method chaining
    }, 1))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="including-modules-mixins"><a class="header" href="#including-modules-mixins">Including Modules (Mixins)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{Module, class, define_class, define_module, method, prelude::*, Error, Ruby};

fn make_comparable(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let module = ruby.define_module("MyComparable")?;

    // Define methods for the module
    module.define_method("&lt;=&gt;", method!(|_ruby, rb_self: Value, other: Value| {
        // Implementation of the spaceship operator for comparison
        let self_num: Result&lt;i64, _&gt; = rb_self.try_convert();
        let other_num: Result&lt;i64, _&gt; = other.try_convert();

        match (self_num, other_num) {
            (Ok(a), Ok(b)) =&gt; Ok(a.cmp(&amp;b) as i8),
            _ =&gt; Ok(nil()),
        }
    }, 1))?;

    // Define methods that depend on &lt;=&gt;
    module.define_method("==", method!(|ruby, rb_self: Value, other: Value| {
        let result: i8 = rb_self.funcall(ruby, "&lt;=&gt;", (other,))?;
        Ok(result == 0)
    }, 1))?;

    module.define_method("&gt;", method!(|ruby, rb_self: Value, other: Value| {
        let result: i8 = rb_self.funcall(ruby, "&lt;=&gt;", (other,))?;
        Ok(result &gt; 0)
    }, 1))?;

    module.define_method("&lt;", method!(|ruby, rb_self: Value, other: Value| {
        let result: i8 = rb_self.funcall(ruby, "&lt;=&gt;", (other,))?;
        Ok(result &lt; 0)
    }, 1))?;

    Ok(())
}

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    // Create our module
    make_comparable(ruby)?;

    // Create a class
    let score = ruby.define_class("Score", ruby.class_object())?;

    // Define methods
    score.define_singleton_method("new", function!(|value: i64| {
        let obj = RObject::new(ruby.class_object::&lt;Score&gt;())?;
        obj.ivar_set(ruby, "@value", value)?;
        Ok(obj)
    }, 1))?;

    score.define_method("value", method!(|ruby, rb_self: Value| {
        rb_self.ivar_get::&lt;_, i64&gt;(ruby, "@value")
    }, 0))?;

    // Include our module
    let comparable = ruby.define_module("MyComparable")?;
    score.include_module(ruby, comparable)?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="working-with-singleton-methods"><a class="header" href="#working-with-singleton-methods">Working with Singleton Methods</a></h2>
<p>Singleton methods in Ruby are methods attached to individual objects, not to their class. The most common use is
defining class methods, but they can be applied to any object.</p>
<h3 id="defining-a-class-with-both-instance-and-singleton-methods"><a class="header" href="#defining-a-class-with-both-instance-and-singleton-methods">Defining a Class with Both Instance and Singleton Methods</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{class, define_class, function, method, prelude::*, Error, Ruby, Value};

#[magnus::wrap(class = "Logger")]
struct Logger {
    level: String,
}

impl Logger {
    fn new(level: String) -&gt; Self {
        Logger { level }
    }

    fn log(&amp;self, message: String) -&gt; String {
        format!("[{}] {}", self.level, message)
    }

    // Class methods (singleton methods)
    fn default_level() -&gt; &amp;'static str {
        "INFO"
    }

    fn create_default(ruby: &amp;Ruby) -&gt; Result&lt;Value, Error&gt; {
        let class = ruby.class_object::&lt;Logger&gt;()?;
        let default_level = Self::default_level();
        class.new_instance((default_level,))
    }
}

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let class = ruby.define_class("Logger", ruby.class_object())?;

    // Instance methods
    class.define_singleton_method("new", function!(Logger::new, 1))?;
    class.define_method("log", method!(Logger::log, 1))?;

    // Class methods using function! macro
    class.define_singleton_method("default_level", function!(Logger::default_level, 0))?;
    class.define_singleton_method("create_default", function!(Logger::create_default, 0))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="attaching-methods-to-a-specific-object-true-singleton-methods"><a class="header" href="#attaching-methods-to-a-specific-object-true-singleton-methods">Attaching Methods to a Specific Object (True Singleton Methods)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{module, function, prelude::*, Error, Ruby, Value};

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    // Create a single object
    let config = ruby.eval::&lt;Value&gt;("Object.new")?;

    // Define singleton methods directly on that object
    config.define_singleton_method(ruby, "get", function!(|| {
        "Configuration value"
    }, 0))?;

    config.define_singleton_method(ruby, "enabled?", function!(|| {
        true
    }, 0))?;

    // Make it globally accessible
    ruby.define_global_const("CONFIG", config)?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>This creates an object that can be used in Ruby like:</p>
<pre><code class="language-ruby">CONFIG.get          # =&gt; "Configuration value"
CONFIG.enabled?     # =&gt; true
CONFIG.class        # =&gt; Object
</code></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<ol>
<li>
<p><strong>Use magnus macros for class definition</strong>: The <code>wrap</code> and <code>TypedData</code> macros simplify class definition
significantly.</p>
</li>
<li>
<p><strong>Consistent naming</strong>: Keep Ruby and Rust naming conventions consistent within their domains (snake_case for Ruby
methods, CamelCase for Ruby classes).</p>
</li>
<li>
<p><strong>Layer your API</strong>: Consider providing both low-level and high-level APIs for complex functionality.</p>
</li>
<li>
<p><strong>Document method signatures</strong>: When using methods that can raise exceptions, document which exceptions can be
raised.</p>
</li>
<li>
<p><strong>RefCell borrowing pattern</strong>: Always release a <code>borrow()</code> before calling <code>borrow_mut()</code> by copying any needed
values.</p>
</li>
<li>
<p><strong>Method macro selection</strong>: Use <code>function!</code> for singleton methods and <code>method!</code> for instance methods.</p>
</li>
<li>
<p><strong>Include the Ruby parameter</strong>: Always include <code>ruby: &amp;Ruby</code> in your method signature if your method might raise
exceptions or interact with the Ruby runtime.</p>
</li>
<li>
<p><strong>Reuse existing Ruby patterns</strong>: When designing your API, follow existing Ruby conventions that users will already
understand.</p>
</li>
<li>
<p><strong>Cache Ruby classes and modules</strong>: Use <code>Lazy</code> to cache frequently accessed classes and modules.</p>
</li>
<li>
<p><strong>Maintain object hierarchy</strong>: Properly use Ruby's inheritance and module system to organize your code."</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling-in-rust-ruby-extensions"><a class="header" href="#error-handling-in-rust-ruby-extensions">Error Handling in Rust Ruby Extensions</a></h1>
<p>Proper error handling is critical for robust Ruby extensions. This guide covers how to handle errors in Rust and map
them to appropriate Ruby exceptions.</p>
<div class="warning">
<p>Improper error handling can lead to crashes that take down the entire Ruby VM. This chapter shows you how to properly
raise and handle exceptions in your Rust extensions.</p>
</div>
<h2 id="overview-of-error-handling-approaches"><a class="header" href="#overview-of-error-handling-approaches">Overview of Error Handling Approaches</a></h2>
<p>When building Ruby extensions with Rust, you'll typically use one of these error handling patterns:</p>
<ol>
<li><strong>Result-based error handling</strong>: Using Rust's <code>Result&lt;T, E&gt;</code> type to return errors</li>
<li><strong>Ruby exception raising</strong>: Converting Rust errors into Ruby exceptions</li>
<li><strong>Panic catching</strong>: Handling unexpected Rust panics and converting them to Ruby exceptions</li>
</ol>
<div class="note">
<p>The most common pattern in rb-sys extensions is to use Rust's <code>Result&lt;T, magnus::Error&gt;</code> type, where the <code>Error</code> type
represents a Ruby exception that can be raised.</p>
</div>
<h2 id="the-result-type-and-magnuserror"><a class="header" href="#the-result-type-and-magnuserror">The Result Type and Magnus::Error</a></h2>
<p>Magnus uses <code>Result&lt;T, Error&gt;</code> as the standard way to handle errors. The <code>Error</code> type represents a Ruby exception that
can be raised:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{Error, Ruby};

fn might_fail(ruby: &amp;Ruby, value: i64) -&gt; Result&lt;i64, Error&gt; {
    if value &lt; 0 {
        return Err(Error::new(
            ruby.exception_arg_error(),
            "Value must be positive"
        ));
    }
    Ok(value * 2)
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Error</code> type:</p>
<ul>
<li>Contains a reference to a Ruby exception class</li>
<li>Includes an error message</li>
<li>Can be created from an existing Ruby exception</li>
</ul>
<h2 id="mapping-rust-errors-to-ruby-exceptions"><a class="header" href="#mapping-rust-errors-to-ruby-exceptions">Mapping Rust Errors to Ruby Exceptions</a></h2>
<h3 id="standard-ruby-exception-types"><a class="header" href="#standard-ruby-exception-types">Standard Ruby Exception Types</a></h3>
<p>Magnus provides access to all standard Ruby exception types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{Error, Ruby};

fn divide(ruby: &amp;Ruby, a: f64, b: f64) -&gt; Result&lt;f64, Error&gt; {
    if b == 0.0 {
        return Err(Error::new(
            ruby.exception_zero_div_error(),
            "Division by zero"
        ));
    }
    Ok(a / b)
}

fn process_array(ruby: &amp;Ruby, index: isize, array: RArray) -&gt; Result&lt;Value, Error&gt; {
    if index &lt; 0 || index &gt;= array.len() as isize {
        return Err(Error::new(
            ruby.exception_index_error(),
            format!("Index {} out of bounds (0..{})", index, array.len() - 1)
        ));
    }
    array.get(index as usize)
}

fn parse_number(ruby: &amp;Ruby, input: &amp;str) -&gt; Result&lt;i64, Error&gt; {
    match input.parse::&lt;i64&gt;() {
        Ok(num) =&gt; Ok(num),
        Err(_) =&gt; Err(Error::new(
            ruby.exception_arg_error(),
            format!("Cannot parse '{}' as a number", input)
        )),
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Common Ruby exception types available through the Ruby API:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Exception Class</th><th>Typical Use Case</th></tr></thead><tbody>
<tr><td><code>ruby.exception_arg_error()</code></td><td><code>ArgumentError</code></td><td>Invalid argument value or type</td></tr>
<tr><td><code>ruby.exception_index_error()</code></td><td><code>IndexError</code></td><td>Array/string index out of bounds</td></tr>
<tr><td><code>ruby.exception_key_error()</code></td><td><code>KeyError</code></td><td>Hash key not found</td></tr>
<tr><td><code>ruby.exception_name_error()</code></td><td><code>NameError</code></td><td>Reference to undefined name</td></tr>
<tr><td><code>ruby.exception_no_memory_error()</code></td><td><code>NoMemoryError</code></td><td>Memory allocation failure</td></tr>
<tr><td><code>ruby.exception_not_imp_error()</code></td><td><code>NotImplementedError</code></td><td>Feature not implemented</td></tr>
<tr><td><code>ruby.exception_range_error()</code></td><td><code>RangeError</code></td><td>Value outside valid range</td></tr>
<tr><td><code>ruby.exception_regexp_error()</code></td><td><code>RegexpError</code></td><td>Invalid regular expression</td></tr>
<tr><td><code>ruby.exception_runtime_error()</code></td><td><code>RuntimeError</code></td><td>General runtime error</td></tr>
<tr><td><code>ruby.exception_script_error()</code></td><td><code>ScriptError</code></td><td>Problem in script execution</td></tr>
<tr><td><code>ruby.exception_syntax_error()</code></td><td><code>SyntaxError</code></td><td>Invalid syntax</td></tr>
<tr><td><code>ruby.exception_type_error()</code></td><td><code>TypeError</code></td><td>Type mismatch</td></tr>
<tr><td><code>ruby.exception_zero_div_error()</code></td><td><code>ZeroDivisionError</code></td><td>Division by zero</td></tr>
</tbody></table>
</div>
<h3 id="creating-custom-exception-classes"><a class="header" href="#creating-custom-exception-classes">Creating Custom Exception Classes</a></h3>
<p>You can define custom exception classes for your extension:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{class, Error, Ruby};

#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let module = ruby.define_module("MyExtension")?;

    // Create custom exception classes
    let std_error = ruby.exception_standard_error();
    let custom_error = module.define_class("CustomError", std_error)?;
    let validation_error = module.define_class("ValidationError", custom_error)?;

    // Register them as constants for easier access
    ruby.define_global_const("MY_CUSTOM_ERROR", custom_error)?;

    Ok(())
}

// Using the custom exception
fn validate(ruby: &amp;Ruby, value: &amp;str) -&gt; Result&lt;(), Error&gt; {
    if value.is_empty() {
        return Err(Error::new(
            ruby.class_path_to_value("MyExtension::ValidationError"),
            "Validation failed: value cannot be empty"
        ));
    }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="passing-and-re-raising-ruby-exceptions"><a class="header" href="#passing-and-re-raising-ruby-exceptions">Passing and Re-raising Ruby Exceptions</a></h3>
<p>You can pass along existing Ruby exceptions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{Error, Ruby, Value};

fn process_data(ruby: &amp;Ruby, input: Value) -&gt; Result&lt;Value, Error&gt; {
    // Call a method that might raise
    let result = match input.funcall(ruby, "process", ()) {
        Ok(val) =&gt; val,
        Err(err) =&gt; return Err(err), // Pass along the original error
    };

    // Or with the ? operator
    let result = input.funcall(ruby, "process", ())?;

    Ok(result)
}
<span class="boring">}</span></code></pre></pre>
<p>For wrapping and adding context to errors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn compute_with_context(ruby: &amp;Ruby, input: Value) -&gt; Result&lt;Value, Error&gt; {
    match complex_operation(ruby, input) {
        Ok(result) =&gt; Ok(result),
        Err(err) =&gt; {
            // Create a new error with additional context
            Err(Error::new(
                ruby.exception_runtime_error(),
                format!("Computation failed: {}", err.message(ruby).unwrap_or_default())
            ))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="handling-rust-panics"><a class="header" href="#handling-rust-panics">Handling Rust Panics</a></h2>
<p>Rust panics should be caught and converted to Ruby exceptions to prevent crashing the Ruby VM:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{Error, Ruby};
use std::panic::{self, catch_unwind};

fn dangerous_operation(ruby: &amp;Ruby, input: i64) -&gt; Result&lt;i64, Error&gt; {
    // Catch any potential panics
    let result = catch_unwind(|| {
        // Code that might panic
        if input == 0 {
            panic!("Unexpected zero value");
        }
        input * 2
    });

    match result {
        Ok(value) =&gt; Ok(value),
        Err(_) =&gt; Err(Error::new(
            ruby.exception_runtime_error(),
            "Internal error: Rust panic occurred"
        )),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-patterns"><a class="header" href="#error-handling-patterns">Error Handling Patterns</a></h2>
<h3 id="the-question-mark-operator"><a class="header" href="#the-question-mark-operator">The Question Mark Operator</a></h3>
<p>The <code>?</code> operator simplifies error handling by automatically propagating errors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn multi_step_operation(ruby: &amp;Ruby, value: i64) -&gt; Result&lt;i64, Error&gt; {
    // Each operation can fail, ? will return early on error
    let step1 = validate_input(ruby, value)?;
    let step2 = transform_data(ruby, step1)?;
    let step3 = final_calculation(ruby, step2)?;

    Ok(step3)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pattern-matching-on-errors"><a class="header" href="#pattern-matching-on-errors">Pattern Matching on Errors</a></h3>
<p>For more sophisticated error handling, pattern match on error types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_specific_errors(ruby: &amp;Ruby, value: Value) -&gt; Result&lt;Value, Error&gt; {
    let result = value.funcall(ruby, "some_method", ());

    match result {
        Ok(val) =&gt; Ok(val),
        Err(err) if err.is_kind_of(ruby, ruby.exception_zero_div_error()) =&gt; {
            // Handle division by zero specially
            Ok(ruby.integer_from_i64(0))
        },
        Err(err) if err.is_kind_of(ruby, ruby.exception_arg_error()) =&gt; {
            // Convert ArgumentError to a different type
            Err(Error::new(
                ruby.exception_runtime_error(),
                format!("Invalid argument: {}", err.message(ruby).unwrap_or_default())
            ))
        },
        Err(err) =&gt; Err(err), // Pass through other errors
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="context-managers--raii-pattern"><a class="header" href="#context-managers--raii-pattern">Context Managers / RAII Pattern</a></h3>
<p>Use Rust's RAII (Resource Acquisition Is Initialization) pattern for cleanup operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{Error, Ruby};
use std::fs::File;
use std::io::{self, Read};

struct TempResource {
    data: Vec&lt;u8&gt;,
}

impl TempResource {
    fn new() -&gt; Self {
        // Allocate resource
        TempResource { data: Vec::new() }
    }
}

impl Drop for TempResource {
    fn drop(&amp;mut self) {
        // Clean up will happen automatically, even if an error occurs
        println!("Cleaning up resource");
    }
}

fn process_with_resource(ruby: &amp;Ruby) -&gt; Result&lt;Value, Error&gt; {
    // Resource is created
    let mut resource = TempResource::new();

    // If an error occurs here, resource will still be cleaned up
    let file_result = File::open("data.txt");
    let mut file = match file_result {
        Ok(f) =&gt; f,
        Err(e) =&gt; return Err(Error::new(
            ruby.exception_io_error(),
            format!("Could not open file: {}", e)
        )),
    };

    // Resource will be dropped at the end of this scope
    Ok(ruby.ary_new_from_ary(&amp;[1, 2, 3]))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-for-error-handling"><a class="header" href="#best-practices-for-error-handling">Best Practices for Error Handling</a></h2>
<div class="tip">
<p>Following these practices will make your extensions more robust and provide a better experience for users.</p>
</div>
<h3 id="1-be-specific-with-exception-types"><a class="header" href="#1-be-specific-with-exception-types">1. Be Specific with Exception Types</a></h3>
<p>Choose the most appropriate Ruby exception type:</p>
<pre><pre class="playground"><code class="language-rust hidelines=#"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use magnus::{Error, Ruby};
</span><span class="boring">
</span><span class="boring">fn example(ruby: &amp;Ruby, index: usize, array: &amp;[i32]) -&gt; Result&lt;i32, Error&gt; {
</span>// ✅ GOOD: Specific exception type
if index &gt;= array.len() {
    return Err(Error::new(
        ruby.exception_index_error(),
        format!("Index {} out of bounds (0..{})", index, array.len() - 1)
    ));
}
<span class="boring">
</span><span class="boring">// Example with bad practice commented out
</span><span class="boring">/*
</span><span class="boring">// ❌ BAD: Generic RuntimeError for specific issue
</span><span class="boring">if index &gt;= array.len() {
</span><span class="boring">    return Err(Error::new(
</span><span class="boring">        ruby.exception_runtime_error(),
</span><span class="boring">        "Invalid index"
</span><span class="boring">    ));
</span><span class="boring">}
</span><span class="boring">*/
</span><span class="boring">    Ok(array[index])
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="note">
<p>Ruby has a rich hierarchy of exception types. Using the specific exception type helps users handle errors properly in
their Ruby code.</p>
</div>
<h3 id="2-provide-clear-error-messages"><a class="header" href="#2-provide-clear-error-messages">2. Provide Clear Error Messages</a></h3>
<p>Include relevant details in error messages:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ GOOD: Descriptive error with context
let err_msg = format!(
    "Cannot parse '{}' as a number in range {}-{}",
    input, min, max
);

// ❌ BAD: Vague error message
let err_msg = "Invalid input";
<span class="boring">}</span></code></pre></pre>
<h3 id="3-maintain-ruby-error-hierarchies"><a class="header" href="#3-maintain-ruby-error-hierarchies">3. Maintain Ruby Error Hierarchies</a></h3>
<p>Respect Ruby's exception hierarchy:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ GOOD: Proper exception hierarchy
let io_error = ruby.exception_io_error();
let file_error = module.define_class("FileError", io_error)?;
let format_error = module.define_class("FormatError", file_error)?;

// ❌ BAD: Improper exception hierarchy
let format_error = module.define_class("FormatError", ruby.class_object())?; // Not inheriting from StandardError
<span class="boring">}</span></code></pre></pre>
<h3 id="4-avoid-panicking"><a class="header" href="#4-avoid-panicking">4. Avoid Panicking</a></h3>
<p>Use <code>Result</code> instead of panic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ GOOD: Return Result for expected error conditions
fn process(value: i64) -&gt; Result&lt;i64, Error&gt; {
    if value &lt; 0 {
        return Err(Error::new(
            ruby.exception_arg_error(),
            "Value must be positive"
        ));
    }
    Ok(value * 2)
}

// ❌ BAD: Panicking on expected error condition
fn process(value: i64) -&gt; i64 {
    if value &lt; 0 {
        panic!("Value must be positive"); // Will crash the Ruby VM!
    }
    value * 2
}
<span class="boring">}</span></code></pre></pre>
<h3 id="5-catch-all-ruby-exceptions"><a class="header" href="#5-catch-all-ruby-exceptions">5. Catch All Ruby Exceptions</a></h3>
<p>When calling Ruby methods, always handle exceptions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ GOOD: Catch exceptions from Ruby method calls
let result = match obj.funcall(ruby, "some_method", ()) {
    Ok(val) =&gt; val,
    Err(err) =&gt; {
        // Handle or re-raise the error
        return Err(err);
    }
};

// ❌ BAD: Not handling potential Ruby exceptions
let result = obj.funcall(ruby, "some_method", ()).unwrap(); // May panic!
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-with-refcell"><a class="header" href="#error-handling-with-refcell">Error Handling with RefCell</a></h2>
<p>When using <code>RefCell</code> for interior mutability, handle borrow errors gracefully:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;
use magnus::{Error, Ruby};

#[magnus::wrap(class = "Counter")]
struct MutCounter(RefCell&lt;u64&gt;);

impl MutCounter {
    fn new() -&gt; Self {
        MutCounter(RefCell::new(0))
    }

    fn increment(ruby: &amp;Ruby, self_: &amp;Self) -&gt; Result&lt;u64, Error&gt; {
        match self_.0.try_borrow_mut() {
            Ok(mut value) =&gt; {
                *value += 1;
                Ok(*value)
            },
            Err(_) =&gt; Err(Error::new(
                ruby.exception_runtime_error(),
                "Cannot modify counter: already borrowed"
            )),
        }
    }

    // Better approach: complete borrows before starting new ones
    fn safe_increment(&amp;self) -&gt; u64 {
        let mut value = self.0.borrow_mut();
        *value += 1;
        *value
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<div class="warning">
<p>Never use <code>unwrap()</code> or <code>expect()</code> in production code for your Ruby extensions. These can cause panics that will crash
the Ruby VM. Always use proper error handling with <code>Result</code> and <code>Error</code> types.</p>
</div>
<p>Effective error handling makes your Ruby extensions more robust and user-friendly. By using the right exception types
and providing clear error messages, you create a better experience for users of your extension.</p>
<p>Remember these key points:</p>
<ul>
<li>Use <code>Result&lt;T, Error&gt;</code> for functions that can fail</li>
<li>Choose appropriate Ruby exception types</li>
<li>Provide clear, detailed error messages</li>
<li>Handle Rust panics to prevent VM crashes</li>
<li>Respect Ruby's exception hierarchy</li>
</ul>
<div class="tip">
<p>After you've handled errors in your Rust code, try to test your extension with invalid inputs to ensure it fails
gracefully with appropriate Ruby exceptions rather than crashing.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-management--safety"><a class="header" href="#memory-management--safety">Memory Management &amp; Safety</a></h1>
<p>One of the most important aspects of writing Ruby extensions is proper memory management. This chapter covers how Ruby's
garbage collector interacts with Rust objects and how to ensure your extensions don't leak memory or cause segmentation
faults.</p>
<div class="warning">
<p>Improper memory management is the leading cause of crashes and security vulnerabilities in native extensions. Rust's
safety guarantees help prevent many common issues, but you still need to carefully manage the boundary between Ruby and
Rust memory.</p>
</div>
<h2 id="rubys-garbage-collection-system"><a class="header" href="#rubys-garbage-collection-system">Ruby's Garbage Collection System</a></h2>
<p>Ruby uses a mark-and-sweep garbage collector to manage memory. Understanding how it works is essential for writing safe
extensions:</p>
<ol>
<li><strong>Marking Phase</strong>: Ruby traverses all visible objects, marking them as "in use"</li>
<li><strong>Sweeping Phase</strong>: Objects that weren't marked are considered garbage and freed</li>
</ol>
<div class="note">
<p>When you create Rust objects that reference Ruby objects, you need to tell Ruby's GC about these references to prevent
premature garbage collection. The <code>TypedData</code> trait and <code>mark</code> method provide the mechanism to do this.</p>
</div>
<h2 id="typeddata-and-datatypefunctions"><a class="header" href="#typeddata-and-datatypefunctions">TypedData and DataTypeFunctions</a></h2>
<p>Magnus provides a <code>TypedData</code> trait and <code>DataTypeFunctions</code> trait for managing Ruby objects that wrap Rust structs. This
is the recommended way to handle complex objects in Rust.</p>
<h3 id="basic-typeddata-example"><a class="header" href="#basic-typeddata-example">Basic TypedData Example</a></h3>
<p>Here's how to define a simple Ruby object that wraps a Rust struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{prelude::*, Error, Ruby, TypedData, DataTypeFunctions};

// Define your Rust struct
#[derive(TypedData)]
#[magnus(class = "MyExtension::Counter", free_immediately)]
struct Counter {
    count: i64,
}

// Implement required functions
impl DataTypeFunctions for Counter {}

// Implement methods for your struct
impl Counter {
    fn new(initial_value: i64) -&gt; Self {
        Counter { count: initial_value }
    }

    fn increment(&amp;mut self, amount: i64) -&gt; i64 {
        self.count += amount;
        self.count
    }

    fn value(&amp;self) -&gt; i64 {
        self.count
    }
}

// Register with Ruby
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let class = ruby.define_class("Counter", ruby.class_object())?;

    class.define_singleton_method("new", function!(|initial: i64| {
        Ok(class.wrap(Counter::new(initial)))
    }, 1))?;

    class.define_method("increment", method!(Counter::increment, 1))?;
    class.define_method("value", method!(Counter::value, 0))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="implementing-gc-marking"><a class="header" href="#implementing-gc-marking">Implementing GC Marking</a></h3>
<p>When your Rust struct holds references to Ruby objects, you need to implement the <code>mark</code> method to tell Ruby's GC about
those references. Here's a simple example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{
    prelude::*, Error, Ruby, Value, TypedData, DataTypeFunctions,
    gc::Marker, typed_data::Obj
};

// A struct that holds references to Ruby objects
#[derive(TypedData)]
#[magnus(class = "MyExtension::Person", free_immediately, mark)]
struct Person {
    // Reference to a Ruby string (their name)
    name: Value,
    // Reference to Ruby array (their hobbies)
    hobbies: Value,
    // Optional reference to another Person (their friend)
    friend: Option&lt;Obj&lt;Person&gt;&gt;,
}

// Implement DataTypeFunctions with mark method
impl DataTypeFunctions for Person {
    // This is called during GC mark phase
    fn mark(&amp;self, marker: &amp;Marker) {
        // Mark the Ruby objects we reference
        marker.mark(self.name);
        marker.mark(self.hobbies);

        // If we have a friend, mark them too
        if let Some(ref friend) = self.friend {
            marker.mark(*friend);
        }
    }
}

impl Person {
    fn new(name: Value, hobbies: Value) -&gt; Self {
        Self {
            name,
            hobbies,
            friend: None,
        }
    }

    fn add_friend(&amp;mut self, friend: Obj&lt;Person&gt;) {
        self.friend = Some(friend);
    }

    fn name(&amp;self) -&gt; Value {
        self.name
    }

    fn hobbies(&amp;self) -&gt; Value {
        self.hobbies
    }

    fn friend(&amp;self) -&gt; Option&lt;Obj&lt;Person&gt;&gt; {
        self.friend.clone()
    }
}

// Register with Ruby
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let class = ruby.define_class("Person", ruby.class_object())?;

    class.define_singleton_method("new", function!(|name: Value, hobbies: Value| {
        Ok(class.wrap(Person::new(name, hobbies)))
    }, 2))?;

    class.define_method("name", method!(Person::name, 0))?;
    class.define_method("hobbies", method!(Person::hobbies, 0))?;
    class.define_method("friend", method!(Person::friend, 0))?;
    class.define_method("add_friend", method!(Person::add_friend, 1))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>In this example:</p>
<ol>
<li>The <code>Person</code> struct holds references to Ruby objects (<code>name</code> and <code>hobbies</code>) and another wrapped Rust object
(<code>friend</code>)</li>
<li>We implement the <code>mark</code> method to tell Ruby's GC about all these references</li>
<li>During garbage collection, Ruby will know not to collect these objects as long as the <code>Person</code> is alive</li>
</ol>
<h2 id="a-real-world-example-trap-from-wasmtime-rb"><a class="header" href="#a-real-world-example-trap-from-wasmtime-rb">A Real-World Example: Trap from wasmtime-rb</a></h2>
<p>Here's a slightly simplified version of a real-world example from the wasmtime-rb project:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{
    prelude::*, method, Error, Ruby, TypedData, DataTypeFunctions,
    typed_data::Obj, Symbol
};

// A struct representing a WebAssembly trap (error)
#[derive(TypedData)]
#[magnus(class = "Wasmtime::Trap", size, free_immediately)]
pub struct Trap {
    trap: wasmtime::Trap,
    wasm_backtrace: Option&lt;wasmtime::WasmBacktrace&gt;,
}

// No references to Ruby objects, so mark is empty
impl DataTypeFunctions for Trap {}

impl Trap {
    pub fn new(trap: wasmtime::Trap, wasm_backtrace: Option&lt;wasmtime::WasmBacktrace&gt;) -&gt; Self {
        Self {
            trap,
            wasm_backtrace,
        }
    }

    // Return a text description of the trap error
    pub fn message(&amp;self) -&gt; String {
        self.trap.to_string()
    }

    // Return the wasm backtrace if available
    pub fn wasm_backtrace_message(&amp;self) -&gt; Option&lt;String&gt; {
        self.wasm_backtrace.as_ref().map(|bt| format!("{bt}"))
    }

    // Return the trap code as a Ruby symbol
    pub fn code(&amp;self) -&gt; Result&lt;Option&lt;Symbol&gt;, Error&gt; {
        match self.trap {
            wasmtime::Trap::StackOverflow =&gt; Ok(Some(Symbol::new("STACK_OVERFLOW"))),
            wasmtime::Trap::MemoryOutOfBounds =&gt; Ok(Some(Symbol::new("MEMORY_OUT_OF_BOUNDS"))),
            // More cases...
            _ =&gt; Ok(Some(Symbol::new("UNKNOWN"))),
        }
    }

    // Custom inspect method
    pub fn inspect(rb_self: Obj&lt;Self&gt;) -&gt; Result&lt;String, Error&gt; {
        Ok(format!(
            "#&lt;Wasmtime::Trap:0x{:016x} @trap_code={}&gt;",
            rb_self.as_raw(),
            rb_self.code()?.map_or("nil".to_string(), |s| s.to_string())
        ))
    }
}

// Register with Ruby
pub fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let class = ruby.define_class("Trap", ruby.class_object())?;

    class.define_method("message", method!(Trap::message, 0))?;
    class.define_method("wasm_backtrace_message", method!(Trap::wasm_backtrace_message, 0))?;
    class.define_method("code", method!(Trap::code, 0))?;
    class.define_method("inspect", method!(Trap::inspect, 0))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>This example shows:</p>
<ol>
<li>A Rust struct that wraps WebAssembly-specific types</li>
<li>Methods that convert Rust values to Ruby-friendly types</li>
<li>A simple implementation of <code>DataTypeFunctions</code> (since there are no Ruby object references to mark)</li>
</ol>
<h2 id="more-complex-example-memory-references"><a class="header" href="#more-complex-example-memory-references">More Complex Example: Memory References</a></h2>
<p>Let's look at a more complex scenario involving memory management:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{
    prelude::*, gc::Marker, Error, Ruby, TypedData, DataTypeFunctions,
    typed_data::Obj, value::Opaque, RString
};

// Represents WebAssembly memory
#[derive(TypedData)]
#[magnus(class = "Wasmtime::Memory", free_immediately, mark)]
struct Memory {
    // Reference to a store (context) object
    store: StoreContext,
    // The actual WebAssembly memory
    memory: WasmMemory,
}

impl DataTypeFunctions for Memory {
    fn mark(&amp;self, marker: &amp;Marker) {
        // Mark the store so it stays alive
        self.store.mark(marker);
    }
}

// A guard that ensures memory access is safe
struct MemoryGuard {
    // Reference to Memory object
    memory: Opaque&lt;Obj&lt;Memory&gt;&gt;,
    // Size when created, to detect resizing
    original_size: u64,
}

impl MemoryGuard {
    fn new(memory: Obj&lt;Memory&gt;) -&gt; Result&lt;Self, Error&gt; {
        let original_size = memory.size()?;

        Ok(Self {
            memory: memory.into(),
            original_size,
        })
    }

    fn get(&amp;self) -&gt; Result&lt;&amp;Memory, Error&gt; {
        let ruby = Ruby::get().unwrap();
        let mem = ruby.get_inner_ref(&amp;self.memory);

        // Check that memory size hasn't changed
        if mem.size()? != self.original_size {
            return Err(Error::new(
                magnus::exception::runtime_error(),
                "memory was resized, reference is no longer valid"
            ));
        }

        Ok(mem)
    }

    fn mark(&amp;self, marker: &amp;Marker) {
        marker.mark(self.memory);
    }
}

// A slice of WebAssembly memory
#[derive(TypedData)]
#[magnus(class = "Wasmtime::MemorySlice", free_immediately, mark)]
struct MemorySlice {
    guard: MemoryGuard,
    offset: usize,
    size: usize,
}

impl DataTypeFunctions for MemorySlice {
    fn mark(&amp;self, marker: &amp;Marker) {
        // Mark the memory guard, which marks the memory object
        self.guard.mark(marker);
    }
}

impl MemorySlice {
    fn new(memory: Obj&lt;Memory&gt;, offset: usize, size: usize) -&gt; Result&lt;Self, Error&gt; {
        let guard = MemoryGuard::new(memory)?;

        // Validate the slice is in bounds
        let mem = guard.get()?;
        if offset + size &gt; mem.data_size()? {
            return Err(Error::new(
                magnus::exception::range_error(),
                "memory slice out of bounds"
            ));
        }

        Ok(Self {
            guard,
            offset,
            size,
        })
    }

    // Read the slice as a Ruby string (efficiently, without copying)
    fn to_str(&amp;self) -&gt; Result&lt;RString, Error&gt; {
        let ruby = unsafe { Ruby::get_unchecked() };
        let mem = self.guard.get()?;
        let data = mem.data()?;

        // Extract the relevant slice
        let slice = &amp;data[self.offset..self.offset + self.size];

        // Create a Ruby string directly from the slice (zero-copy)
        Ok(ruby.str_from_slice(slice))
    }

    // Read the slice as a UTF-8 string (with validation)
    fn to_utf8_str(&amp;self) -&gt; Result&lt;RString, Error&gt; {
        let ruby = unsafe { Ruby::get_unchecked() };
        let mem = self.guard.get()?;
        let data = mem.data()?;

        // Extract the relevant slice
        let slice = &amp;data[self.offset..self.offset + self.size];

        // Validate UTF-8 and create a Ruby string
        match std::str::from_utf8(slice) {
            Ok(s) =&gt; Ok(RString::new(s)),
            Err(e) =&gt; Err(Error::new(
                magnus::exception::encoding_error(),
                format!("invalid UTF-8: {}", e)
            ))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This more advanced example demonstrates:</p>
<ol>
<li><strong>Guarded Resource Access</strong>: The <code>MemoryGuard</code> ensures memory operations are safe by checking for resizing</li>
<li><strong>Proper GC Integration</strong>: Both structs implement marking to ensure referenced objects aren't collected</li>
<li><strong>Efficient String Creation</strong>: Using <code>str_from_slice</code> to create strings directly from memory without extra copying</li>
<li><strong>Error Handling</strong>: All operations that might fail return meaningful errors</li>
<li><strong>Resource Validation</strong>: The code validates bounds before accessing memory</li>
</ol>
<h2 id="common-memory-management-pitfalls"><a class="header" href="#common-memory-management-pitfalls">Common Memory Management Pitfalls</a></h2>
<div class="warning">
<p>These pitfalls can lead to crashes, memory leaks, or undefined behavior in your Ruby extensions. Understanding and
avoiding them is crucial for writing reliable code.</p>
</div>
<h3 id="1-forgetting-to-mark-references"><a class="header" href="#1-forgetting-to-mark-references">1. Forgetting to Mark References</a></h3>
<p>If your Rust struct holds Ruby objects but doesn't implement marking, those objects might be collected while still in
use:</p>
<pre><pre class="playground"><code class="language-rust hidelines=#"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use magnus::{gc::Marker, DataTypeFunctions, Value};
</span><span class="boring">
</span>// BAD: No marking implementation
struct BadExample {
    ruby_object: Value,  // This reference won't be marked by GC
}

<span class="boring">impl DataTypeFunctions for BadExample {
</span><span class="boring">    // Missing mark implementation!
</span><span class="boring">}
</span><span class="boring">
</span>// GOOD: Proper marking
struct GoodExample {
    ruby_object: Value,
}

impl DataTypeFunctions for GoodExample {
    fn mark(&amp;self, marker: &amp;Marker) {
        marker.mark(self.ruby_object);
    }
}

<span class="boring">// A more complex example with multiple references
</span><span class="boring">struct ComplexExample {
</span><span class="boring">    ruby_strings: Vec&lt;Value&gt;,
</span><span class="boring">    ruby_hash: Value,
</span><span class="boring">    ruby_object: Value,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DataTypeFunctions for ComplexExample {
</span><span class="boring">    fn mark(&amp;self, marker: &amp;Marker) {
</span><span class="boring">        // Mark each string in the vector
</span><span class="boring">        for string in &amp;self.ruby_strings {
</span><span class="boring">            marker.mark(*string);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Mark the hash and object
</span><span class="boring">        marker.mark(self.ruby_hash);
</span><span class="boring">        marker.mark(self.ruby_object);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="tip">
<p>Click the eye icon (<i class="fa fa-eye"></i>) to see an additional example of marking multiple references in a more
complex struct.</p>
</div>
<h3 id="2-creating-cyclic-references"><a class="header" href="#2-creating-cyclic-references">2. Creating Cyclic References</a></h3>
<p>Cyclic references (A references B, which references A) can lead to memory leaks. Consider using weak references or
redesigning your object graph.</p>
<h3 id="3-inefficient-string-creation"><a class="header" href="#3-inefficient-string-creation">3. Inefficient String Creation</a></h3>
<div class="note">
<p>String handling is often a performance bottleneck in Ruby extensions. Using the right APIs can significantly improve
performance.</p>
</div>
<p>Creating strings inefficiently can significantly impact performance:</p>
<pre><pre class="playground"><code class="language-rust hidelines=#"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use magnus::{Error, RString, Ruby};
</span><span class="boring">
</span>// BAD: Creates unnecessary temporary Rust String
fn inefficient_string(data: &amp;[u8]) -&gt; Result&lt;RString, Error&gt; {
    let temp_string = String::from_utf8(data.to_vec())?; // Unnecessary allocation
    Ok(RString::new(&amp;temp_string))  // Another copy
}

// GOOD: Direct creation from slice
fn efficient_string(ruby: &amp;Ruby, data: &amp;[u8]) -&gt; RString {
    ruby.str_from_slice(data)  // No extra copies
}

<span class="boring">// ALSO GOOD: Creating from string slice when UTF-8 is confirmed
</span><span class="boring">fn from_str(ruby: &amp;Ruby, s: &amp;str) -&gt; RString {
</span><span class="boring">    RString::new(s)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// ALSO GOOD: Creating binary string with capacity then filling
</span><span class="boring">fn build_string(ruby: &amp;Ruby, size: usize) -&gt; RString {
</span><span class="boring">    let mut string = RString::with_capacity(size);
</span><span class="boring">    // Fill the string directly...
</span><span class="boring">    string
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="tip">
<p>Both memory usage and performance are significantly improved by avoiding unnecessary allocations and copies. The eye
icon (<i class="fa fa-eye"></i>) reveals additional efficient string handling examples.</p>
</div>
<h3 id="4-not-handling-exceptions-properly"><a class="header" href="#4-not-handling-exceptions-properly">4. Not Handling Exceptions Properly</a></h3>
<p>Ruby exceptions can disrupt the normal flow of your code. Ensure resources are cleaned up even when exceptions occur.</p>
<h2 id="refcell-and-interior-mutability"><a class="header" href="#refcell-and-interior-mutability">RefCell and Interior Mutability</a></h2>
<p>When creating Ruby objects with Rust, you'll often need to use interior mutability patterns. The most common approach is
using <code>RefCell</code> to allow your Ruby objects to be mutated even when users hold immutable references to them.</p>
<h3 id="understanding-refcell-and-borrowing"><a class="header" href="#understanding-refcell-and-borrowing">Understanding RefCell and Borrowing</a></h3>
<p>Rust's <code>RefCell</code> allows mutable access to data through shared references, but enforces Rust's borrowing rules at
runtime. This is perfect for Ruby extension objects, where Ruby owns the object and we interact with it via method
calls.</p>
<p>A common pattern is to wrap your Rust struct in a <code>RefCell</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;
use magnus::{prelude::*, Error, Ruby};

struct Counter {
    count: i64,
}

#[magnus::wrap(class = "MyExtension::Counter")]
struct MutCounter(RefCell&lt;Counter&gt;);

impl MutCounter {
    fn new(initial: i64) -&gt; Self {
        Self(RefCell::new(Counter { count: initial }))
    }

    fn count(&amp;self) -&gt; i64 {
        self.0.borrow().count
    }

    fn increment(&amp;self) -&gt; i64 {
        let mut counter = self.0.borrow_mut();
        counter.count += 1;
        counter.count
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="the-borrowmuterror-problem"><a class="header" href="#the-borrowmuterror-problem">The BorrowMutError Problem</a></h3>
<p>A common mistake when using <code>RefCell</code> is trying to borrow mutably when you already have an active immutable borrow. This
leads to a <code>BorrowMutError</code> panic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD - will panic with "already borrowed: BorrowMutError"
fn buggy_add(&amp;self, val: i64) -&gt; Result&lt;i64, Error&gt; {
    // First borrow is still active when we try to borrow_mut below
    if let Some(sum) = self.0.borrow().count.checked_add(val) {
        self.0.borrow_mut().count = sum; // ERROR - already borrowed above
        Ok(sum)
    } else {
        Err(Error::new(
            ruby.exception_range_error(),
            "result too large"
        ))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The problem is that the <code>borrow()</code> in the <code>if</code> condition is still active when we try to use <code>borrow_mut()</code> in the body.
Rust's borrow checker would catch this at compile time for normal references, but <code>RefCell</code> defers this check to
runtime, resulting in a panic.</p>
<h3 id="the-solution-complete-borrows-before-mutating"><a class="header" href="#the-solution-complete-borrows-before-mutating">The Solution: Complete Borrows Before Mutating</a></h3>
<p>The solution is to complete all immutable borrows before starting mutable ones:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GOOD - copy the value first to complete the borrow
fn safe_add(&amp;self, val: i64) -&gt; Result&lt;i64, Error&gt; {
    // Get the current count, completing this borrow
    let current_count = self.0.borrow().count;

    // Now we can safely borrow mutably
    if let Some(sum) = current_count.checked_add(val) {
        self.0.borrow_mut().count = sum; // Safe now
        Ok(sum)
    } else {
        Err(Error::new(
            ruby.exception_range_error(),
            "result too large"
        ))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>By copying <code>count</code> to a local variable, we complete the immutable borrow before starting the mutable one, avoiding the
runtime panic.</p>
<h3 id="complex-example-with-multiple-operations"><a class="header" href="#complex-example-with-multiple-operations">Complex Example with Multiple Operations</a></h3>
<p>When working with more complex data structures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Game {
    players: Vec&lt;String&gt;,
    current_player: usize,
    score: i64,
}

#[magnus::wrap(class = "MyGame")]
struct MutGame(RefCell&lt;Game&gt;);

impl MutGame {
    fn new() -&gt; Self {
        Self(RefCell::new(Game {
            players: Vec::new(),
            current_player: 0,
            score: 0,
        }))
    }

    // INCORRECT: Multiple borrows that will cause issues
    fn buggy_next_player_scores(&amp;self, points: i64) -&gt; Result&lt;String, Error&gt; {
        let game = self.0.borrow();
        if game.players.is_empty() {
            return Err(Error::new(
                magnus::exception::runtime_error(),
                "No players in game"
            ));
        }

        // This would panic - we're still borrowing game
        let mut game_mut = self.0.borrow_mut();
        game_mut.score += points;
        let player = game_mut.current_player;
        game_mut.current_player = (player + 1) % game_mut.players.len();

        Ok(format!("{} scored {} points! New total: {}",
            game_mut.players[player], points, game_mut.score))
    }

    // CORRECT: Copy all needed data before releasing the borrow
    fn safe_next_player_scores(&amp;self, points: i64) -&gt; Result&lt;String, Error&gt; {
        // Read all the data we need first
        let player_name: String;
        let new_player_index: usize;
        let new_score: i64;

        {
            // Create a block scope to ensure the borrow is dropped
            let game = self.0.borrow();
            if game.players.is_empty() {
                return Err(Error::new(
                    magnus::exception::runtime_error(),
                    "No players in game"
                ));
            }

            player_name = game.players[game.current_player].clone();
            new_player_index = (game.current_player + 1) % game.players.len();
            new_score = game.score + points;
        } // borrow is dropped here

        // Now we can borrow mutably
        let mut game = self.0.borrow_mut();
        game.score = new_score;
        game.current_player = new_player_index;

        Ok(format!("{} scored {} points! New total: {}",
            player_name, points, new_score))
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-temporary-variables-instead-of-block-scopes"><a class="header" href="#using-temporary-variables-instead-of-block-scopes">Using Temporary Variables Instead of Block Scopes</a></h3>
<p>If you prefer, you can use temporary variables instead of block scopes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_player(&amp;self, player: String) -&gt; Result&lt;usize, Error&gt; {
    // Get the current number of players first
    let player_count = self.0.borrow().players.len();

    // Now we can mutate
    let mut game = self.0.borrow_mut();
    game.players.push(player);

    Ok(player_count + 1) // Return new count
}
<span class="boring">}</span></code></pre></pre>
<h3 id="refcell-best-practices"><a class="header" href="#refcell-best-practices">RefCell Best Practices</a></h3>
<ol>
<li>
<p><strong>Complete All Borrows</strong>: Always complete immutable borrows before starting mutable borrows.</p>
</li>
<li>
<p><strong>Use Block Scopes or Variables</strong>: Either use block scopes to limit borrow lifetimes or copy needed values to local
variables.</p>
</li>
<li>
<p><strong>Minimize Borrow Scope</strong>: Keep the scope of borrows as small as possible.</p>
</li>
<li>
<p><strong>Clone When Necessary</strong>: If you need to keep references to data while mutating other parts, clone the data you need
to keep.</p>
</li>
<li>
<p><strong>Consider Data Design</strong>: Structure your data to minimize the need for complex borrowing patterns.</p>
</li>
<li>
<p><strong>Error When Conflicting</strong>: If you can't resolve a borrowing conflict cleanly, make the operation an error rather
than trying to force it.</p>
</li>
</ol>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<ol>
<li><strong>Use TypedData and DataTypeFunctions</strong>: They provide a safe framework for memory management</li>
<li><strong>Always Implement Mark Methods</strong>: Mark all Ruby objects your struct references</li>
<li><strong>Validate Assumptions</strong>: Check that resources are valid before using them</li>
<li><strong>Use Zero-Copy APIs</strong>: Leverage APIs like <code>str_from_slice</code> to avoid unnecessary copying</li>
<li><strong>Use Guards for Changing Data</strong>: Validate assumptions before accessing data that might change</li>
<li><strong>Test Thoroughly with GC Stress</strong>: Run tests with <code>GC.stress = true</code> to expose memory issues</li>
<li><strong>Handle RefCell Borrowing Carefully</strong>: Complete all immutable borrows before starting mutable ones to avoid runtime
panics</li>
</ol>
<p>By following these practices, you can write Ruby extensions in Rust that are both memory-safe and efficient.</p>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<p>In the next chapter, we'll explore performance optimization techniques that leverage Rust's strengths while maintaining
memory safety.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-build-process"><a class="header" href="#the-build-process">The Build Process</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>This chapter explains what happens behind the scenes when rb-sys compiles your Rust extension, helping you debug issues
and optimize builds.</p>
<p>This chapter explains what happens behind the scenes when rb-sys compiles your Rust extension. Understanding this
process will help you debug issues and optimize your extension.</p>
<h2 id="how-rb-sys-compiles-your-code"><a class="header" href="#how-rb-sys-compiles-your-code">How rb-sys Compiles Your Code</a></h2>
<p>When you run <code>bundle exec rake compile</code>, several steps happen in sequence:</p>
<ol>
<li>Ruby's <code>mkmf</code> system reads your <code>extconf.rb</code> file</li>
<li>The <code>create_rust_makefile</code> function generates a Makefile</li>
<li>Cargo builds your Rust code as a dynamic library</li>
<li>The resulting binary is copied to your gem's lib directory</li>
</ol>
<p>Let's examine each step in detail.</p>
<h2 id="the-role-of-extconfrb"><a class="header" href="#the-role-of-extconfrb">The Role of extconf.rb</a></h2>
<p>The <code>extconf.rb</code> file is the entry point for Ruby's native extension system. For rb-sys projects, it typically looks
like this:</p>
<pre><code class="language-ruby"># extconf.rb
require "mkmf"
require "rb_sys/mkmf"

create_rust_makefile("my_gem/my_gem")
</code></pre>
<p>The <code>create_rust_makefile</code> function:</p>
<ol>
<li>Sets up the environment for compiling Rust code</li>
<li>Generates a Makefile with appropriate Cargo commands</li>
<li>Configures where the compiled library should be placed</li>
</ol>
<h3 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h3>
<p>You can customize the build process by passing a block to <code>create_rust_makefile</code>:</p>
<pre><code class="language-ruby">create_rust_makefile("my_gem/my_gem") do |config|
  # Set cargo profile (defaults to ENV["RB_SYS_CARGO_PROFILE"] or :dev)
  config.profile = ENV.fetch("MY_GEM_PROFILE", :dev).to_sym

  # Enable specific cargo features
  config.features = ["feature1", "feature2"]

  # Set environment variables for cargo
  config.env = { "SOME_VAR" =&gt; "value" }

  # Specify extra Rust flags
  config.extra_rustflags = ["--cfg=feature=\"custom_feature\""]

  # Clean up target directory after installation to reduce gem size
  config.clean_after_install = true

  # Force installation of Rust toolchain if not present
  config.force_install_rust_toolchain = "stable"

  # Auto-install Rust toolchain during gem installation
  config.auto_install_rust_toolchain = true
end
</code></pre>
<p>For a complete reference of all available configuration options, see the
<a href="./api-reference/rb-sys-gem-config.html">rb_sys Gem Configuration</a> documentation.</p>
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h2>
<p>Several environment variables affect the build process:</p>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>RB_SYS_CARGO_PROFILE</code></td><td>Cargo profile to use (<code>dev</code> or <code>release</code>)</td><td><code>dev</code></td></tr>
<tr><td><code>RB_SYS_CARGO_FEATURES</code></td><td>Comma-separated list of features to enable</td><td>None</td></tr>
<tr><td><code>RB_SYS_CARGO_ARGS</code></td><td>Additional arguments to pass to cargo</td><td>None</td></tr>
</tbody></table>
</div>
<p>For example:</p>
<pre><code class="language-bash">RB_SYS_CARGO_PROFILE=release bundle exec rake compile
</code></pre>
<h2 id="debugging-the-build-process"><a class="header" href="#debugging-the-build-process">Debugging the Build Process</a></h2>
<p>When things go wrong, you can debug the build process:</p>
<h3 id="1-enable-verbose-output"><a class="header" href="#1-enable-verbose-output">1. Enable Verbose Output</a></h3>
<pre><code class="language-bash">bundle exec rake compile VERBOSE=1
</code></pre>
<h3 id="2-inspect-generated-files"><a class="header" href="#2-inspect-generated-files">2. Inspect Generated Files</a></h3>
<p>Look at the generated Makefile and Cargo configuration:</p>
<pre><code class="language-bash">cat ext/my_gem/Makefile
</code></pre>
<h3 id="3-run-cargo-directly"><a class="header" href="#3-run-cargo-directly">3. Run Cargo Directly</a></h3>
<p>You can run Cargo commands directly in the extension directory:</p>
<pre><code class="language-bash">cd ext/my_gem
cargo build -v
</code></pre>
<h2 id="optimizing-the-build"><a class="header" href="#optimizing-the-build">Optimizing the Build</a></h2>
<h3 id="development-vs-release-builds"><a class="header" href="#development-vs-release-builds">Development vs. Release Builds</a></h3>
<p>During development, use the default dev profile for faster compilation:</p>
<pre><code class="language-bash">RB_SYS_CARGO_PROFILE=dev bundle exec rake compile
</code></pre>
<p>For production releases, use the release profile for optimized performance:</p>
<pre><code class="language-bash">RB_SYS_CARGO_PROFILE=release bundle exec rake compile
</code></pre>
<h3 id="cargo-configuration"><a class="header" href="#cargo-configuration">Cargo Configuration</a></h3>
<p>In your Cargo.toml, you can customize optimization levels:</p>
<pre><code class="language-toml">[profile.release]
lto = true             # Link-time optimization
opt-level = 3          # Maximum optimization
codegen-units = 1      # Optimize for size at the expense of compile time
</code></pre>
<h3 id="build-scripts-buildrs"><a class="header" href="#build-scripts-buildrs">Build Scripts (build.rs)</a></h3>
<p>For advanced customization, you can use Rust's build script feature:</p>
<pre><pre class="playground"><code class="language-rust">// ext/my_gem/build.rs
fn main() {
    // Detect features at build time
    if std::env::var("TARGET").unwrap().contains("windows") {
        println!("cargo:rustc-cfg=feature=\"windows\"");
    }

    // Link to system libraries if needed
    println!("cargo:rustc-link-lib=dylib=ssl");

    // Rerun if specific files change
    println!("cargo:rerun-if-changed=src/native_code.h");
}</code></pre></pre>
<p>Remember to add this to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml"># ext/my_gem/Cargo.toml
[package]
# ...
build = "build.rs"
</code></pre>
<h2 id="cross-compilation-with-rb-sys-dock"><a class="header" href="#cross-compilation-with-rb-sys-dock">Cross-Compilation with rb-sys-dock</a></h2>
<p>The real power of rb-sys is its ability to cross-compile extensions using <code>rb-sys-dock</code>. This tool runs your build in
Docker containers configured for different platforms.</p>
<h3 id="basic-cross-compilation"><a class="header" href="#basic-cross-compilation">Basic Cross-Compilation</a></h3>
<p>To set up cross-compilation with the <code>RbSys::ExtensionTask</code>:</p>
<pre><code class="language-ruby"># Rakefile
RbSys::ExtensionTask.new("my_gem", GEMSPEC) do |ext|
  ext.lib_dir = "lib/my_gem"
  ext.cross_compile = true
  ext.cross_platform = ['x86_64-linux', 'x86_64-darwin', 'arm64-darwin']
end
</code></pre>
<p>Then you can cross-compile with:</p>
<pre><code class="language-bash">bundle exec rake native:my_gem:x86_64-linux
</code></pre>
<h3 id="using-rb-sys-dock-directly"><a class="header" href="#using-rb-sys-dock-directly">Using rb-sys-dock Directly</a></h3>
<p>You can also use rb-sys-dock directly:</p>
<pre><code class="language-bash">bundle exec rb-sys-dock --platform x86_64-linux --build
</code></pre>
<h3 id="supported-platforms"><a class="header" href="#supported-platforms">Supported Platforms</a></h3>
<p>rb-sys supports many platforms, including:</p>
<ul>
<li>x86_64-linux (Linux on Intel/AMD 64-bit)</li>
<li>x86_64-linux-musl (Static Linux builds)</li>
<li>aarch64-linux (Linux on ARM64)</li>
<li>x86_64-darwin (macOS on Intel)</li>
<li>arm64-darwin (macOS on Apple Silicon)</li>
<li>x64-mingw-ucrt (Windows 64-bit UCRT)</li>
</ul>
<h2 id="cicd-with-oxidize-rbactions"><a class="header" href="#cicd-with-oxidize-rbactions">CI/CD with oxidize-rb/actions</a></h2>
<p>The <a href="https://github.com/oxidize-rb/actions">oxidize-rb/actions</a> repository provides GitHub Actions specifically designed
for rb-sys projects:</p>
<h3 id="setup-ruby-and-rust"><a class="header" href="#setup-ruby-and-rust">setup-ruby-and-rust</a></h3>
<pre><code class="language-yaml"># .github/workflows/ci.yml
jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        ruby: [3.0, 3.1, 3.2, 3.3]
    steps:
      - uses: actions/checkout@v4
      - uses: oxidize-rb/actions/setup-ruby-and-rust@v1
        with:
          ruby-version: ${{ matrix.ruby }}
          bundler-cache: true
          cargo-cache: true
      - name: Compile
        run: bundle exec rake compile
      - name: Test
        run: bundle exec rake test
</code></pre>
<h3 id="cross-gem"><a class="header" href="#cross-gem">cross-gem</a></h3>
<pre><code class="language-yaml"># .github/workflows/cross-gem.yml
jobs:
  cross_gems:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        platform: ["x86_64-linux", "x86_64-darwin", "arm64-darwin"]
    steps:
      - uses: actions/checkout@v4
      - uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.3"
      - uses: oxidize-rb/actions/cross-gem@v1
        with:
          platform: ${{ matrix.platform }}
</code></pre>
<p>For a complete CI/CD setup, combine these actions to test your extension on multiple Ruby versions and platforms, then
cross-compile for release.</p>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<ul>
<li>Explore <a href="cross-platform.html">Cross-Platform Development</a> to learn about cross-compilation.</li>
<li>Learn <a href="debugging.html">Debugging</a> techniques to troubleshoot build failures.</li>
<li>See <a href="testing.html">Testing Extensions</a> for CI/CD testing strategies.</li>
<li>Dive into <a href="project-setup.html">Project Setup</a> for organizing your gem’s structure.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-platform-development"><a class="header" href="#cross-platform-development">Cross-Platform Development</a></h1>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>One of rb-sys's greatest strengths is its support for cross-platform Ruby extensions. This chapter covers how to
develop, test, and distribute extensions across multiple platforms.</p>
<h2 id="supported-platforms-1"><a class="header" href="#supported-platforms-1">Supported Platforms</a></h2>
<p>rb-sys supports cross-compilation to the following platforms:</p>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>Supported</th><th>Docker Image</th></tr></thead><tbody>
<tr><td>x86_64-linux</td><td>✅</td><td><code>rbsys/x86_64-linux</code></td></tr>
<tr><td>x86_64-linux-musl</td><td>✅</td><td><code>rbsys/x86_64-linux-musl</code></td></tr>
<tr><td>aarch64-linux</td><td>✅</td><td><code>rbsys/aarch64-linux</code></td></tr>
<tr><td>aarch64-linux-musl</td><td>✅</td><td><code>rbsys/aarch64-linux-musl</code></td></tr>
<tr><td>arm-linux</td><td>✅</td><td><code>rbsys/arm-linux</code></td></tr>
<tr><td>arm64-darwin</td><td>✅</td><td><code>rbsys/arm64-darwin</code></td></tr>
<tr><td>x64-mingw32</td><td>✅</td><td><code>rbsys/x64-mingw32</code></td></tr>
<tr><td>x64-mingw-ucrt</td><td>✅</td><td><code>rbsys/x64-mingw-ucrt</code></td></tr>
<tr><td>mswin</td><td>✅</td><td>not available on Docker</td></tr>
<tr><td>truffleruby</td><td>✅</td><td>not available on Docker</td></tr>
</tbody></table>
</div>
<p>The Docker images are available on <a href="https://hub.docker.com/r/rbsys/rcd">Docker Hub</a> and are automatically updated with
each rb-sys release.</p>
<h2 id="platform-considerations"><a class="header" href="#platform-considerations">Platform Considerations</a></h2>
<p>Ruby extensions face several cross-platform challenges:</p>
<ul>
<li>Different operating systems (Linux, macOS, Windows)</li>
<li>Different CPU architectures (x86_64, ARM64)</li>
<li>Different Ruby implementations</li>
<li>Different compilers and linkers</li>
<li>System libraries and dependencies</li>
</ul>
<p>rb-sys provides tools to handle these differences effectively.</p>
<h2 id="understanding-platform-targets"><a class="header" href="#understanding-platform-targets">Understanding Platform Targets</a></h2>
<p>Ruby identifies platforms with standardized strings:</p>
<div class="table-wrapper"><table><thead><tr><th>Platform String</th><th>Description</th></tr></thead><tbody>
<tr><td><code>x86_64-linux</code></td><td>64-bit Linux on Intel/AMD</td></tr>
<tr><td><code>aarch64-linux</code></td><td>64-bit Linux on ARM</td></tr>
<tr><td><code>x86_64-darwin</code></td><td>64-bit macOS on Intel</td></tr>
<tr><td><code>arm64-darwin</code></td><td>64-bit macOS on Apple Silicon</td></tr>
<tr><td><code>x64-mingw-ucrt</code></td><td>64-bit Windows (UCRT)</td></tr>
<tr><td><code>x64-mingw32</code></td><td>64-bit Windows (older)</td></tr>
</tbody></table>
</div>
<p>These platform strings are used by:</p>
<ul>
<li>RubyGems to select the correct pre-built binary</li>
<li>rake-compiler for cross-compilation</li>
<li>rb-sys-dock to build for different platforms</li>
</ul>
<h2 id="conditional-compilation"><a class="header" href="#conditional-compilation">Conditional Compilation</a></h2>
<p>Rust's conditional compilation features allow you to write platform-specific code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Platform-specific code
#[cfg(target_os = "windows")]
fn platform_specific() {
    // Windows-specific implementation
}

#[cfg(target_os = "macos")]
fn platform_specific() {
    // macOS-specific implementation
}

#[cfg(target_os = "linux")]
fn platform_specific() {
    // Linux-specific implementation
}
<span class="boring">}</span></code></pre></pre>
<p>For architectures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_arch = "x86_64")]
fn arch_specific() {
    // x86_64 implementation
}

#[cfg(target_arch = "aarch64")]
fn arch_specific() {
    // ARM64 implementation
}
<span class="boring">}</span></code></pre></pre>
<h3 id="complete-example-file-path-handling"><a class="header" href="#complete-example-file-path-handling">Complete Example: File Path Handling</a></h3>
<p>Here's a real-world example of handling paths differently across platforms:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::path::PathBuf;

fn get_config_path() -&gt; PathBuf {
    #[cfg(target_os = "windows")]
    {
        let mut path = PathBuf::new();
        if let Some(profile) = std::env::var_os("USERPROFILE") {
            path.push(profile);
            path.push("AppData");
            path.push("Roaming");
            path.push("MyApp");
            path.push("config.toml");
        }
        path
    }

    #[cfg(target_os = "macos")]
    {
        let mut path = PathBuf::new();
        if let Some(home) = std::env::var_os("HOME") {
            path.push(home);
            path.push("Library");
            path.push("Application Support");
            path.push("MyApp");
            path.push("config.toml");
        }
        path
    }

    #[cfg(target_os = "linux")]
    {
        let mut path = PathBuf::new();
        if let Some(config_dir) = std::env::var_os("XDG_CONFIG_HOME") {
            path.push(config_dir);
        } else if let Some(home) = std::env::var_os("HOME") {
            path.push(home);
            path.push(".config");
        }
        path.push("myapp");
        path.push("config.toml");
        path
    }

    #[cfg(not(any(target_os = "windows", target_os = "macos", target_os = "linux")))]
    {
        // Default for other platforms
        PathBuf::from("config.toml")
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="platform-specific-dependencies"><a class="header" href="#platform-specific-dependencies">Platform-Specific Dependencies</a></h2>
<p>Cargo.toml supports platform-specific dependencies:</p>
<pre><code class="language-toml">[dependencies]
# Common dependencies...

[target.'cfg(target_os = "linux")'.dependencies]
jemallocator = { version = "0.5", features = ["disable_initial_exec_tls"] }

[target.'cfg(target_os = "windows")'.dependencies]
winapi = { version = "0.3", features = ["winbase"] }

[target.'cfg(target_os = "macos")'.dependencies]
core-foundation = "0.9"
</code></pre>
<h3 id="example-system-specific-memory-allocation"><a class="header" href="#example-system-specific-memory-allocation">Example: System-specific Memory Allocation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_os = "linux")]
use jemallocator::Jemalloc;

#[cfg(target_os = "linux")]
#[global_allocator]
static GLOBAL: Jemalloc = Jemalloc;

// Rest of your code...
<span class="boring">}</span></code></pre></pre>
<h2 id="using-buildrs-for-platform-detection"><a class="header" href="#using-buildrs-for-platform-detection">Using build.rs for Platform Detection</a></h2>
<p>The Rust build script (<code>build.rs</code>) can be used to detect platforms and configure builds:</p>
<pre><pre class="playground"><code class="language-rust">// ext/my_gem/build.rs
fn main() {
    // Detect OS
    let target = std::env::var("TARGET").unwrap_or_default();

    if target.contains("windows") {
        println!("cargo:rustc-link-lib=dylib=user32");
        println!("cargo:rustc-cfg=feature=\"windows_specific\"");
    } else if target.contains("darwin") {
        println!("cargo:rustc-link-lib=framework=CoreFoundation");
        println!("cargo:rustc-cfg=feature=\"macos_specific\"");
    } else if target.contains("linux") {
        println!("cargo:rustc-link-lib=dylib=dl");
        println!("cargo:rustc-cfg=feature=\"linux_specific\"");
    }

    // Tell Cargo to invalidate the built crate whenever the build script changes
    println!("cargo:rerun-if-changed=build.rs");
}</code></pre></pre>
<p>Then in your code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = "windows_specific")]
fn platform_init() {
    // Windows initialization code
}

#[cfg(feature = "macos_specific")]
fn platform_init() {
    // macOS initialization code
}

#[cfg(feature = "linux_specific")]
fn platform_init() {
    // Linux initialization code
}
<span class="boring">}</span></code></pre></pre>
<h2 id="cross-compilation-with-rb-sys-dock-1"><a class="header" href="#cross-compilation-with-rb-sys-dock-1">Cross-Compilation with rb-sys-dock</a></h2>
<p>rb-sys-dock is a Docker-based tool that simplifies cross-compilation:</p>
<h3 id="setting-up-rb-sys-dock-in-your-gem"><a class="header" href="#setting-up-rb-sys-dock-in-your-gem">Setting Up rb-sys-dock in Your Gem</a></h3>
<ol>
<li>Add rb-sys-dock to your Gemfile:</li>
</ol>
<pre><code class="language-ruby"># Gemfile
group :development do
  gem "rb-sys-dock", "~&gt; 0.1"
end
</code></pre>
<ol start="2">
<li>Configure your Rakefile for cross-compilation:</li>
</ol>
<pre><code class="language-ruby"># Rakefile
require "rb_sys/extensiontask"

GEMSPEC = Gem::Specification.load("my_gem.gemspec")

RbSys::ExtensionTask.new("my_gem", GEMSPEC) do |ext|
  ext.lib_dir = "lib/my_gem"
  ext.cross_compile = true
  ext.cross_platform = [
    "x86_64-linux",
    "aarch64-linux",
    "x86_64-darwin",
    "arm64-darwin",
    "x64-mingw-ucrt"
  ]
end
</code></pre>
<h3 id="building-for-a-specific-platform"><a class="header" href="#building-for-a-specific-platform">Building for a Specific Platform</a></h3>
<p>To build for a specific platform:</p>
<pre><code class="language-bash">bundle exec rake native:my_gem:x86_64-linux
</code></pre>
<p>This creates a platform-specific gem in the <code>pkg</code> directory.</p>
<h3 id="building-for-all-platforms"><a class="header" href="#building-for-all-platforms">Building for All Platforms</a></h3>
<p>To build for all configured platforms:</p>
<pre><code class="language-bash">bundle exec rake native
</code></pre>
<h3 id="using-rb-sys-dock-directly-1"><a class="header" href="#using-rb-sys-dock-directly-1">Using rb-sys-dock Directly</a></h3>
<p>For more control, use rb-sys-dock directly:</p>
<pre><code class="language-bash"># Build for a specific platform
bundle exec rb-sys-dock --platform x86_64-linux --build

# Start a shell in the Docker container
bundle exec rb-sys-dock --platform x86_64-linux --shell
</code></pre>
<h2 id="testing-cross-platform-builds"><a class="header" href="#testing-cross-platform-builds">Testing Cross-Platform Builds</a></h2>
<h3 id="local-testing-with-docker"><a class="header" href="#local-testing-with-docker">Local Testing with Docker</a></h3>
<p>You can test your cross-compiled Linux extensions locally:</p>
<pre><code class="language-bash"># Run tests inside a Docker container
bundle exec rb-sys-dock --platform x86_64-linux --command "bundle exec rake test"
</code></pre>
<h3 id="local-testing-on-macos"><a class="header" href="#local-testing-on-macos">Local Testing on macOS</a></h3>
<p>If you're on macOS with Apple Silicon, you can test both architectures:</p>
<pre><code class="language-bash"># Test arm64-darwin build (native)
bundle exec rake test

# Test x86_64-darwin build (cross-compiled)
arch -x86_64 bundle exec rake test
</code></pre>
<h2 id="cicd-for-multiple-platforms"><a class="header" href="#cicd-for-multiple-platforms">CI/CD for Multiple Platforms</a></h2>
<p>GitHub Actions is ideal for testing across platforms:</p>
<h3 id="testing-on-multiple-platforms"><a class="header" href="#testing-on-multiple-platforms">Testing on Multiple Platforms</a></h3>
<pre><code class="language-yaml"># .github/workflows/test.yml
name: Test

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        ruby: ["3.0", "3.1", "3.2", "3.3"]

    runs-on: ${{ matrix.os }}

    steps:
      - uses: actions/checkout@v4
      - uses: oxidize-rb/actions/setup-ruby-and-rust@v1
        with:
          ruby-version: ${{ matrix.ruby }}
          bundler-cache: true
      - run: bundle exec rake compile
      - run: bundle exec rake test
</code></pre>
<h3 id="ruby-head-compatibility"><a class="header" href="#ruby-head-compatibility">Ruby-Head Compatibility</a></h3>
<p>When supporting <code>ruby-head</code> or development versions of Ruby, you must publish a source gem alongside your precompiled gems. This is necessary because:</p>
<ol>
<li>The Ruby ABI (Application Binary Interface) can change between development versions</li>
<li>Precompiled binary gems built against one ruby-head version may be incompatible with newer ruby-head versions</li>
<li>Source gems allow users to compile the extension against their specific ruby-head version</li>
</ol>
<p>To ensure compatibility, add a source gem to your release process:</p>
<pre><code class="language-ruby"># Rakefile
RbSys::ExtensionTask.new("my_gem", GEMSPEC) do |ext|
  # Configure cross-platform gems as usual
  ext.cross_compile = true
  ext.cross_platform = ['x86_64-linux', 'arm64-darwin', ...]

  # The default platform will build the source gem
end
</code></pre>
<p>Then in your CI/CD pipeline, include both platform-specific and source gem builds:</p>
<pre><code class="language-yaml"># .github/workflows/release.yml
jobs:
  # First build all platform-specific gems
  cross_compile:
    # ...

  # Then build the source gem
  source_gem:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.3"
      - run: bundle install
      - run: bundle exec rake build # Builds the source gem
      - uses: actions/upload-artifact@v3
        with:
          name: source-gem
          path: pkg/*.gem # Include source gem without platform suffix
</code></pre>
<h3 id="cross-compiling-for-release"><a class="header" href="#cross-compiling-for-release">Cross-Compiling for Release</a></h3>
<pre><code class="language-yaml"># .github/workflows/release.yml
name: Release

on:
  push:
    tags: ["v*"]

jobs:
  cross_compile:
    strategy:
      fail-fast: false
      matrix:
        platform: ["x86_64-linux", "aarch64-linux", "x86_64-darwin", "arm64-darwin", "x64-mingw-ucrt"]

    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
      - uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.1"
      - uses: oxidize-rb/actions/cross-gem@v1
        with:
          platform: ${{ matrix.platform }}
      - uses: actions/upload-artifact@v3
        with:
          name: gem-${{ matrix.platform }}
          path: pkg/*-${{ matrix.platform }}.gem
</code></pre>
<h3 id="complete-ci-workflow-example"><a class="header" href="#complete-ci-workflow-example">Complete CI Workflow Example</a></h3>
<p>Here's a more complete workflow showing an automated release process with tests and cross-compilation:</p>
<pre><code class="language-yaml"># .github/workflows/gem-release.yml
name: Gem Release

on:
  push:
    tags:
      - "v*"

jobs:
  fetch-data:
    runs-on: ubuntu-latest
    outputs:
      platforms: ${{ steps.fetch.outputs.supported-ruby-platforms }}
    steps:
      - id: fetch
        uses: oxidize-rb/actions/fetch-ci-data@v1
        with:
          supported-ruby-platforms: |
            exclude: [x86-linux, x86-darwin, arm-linux]

  test:
    needs: fetch-data
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        ruby: ["3.0", "3.1", "3.2", "3.3"]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4
      - uses: oxidize-rb/actions/setup-ruby-and-rust@v1
        with:
          ruby-version: ${{ matrix.ruby }}
          bundler-cache: true
      - run: bundle exec rake compile
      - run: bundle exec rake test

  cross-compile:
    needs: [fetch-data, test]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        platform: ${{ fromJSON(needs.fetch-data.outputs.platforms) }}
    steps:
      - uses: actions/checkout@v4
      - uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.1"
      - uses: oxidize-rb/actions/cross-gem@v1
        with:
          platform: ${{ matrix.platform }}
      - uses: actions/upload-artifact@v3
        with:
          name: gem-${{ matrix.platform }}
          path: pkg/*-${{ matrix.platform }}.gem

  release:
    needs: cross-compile
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.1"
      - uses: actions/download-artifact@v3
        with:
          path: artifacts
      - name: Move gems to pkg directory
        run: |
          mkdir -p pkg
          find artifacts -name "*.gem" -exec mv {} pkg/ \;
      - name: Publish to RubyGems
        run: |
          mkdir -p ~/.gem
          echo -e "---\n:rubygems_api_key: ${RUBYGEMS_API_KEY}" &gt; ~/.gem/credentials
          chmod 0600 ~/.gem/credentials
          gem push pkg/*.gem
        env:
          RUBYGEMS_API_KEY: ${{ secrets.RUBYGEMS_API_KEY }}
</code></pre>
<h2 id="platform-specific-issues-and-solutions"><a class="header" href="#platform-specific-issues-and-solutions">Platform-Specific Issues and Solutions</a></h2>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>Windows presents unique challenges for Ruby extensions:</p>
<ul>
<li>
<p><strong>Path Handling</strong>: Use forward slashes (<code>/</code>) in paths, not backslashes (<code>\</code>)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Instead of this:
let path = "C:\\Users\\Name\\file.txt";

// Do this:
let path = "C:/Users/Name/file.txt";
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>DLL Loading</strong>: Handle DLL loading carefully</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_os = "windows")]
fn load_library(name: &amp;str) -&gt; Result&lt;(), Error&gt; {
    use std::os::windows::ffi::OsStrExt;
    use std::ffi::OsStr;
    use winapi::um::libloaderapi::LoadLibraryW;

    let name_wide: Vec&lt;u16&gt; = OsStr::new(name)
        .encode_wide()
        .chain(std::iter::once(0))
        .collect();

    let handle = unsafe { LoadLibraryW(name_wide.as_ptr()) };
    if handle.is_null() {
        return Err(Error::new("Failed to load library"));
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Asynchronous I/O</strong>: Windows has different async I/O APIs</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(target_os = "windows")]
use windows_specific_io::read_file;

#[cfg(not(target_os = "windows"))]
use posix_specific_io::read_file;
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<ul>
<li>
<p><strong>Architectures</strong>: Support both Intel and Apple Silicon</p>
<pre><code class="language-ruby"># Rakefile
RbSys::ExtensionTask.new("my_gem", GEMSPEC) do |ext|
  ext.cross_platform = ["x86_64-darwin", "arm64-darwin"]
end
</code></pre>
</li>
<li>
<p><strong>Framework Linking</strong>: Link against macOS frameworks</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// build.rs
#[cfg(target_os = "macos")]
{
    println!("cargo:rustc-link-lib=framework=Security");
    println!("cargo:rustc-link-lib=framework=CoreFoundation");
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Universal Binary</strong>: Consider building universal binaries</p>
<pre><code class="language-ruby"># extconf.rb
if RUBY_PLATFORM =~ /darwin/
  ENV['RUSTFLAGS'] = "-C link-arg=-arch -C link-arg=arm64 -C link-arg=-arch -C link-arg=x86_64"
end
</code></pre>
</li>
</ul>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<ul>
<li>
<p><strong>glibc vs musl</strong>: Consider both glibc and musl for maximum compatibility</p>
<pre><code class="language-ruby"># Rakefile
RbSys::ExtensionTask.new("my_gem", GEMSPEC) do |ext|
  ext.cross_platform = ["x86_64-linux", "x86_64-linux-musl"]
end
</code></pre>
</li>
<li>
<p><strong>Static Linking</strong>: Increase portability with static linking</p>
<pre><code class="language-toml"># Cargo.toml
[target.'cfg(target_os = "linux")'.dependencies]
openssl-sys = { version = "0.9", features = ["vendored"] }
</code></pre>
</li>
<li>
<p><strong>Multiple Distributions</strong>: Test on different distributions in CI</p>
<pre><code class="language-yaml"># .github/workflows/linux-test.yml
jobs:
  test:
    strategy:
      matrix:
        container: ["ubuntu:20.04", "debian:bullseye", "alpine:3.15"]
    container: ${{ matrix.container }}
</code></pre>
</li>
</ul>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<ol>
<li><strong>Start with cross-compilation early</strong> - Don't wait until release time</li>
<li><strong>Test on all target platforms</strong> - Ideally in CI</li>
<li><strong>Use platform-specific code sparingly</strong> - Abstract platform differences when possible</li>
<li><strong>Prefer conditional compilation over runtime checks</strong> - Better performance and safer code</li>
<li><strong>Document platform requirements</strong> - Make dependencies clear to users</li>
<li><strong>Use feature flags for optional platform support</strong> - Allow users to opt-in to platform-specific features</li>
</ol>
<h3 id="example-good-platform-abstraction"><a class="header" href="#example-good-platform-abstraction">Example: Good Platform Abstraction</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Platform abstraction module
mod platform {
    pub struct FileHandle(PlatformSpecificHandle);

    impl FileHandle {
        pub fn open(path: &amp;str) -&gt; Result&lt;Self, Error&gt; {
            #[cfg(target_os = "windows")]
            {
                // Windows-specific implementation
                // ...
            }

            #[cfg(unix)]
            {
                // Unix-based implementation (Linux, macOS, etc.)
                // ...
            }

            #[cfg(not(any(target_os = "windows", unix)))]
            {
                return Err(Error::new("Unsupported platform"));
            }
        }

        pub fn read(&amp;self, buf: &amp;mut [u8]) -&gt; Result&lt;usize, Error&gt; {
            // Platform-specific reading implementation
            // ...
        }

        pub fn write(&amp;self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt; {
            // Platform-specific writing implementation
            // ...
        }
    }
}

// User code just uses the abstraction
use platform::FileHandle;

fn process_file(path: &amp;str) -&gt; Result&lt;(), Error&gt; {
    let file = FileHandle::open(path)?;
    // Common code without platform-specific details
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example-cross-platform-release-workflow"><a class="header" href="#complete-example-cross-platform-release-workflow">Complete Example: Cross-Platform Release Workflow</a></h2>
<p>Here's a complete example for releasing a cross-platform gem:</p>
<ol>
<li><strong>Develop locally</strong> on your preferred platform</li>
<li><strong>Test your changes</strong> locally with <code>bundle exec rake test</code></li>
<li><strong>Verify cross-platform builds</strong> with
<code>bundle exec rb-sys-dock --platform x86_64-linux --command "bundle exec rake test"</code></li>
<li><strong>Commit and push</strong> your changes</li>
<li><strong>CI tests</strong> run on all supported platforms</li>
<li><strong>Create a release tag</strong> when ready (<code>git tag v1.0.0 &amp;&amp; git push --tags</code>)</li>
<li><strong>Cross-compilation workflow</strong> builds platform-specific gems</li>
<li><strong>Publish gems</strong> to RubyGems or your private repository</li>
</ol>
<p>By following this workflow, you can be confident your extension works consistently across platforms.</p>
<h2 id="real-world-examples-2"><a class="header" href="#real-world-examples-2">Real-World Examples</a></h2>
<p>Many real-world gems use rb-sys for cross-platform development:</p>
<ul>
<li><a href="https://github.com/oxidize-rb/blake3-ruby">blake3-ruby</a> - Fast cryptographic hash function implementation with full
cross-platform support</li>
<li><a href="https://github.com/yoshoku/lz4-ruby">lz4-ruby</a> - LZ4 compression library with rb-sys</li>
<li><a href="https://github.com/bytecodealliance/wasmtime-rb">wasmtime-rb</a> - WebAssembly runtime</li>
</ul>
<p>These projects demonstrate successful cross-platform strategies and can serve as references for your own extensions.</p>
<h3 id="example-from-wasmtime-rb"><a class="header" href="#example-from-wasmtime-rb">Example from wasmtime-rb</a></h3>
<p>wasmtime-rb wraps platform-specific functionality while presenting a consistent API:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(unix)]
mod unix {
    pub unsafe fn map_memory(addr: *mut u8, len: usize) -&gt; Result&lt;(), Error&gt; {
        // Unix-specific memory mapping
    }
}

#[cfg(windows)]
mod windows {
    pub unsafe fn map_memory(addr: *mut u8, len: usize) -&gt; Result&lt;(), Error&gt; {
        // Windows-specific memory mapping
    }
}

// Public API uses the platform-specific implementation
pub unsafe fn map_memory(addr: *mut u8, len: usize) -&gt; Result&lt;(), Error&gt; {
    #[cfg(unix)]
    {
        return unix::map_memory(addr, len);
    }

    #[cfg(windows)]
    {
        return windows::map_memory(addr, len);
    }

    #[cfg(not(any(unix, windows)))]
    {
        return Err(Error::new("Unsupported platform"));
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Cross-platform development with rb-sys leverages Rust's excellent platform-specific features:</p>
<ol>
<li><strong>Conditional compilation</strong> provides platform-specific code paths</li>
<li><strong>Platform-specific dependencies</strong> allow different libraries per platform</li>
<li><strong>rb-sys-dock</strong> enables easy cross-compilation for multiple platforms</li>
<li><strong>GitHub Actions integration</strong> automates testing and releases</li>
</ol>
<p>By following the patterns in this chapter, your Ruby extensions can work seamlessly across all major platforms while
minimizing platform-specific code and maintenance burden.</p>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<ul>
<li>Visit <a href="build-process.html">Build Process</a> to see local compilation details.</li>
<li>Check out <a href="testing.html">Testing Extensions</a> for CI workflows across platforms.</li>
<li>Use <a href="debugging.html">Debugging</a> strategies when cross-compiling fails.</li>
<li>Review <a href="project-setup.html">Project Setup</a> to organize multi-platform gems.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-extensions"><a class="header" href="#testing-extensions">Testing Extensions</a></h1>
<p>Testing is a critical part of developing Ruby extensions. This chapter covers strategies for testing your Rust code that
interfaces with Ruby, from unit tests to integration tests and CI workflows.</p>
<div class="warning">
<p>Testing is particularly important for Ruby extensions because segmentation faults, memory leaks, and other low-level
issues can crash the entire Ruby VM. Untested extensions can lead to hard-to-debug production crashes.</p>
</div>
<h2 id="rb-sys-test-helpers-overview"><a class="header" href="#rb-sys-test-helpers-overview">rb-sys-test-helpers Overview</a></h2>
<p>The <code>rb-sys-test-helpers</code> crate provides specialized utilities for testing Ruby extensions in Rust. It solves many of
the challenges associated with testing code that interacts with the Ruby VM:</p>
<ul>
<li>Automating Ruby VM initialization and teardown</li>
<li>Managing thread safety for Ruby VM operations</li>
<li>Handling Ruby exceptions in tests</li>
<li>Providing GC stress testing to catch memory issues</li>
<li>Offering conversion helpers for common Ruby types</li>
</ul>
<p>For detailed API documentation, see the <a href="./api-reference/test-helpers.html">Test Helpers API Reference</a>.</p>
<h2 id="unit-testing-rust-code"><a class="header" href="#unit-testing-rust-code">Unit Testing Rust Code</a></h2>
<h3 id="the-challenge-of-testing-ruby-extensions"><a class="header" href="#the-challenge-of-testing-ruby-extensions">The Challenge of Testing Ruby Extensions</a></h3>
<p>Testing Rust code that interacts with Ruby presents unique challenges:</p>
<ol>
<li><strong>Ruby VM Initialization</strong>: The Ruby VM must be properly initialized before tests run.</li>
<li><strong>Thread Safety</strong>: Ruby's VM has thread-specific state that must be managed.</li>
<li><strong>Exception Handling</strong>: Ruby exceptions need to be properly caught and converted to Rust errors.</li>
<li><strong>Memory Management</strong>: Memory allocated by Ruby needs to be protected from garbage collection during tests.</li>
</ol>
<div class="note">
<p>rb-sys provides specialized tools to overcome these challenges, particularly the <code>#[ruby_test]</code> macro which handles Ruby
VM initialization and thread management automatically.</p>
</div>
<h3 id="complete-test-setup-guide"><a class="header" href="#complete-test-setup-guide">Complete Test Setup Guide</a></h3>
<p>Setting up proper testing for Ruby extensions requires several components working together. This guide provides a
comprehensive setup that you can adapt to your project.</p>
<h4 id="required-dependencies"><a class="header" href="#required-dependencies">Required Dependencies</a></h4>
<p>Your <code>Cargo.toml</code> needs to be configured with the appropriate dependencies:</p>
<pre><code class="language-toml">[package]
name = "my_extension"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

# Main dependencies
[dependencies]
magnus = "0.6" # For high-level Ruby API
rb-sys = "0.9"  # Required for rb_sys_test_helpers to work

# Test dependencies
[dev-dependencies]
rb-sys-env = "0.1"          # For Ruby environment detection
rb-sys-test-helpers = "0.2" # For Ruby VM test helpers
</code></pre>
<p>The key points:</p>
<ul>
<li>Include <code>rb-sys</code> as a regular dependency (not just a dev-dependency)</li>
<li>Both <code>rb-sys-env</code> and <code>rb-sys-test-helpers</code> are needed for tests</li>
</ul>
<h4 id="setting-up-buildrs"><a class="header" href="#setting-up-buildrs">Setting Up build.rs</a></h4>
<p>Create a <code>build.rs</code> file in your project root with the following content:</p>
<pre><pre class="playground"><code class="language-rust">use std::error::Error;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // This activates rb-sys-env for both normal builds and tests
    let _ = rb_sys_env::activate()?;

    // Any additional build configuration can go here

    Ok(())
}</code></pre></pre>
<p>The <code>rb_sys_env::activate()</code> function:</p>
<ul>
<li>Sets up Cargo configuration based on the detected Ruby environment</li>
<li>Exposes Ruby version information as feature flags (e.g., <code>ruby_gte_3_0</code>, <code>ruby_use_flonum</code>)</li>
<li>Ensures proper linking to the Ruby library</li>
</ul>
<h4 id="importing-test-helpers"><a class="header" href="#importing-test-helpers">Importing Test Helpers</a></h4>
<p>In your test module, import the necessary components:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use rb_sys_test_helpers::ruby_test;
    use magnus::{Ruby, Error};

    // Your test functions go here...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="the-ruby_test-macro"><a class="header" href="#the-ruby_test-macro">The #[ruby_test] Macro</a></h3>
<div class="tip">
<p>The <code>#[ruby_test]</code> macro is the simplest and most reliable way to test Ruby extensions in Rust. It handles all the
complexities of VM initialization and thread management.</p>
</div>
<p>The simplest way to test Ruby extensions is with the <code>#[ruby_test]</code> macro, which wraps your test functions to ensure
they run within a properly initialized Ruby VM:</p>
<pre><pre class="playground"><code class="language-rust hidelines=#"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">// Complete example of using the ruby_test macro
</span>use rb_sys::*;
use rb_sys_test_helpers::ruby_test;

#[ruby_test]
fn test_string_manipulation() {
    unsafe {
        // Create a Ruby string
        let rb_str = rb_utf8_str_new_cstr("hello\0".as_ptr() as _);

        // Append to the string
        let rb_str = rb_str_cat(rb_str, " world\0".as_ptr() as _, 6);

        // Convert to Rust string for assertion
        let mut rb_str_val = rb_str;
        let result_ptr = rb_string_value_cstr(&amp;mut rb_str_val);
        let result = std::ffi::CStr::from_ptr(result_ptr)
            .to_string_lossy()
            .to_string();

        assert_eq!(result, "hello world");
    }
}

<span class="boring">// You can add options to the macro
</span><span class="boring">#[ruby_test(gc_stress)]
</span><span class="boring">fn test_with_gc_stress() {
</span><span class="boring">    // This test will run with GC stress enabled
</span><span class="boring">    // Ruby's garbage collector will run more frequently
</span><span class="boring">    // to help catch memory management issues
</span><span class="boring">    unsafe {
</span><span class="boring">        let rb_str = rb_utf8_str_new_cstr("test\0".as_ptr() as _);
</span><span class="boring">        rb_gc_guard!(rb_str); // Protect from GC
</span><span class="boring">        rb_gc(); // Force garbage collection
</span><span class="boring">        // If rb_str was not protected, it might be collected here
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Version-specific tests using rb-sys-env features
</span><span class="boring">#[ruby_test]
</span><span class="boring">fn test_with_version_conditionals() {
</span><span class="boring">    // This block only runs on Ruby 3.0 or newer
</span><span class="boring">    #[cfg(ruby_gte_3_0)]
</span><span class="boring">    {
</span><span class="boring">        // Test Ruby 3.0+ specific features
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // This block only runs on Ruby 2.7
</span><span class="boring">    #[cfg(all(ruby_gte_2_7, ruby_lt_3_0))]
</span><span class="boring">    {
</span><span class="boring">        // Test Ruby 2.7 specific features
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // This block runs if float values are stored
</span><span class="boring">    // as immediate values (Ruby implementation detail)
</span><span class="boring">    #[cfg(ruby_use_flonum)]
</span><span class="boring">    {
</span><span class="boring">        // Test flonum implementation
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="note">
<p>The <code>#[ruby_test]</code> macro:</p>
<ol>
<li>Ensures the Ruby VM is initialized once and only once</li>
<li>Runs all tests on the same OS thread</li>
<li>Catches and propagates Ruby exceptions as Rust errors</li>
<li>Performs GC after each test to catch memory management issues</li>
</ol>
<p>Click the eye icon (<i class="fa fa-eye"></i>) to view additional examples of the macro options and version-specific
testing.</p>
</div>
<p>The <code>#[ruby_test]</code> macro:</p>
<ol>
<li>Ensures the Ruby VM is initialized once and only once</li>
<li>Runs all tests on the same OS thread</li>
<li>Catches and propagates Ruby exceptions as Rust errors</li>
<li>Performs GC after each test to catch memory management issues</li>
</ol>
<h3 id="using-magnus-with-ruby_test"><a class="header" href="#using-magnus-with-ruby_test">Using Magnus with #[ruby_test]</a></h3>
<div class="tip">
<p>Magnus provides a much more ergonomic Rust API for working with Ruby. Combined with the <code>#[ruby_test]</code> macro, it makes
testing Ruby extensions much simpler and safer.</p>
</div>
<p>One of the great advantages of the <code>#[ruby_test]</code> macro is that it works seamlessly with Magnus, providing a much more
ergonomic way to test Ruby integrations:</p>
<pre><pre class="playground"><code class="language-rust hidelines=#"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">// Complete example of using Magnus with ruby_test
</span>use magnus::{RString, Ruby};
use rb_sys_test_helpers::ruby_test;

#[ruby_test]
fn test_with_magnus() {
    // Get the Ruby interpreter - no unsafe required when using Magnus!
    let ruby = Ruby::get().unwrap();

    // Create a Ruby string with Magnus
    let hello = RString::new(ruby, "Hello, ");

    // Append to the string
    let message = hello.concat(ruby, "World!");

    // Convert to Rust string for assertion - easy with Magnus
    let result = message.to_string().unwrap();

    assert_eq!(result, "Hello, World!");
}

<span class="boring">// Testing more complex Ruby interactions
</span><span class="boring">#[ruby_test]
</span><span class="boring">fn test_ruby_class_interaction() {
</span><span class="boring">    let ruby = Ruby::get().unwrap();
</span><span class="boring">
</span><span class="boring">    // Define a Ruby class for testing
</span><span class="boring">    let test_class = ruby.define_class("TestClass", ruby.class_object()).unwrap();
</span><span class="boring">
</span><span class="boring">    // Define a method on the class
</span><span class="boring">    test_class.define_method("double",
</span><span class="boring">        magnus::method!(|_rb_self, num: i64| -&gt; i64 { num * 2 }, 1)
</span><span class="boring">    ).unwrap();
</span><span class="boring">
</span><span class="boring">    // Use Ruby's eval to test the class
</span><span class="boring">    let result: i64 = ruby.eval("TestClass.new.double(21)").unwrap();
</span><span class="boring">
</span><span class="boring">    assert_eq!(result, 42);
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="note">
<p>Magnus makes it much easier to interact with Ruby objects in a safe and idiomatic way. Using Magnus with the
<code>#[ruby_test]</code> macro gives you the best of both worlds:</p>
<ul>
<li>Magnus's safe, high-level API</li>
<li>The <code>#[ruby_test]</code> macro's robust Ruby VM management</li>
</ul>
<p>Click the eye icon (<i class="fa fa-eye"></i>) to see examples of more complex Ruby class interactions.</p>
</div>
<p>Magnus makes it much easier to interact with Ruby objects in a safe and idiomatic way. Using Magnus with the
<code>#[ruby_test]</code> macro gives you the best of both worlds:</p>
<ul>
<li>Magnus's safe, high-level API</li>
<li>The <code>#[ruby_test]</code> macro's robust Ruby VM management</li>
</ul>
<p>Here's another example showing how to work with Ruby classes and methods using Magnus:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{class, eval, method, prelude::*, Module, RClass, Ruby};
use rb_sys_test_helpers::ruby_test;

#[ruby_test]
fn test_ruby_class_interaction() {
    let ruby = Ruby::get().unwrap();

    // Define a Ruby class for testing
    let test_class = ruby.define_class("TestClass", ruby.class_object()).unwrap();

    // Define a method on the class
    test_class.define_method("double", method!(|ruby, num: i64| -&gt; i64 {
        num * 2
    })).unwrap();

    // Create an instance and call the method
    let result: i64 = eval!(ruby, "TestClass.new.double(21)").unwrap();

    assert_eq!(result, 42);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="testing-with-gc-stress"><a class="header" href="#testing-with-gc-stress">Testing with GC Stress</a></h3>
<p>To detect subtle memory management issues, you can enable GC stress testing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ruby_test(gc_stress)]
fn test_gc_interactions() {
    unsafe {
        // Create a Ruby string
        let s = rb_str_new_cstr("hello world\0".as_ptr() as _);

        // Get a pointer to the string's contents
        let s_ptr = RSTRING_PTR(s);

        // Protect s from garbage collection
        rb_gc_guard!(s);

        // Now we can safely use s_ptr, even though GC might run
        let t = rb_str_new_cstr("prefix: \0".as_ptr() as _);
        let result = rb_str_cat_cstr(t, s_ptr);

        // More code...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>With Magnus, the same test is more straightforward:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{RString, Ruby};
use rb_sys_test_helpers::ruby_test;

#[ruby_test(gc_stress)]
fn test_gc_interactions_with_magnus() {
    let ruby = Ruby::get().unwrap();

    // Create first string
    let s = RString::new(ruby, "hello world");

    // Magnus handles GC protection automatically!

    // Create second string and concatenate
    let t = RString::new(ruby, "prefix: ");
    let result = t.concat(ruby, &amp;s);

    assert_eq!(result.to_string().unwrap(), "prefix: hello world");
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>gc_stress</code> option forces Ruby's garbage collector to run frequently during the test, which helps expose bugs
related to:</p>
<ul>
<li>Objects not being properly protected from GC</li>
<li>Dangling pointers</li>
<li>Invalid memory access</li>
</ul>
<h3 id="handling-ruby-exceptions"><a class="header" href="#handling-ruby-exceptions">Handling Ruby Exceptions</a></h3>
<p>Ruby exceptions can be caught and converted to Rust errors using the <code>protect</code> function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ruby_test]
fn test_exception_handling() {
    use rb_sys_test_helpers::protect;

    // This code will raise a Ruby exception
    let result = unsafe {
        protect(|| {
            rb_sys::rb_raise(rb_sys::rb_eRuntimeError, "Test error\0".as_ptr() as _);
            // This will never be reached
            "success"
        })
    };

    // Verify we got an error
    assert!(result.is_err());

    // Check the error message
    let error = result.unwrap_err();
    assert!(error.message().unwrap().contains("Test error"));
}
<span class="boring">}</span></code></pre></pre>
<p>With Magnus, exception handling is more natural:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{eval, Ruby, Error};
use rb_sys_test_helpers::ruby_test;

#[ruby_test]
fn test_exception_handling_with_magnus() {
    let ruby = Ruby::get().unwrap();

    // Evaluate Ruby code that raises an exception
    let result: Result&lt;String, Error&gt; = eval!(ruby, "raise 'Test error'");

    // Verify we got an error
    assert!(result.is_err());

    // Magnus errors contain the Ruby exception
    let error = result.unwrap_err();
    assert!(error.to_string().contains("Test error"));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="version-specific-tests"><a class="header" href="#version-specific-tests">Version-Specific Tests</a></h3>
<p>rb-sys-env provides feature flags that allow you to write version-specific tests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ruby_test]
fn test_version_specific_features() {
    // This test will only run on Ruby 3.0 or higher
    #[cfg(ruby_gte_3_0)]
    {
        // Test Ruby 3.0+ specific features
        unsafe {
            // Example: using Ractor API which is only available in Ruby 3.0+
            #[cfg(ruby_have_ruby_ractor_h)]
            let is_ractor_supported = rb_sys::rb_ractor_main_p() != 0;

            // ...
        }
    }

    // This block will only run on Ruby 2.7
    #[cfg(all(ruby_gte_2_7, ruby_lt_3_0))]
    {
        // Test Ruby 2.7 specific features
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>With Magnus:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{Ruby, eval};
use rb_sys_test_helpers::ruby_test;

#[ruby_test]
fn test_version_specific_features_with_magnus() {
    let ruby = Ruby::get().unwrap();

    // This test will only run on Ruby 3.0 or higher
    #[cfg(ruby_gte_3_0)]
    {
        // Test Ruby 3.0+ specific features
        #[cfg(ruby_have_ruby_ractor_h)]
        let is_ractor_supported: bool = eval!(ruby, "defined?(Ractor) != nil").unwrap();

        #[cfg(ruby_have_ruby_ractor_h)]
        assert!(is_ractor_supported);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Available version flags include:</p>
<ul>
<li><code>ruby_gte_X_Y</code>: Ruby version &gt;= X.Y</li>
<li><code>ruby_lt_X_Y</code>: Ruby version &lt; X.Y</li>
<li><code>ruby_eq_X_Y</code>: Ruby version == X.Y</li>
<li><code>ruby_have_FEATURE</code>: Specific Ruby API feature is available</li>
</ul>
<h3 id="test-helpers-and-macros"><a class="header" href="#test-helpers-and-macros">Test Helpers and Macros</a></h3>
<p>rb-sys-test-helpers includes several macros to simplify common testing patterns:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Convert a Ruby string to a Rust String for testing
#[ruby_test]
fn test_with_helper_macros() {
    use rb_sys_test_helpers::rstring_to_string;

    unsafe {
        let rb_str = rb_utf8_str_new_cstr("hello world\0".as_ptr() as _);
        let rust_str = rstring_to_string!(rb_str);

        assert_eq!(rust_str, "hello world");
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="manual-ruby-vm-setup"><a class="header" href="#manual-ruby-vm-setup">Manual Ruby VM Setup</a></h3>
<p>For more complex test scenarios, you can manually initialize the Ruby VM:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rb_sys_test_helpers::{with_ruby_vm, protect};

#[test]
fn test_complex_scenario() {
    with_ruby_vm(|| {
        // Multiple operations that need a Ruby VM
        let result1 = unsafe {
            protect(|| {
                // First operation...
                42
            })
        };

        let result2 = unsafe {
            protect(|| {
                // Second operation...
                "success"
            })
        };

        assert_eq!(result1.unwrap(), 42);
        assert_eq!(result2.unwrap(), "success");
    }).unwrap();
}
<span class="boring">}</span></code></pre></pre>
<p>With Magnus, the same approach but more ergonomically:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{eval, Ruby};
use rb_sys_test_helpers::with_ruby_vm;

#[test]
fn test_complex_scenario_with_magnus() {
    with_ruby_vm(|| {
        let ruby = Ruby::get().unwrap();

        // First operation
        let result1: i64 = eval!(ruby, "21 * 2").unwrap();

        // Second operation
        let result2: String = eval!(ruby, "'suc' + 'cess'").unwrap();

        assert_eq!(result1, 42);
        assert_eq!(result2, "success");
    }).unwrap();
}
<span class="boring">}</span></code></pre></pre>
<h2 id="debugging-failed-tests"><a class="header" href="#debugging-failed-tests">Debugging Failed Tests</a></h2>
<p>When your tests fail, debugging tools can help identify the root cause. LLDB is particularly useful for debugging memory
issues, segmentation faults, and other low-level problems.</p>
<h3 id="using-lldb-to-debug-tests"><a class="header" href="#using-lldb-to-debug-tests">Using LLDB to Debug Tests</a></h3>
<p>LLDB is a powerful debugger that works well with Rust and Ruby code. Here's how to use it with your tests:</p>
<ol>
<li>
<p>First, compile your extension with debug symbols:</p>
<pre><code class="language-bash">RUSTFLAGS="-g" bundle exec rake compile
</code></pre>
</li>
<li>
<p>Run your test with LLDB:</p>
<pre><code class="language-bash">lldb -- ruby -Ilib -e "require 'my_extension'; require_relative 'test/test_my_extension.rb'"
</code></pre>
</li>
<li>
<p>At the LLDB prompt, set breakpoints in your Rust code:</p>
<pre><code>(lldb) breakpoint set --name MutCalculator::divide
</code></pre>
</li>
<li>
<p>Run the program:</p>
<pre><code>(lldb) run
</code></pre>
</li>
<li>
<p>When the breakpoint is hit, you can:</p>
<ul>
<li>Examine variables: <code>frame variable</code></li>
<li>Print expressions: <code>p self</code> or <code>p val</code></li>
<li>Step through code: <code>next</code> (over) or <code>step</code> (into)</li>
<li>Continue execution: <code>continue</code></li>
<li>Show backtrace: <code>bt</code></li>
</ul>
</li>
</ol>
<h3 id="lldb-commands-for-ruby-extensions"><a class="header" href="#lldb-commands-for-ruby-extensions">LLDB Commands for Ruby Extensions</a></h3>
<p>Some LLDB commands that are particularly useful for Ruby extensions:</p>
<pre><code># To print a Ruby string VALUE
(lldb) p rb_string_value_cstr(&amp;my_rb_string_val)

# To check if a VALUE is nil
(lldb) p RB_NIL_P(my_value)

# To get the Ruby class name of an object
(lldb) p rb_class2name(rb_class_of(my_value))

# To check Ruby exception information
(lldb) p rb_errinfo()
</code></pre>
<h3 id="debugging-memory-issues"><a class="header" href="#debugging-memory-issues">Debugging Memory Issues</a></h3>
<p>For memory-related issues:</p>
<ol>
<li>Set a breakpoint around where objects are created</li>
<li>Set a breakpoint where the crash occurs</li>
<li>When hitting the first breakpoint, note memory addresses</li>
<li>When hitting the second breakpoint, check if those addresses are still valid</li>
</ol>
<pre><code class="language-bash"># Example debugging session for memory issues
$ lldb -- ruby -Ilib -e "require 'my_extension'; MyExtension.test_method"
(lldb) breakpoint set --name MutPoint::new
(lldb) breakpoint set --name MutPoint::add_x
(lldb) run

# When first breakpoint hits
(lldb) frame variable
(lldb) p self
(lldb) continue

# When second breakpoint hits
(lldb) frame variable
(lldb) p self
</code></pre>
<h3 id="debugging-refcell-borrow-errors"><a class="header" href="#debugging-refcell-borrow-errors">Debugging RefCell Borrow Errors</a></h3>
<p>For diagnosing <code>BorrowMutError</code> panics:</p>
<ol>
<li>
<p>Set a breakpoint right before the borrow operation:</p>
<pre><code>(lldb) breakpoint set --file lib.rs --line 123
</code></pre>
</li>
<li>
<p>When it hits, check the status of the RefCell:</p>
<pre><code>(lldb) p self.0
</code></pre>
</li>
<li>
<p>Step through the code and watch when borrows occur:</p>
<pre><code>(lldb) next
</code></pre>
</li>
</ol>
<h3 id="further-information"><a class="header" href="#further-information">Further Information</a></h3>
<p>For more comprehensive debugging setup including VSCode integration and debugging the Ruby C API, see the
<a href="debugging.html">Debugging &amp; Troubleshooting</a> chapter.</p>
<h3 id="common-testing-patterns-and-anti-patterns"><a class="header" href="#common-testing-patterns-and-anti-patterns">Common Testing Patterns and Anti-Patterns</a></h3>
<p>When testing Ruby extensions, several patterns emerge that can help you write more effective tests, along with
anti-patterns to avoid.</p>
<h4 id="pattern-proper-method-invocation"><a class="header" href="#pattern-proper-method-invocation">Pattern: Proper Method Invocation</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ GOOD: Using associated function syntax for methods with Ruby/self parameters
let result = MutCalculator::divide(&amp;ruby, &amp;calc, 6.0, 2.0);

// ❌ BAD: This won't compile - can't call as instance method
// let result = calc.divide(&amp;ruby, 6.0, 2.0);
<span class="boring">}</span></code></pre></pre>
<h4 id="pattern-complete-refcell-borrows"><a class="header" href="#pattern-complete-refcell-borrows">Pattern: Complete RefCell Borrows</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ GOOD: Complete the borrow before attempting to borrow mutably
let current_x = self.0.borrow().x;  // First borrow completes here
if let Some(sum) = current_x.checked_add(val) {
    self.0.borrow_mut().x = sum;    // Safe to borrow mutably now
}

// ❌ BAD: Will panic with "already borrowed: BorrowMutError"
// if let Some(sum) = self.0.borrow().x.checked_add(val) {
//     self.0.borrow_mut().x = sum;  // Error: still borrowed from the if condition
// }
<span class="boring">}</span></code></pre></pre>
<h4 id="pattern-ruby-error-checking"><a class="header" href="#pattern-ruby-error-checking">Pattern: Ruby Error Checking</a></h4>
<p>Testing error handling is crucial for Ruby extensions. Here's how to properly test different exception scenarios:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ GOOD: Verify specific Ruby exception types
let result = MutCalculator::divide(&amp;ruby, &amp;calc, 6.0, 0.0);
assert!(result.is_err());
let err = result.unwrap_err();
assert!(err.is_kind_of(ruby, ruby.exception_zero_div_error()));
assert!(err.message().unwrap().contains("Division by zero"));

// ❌ BAD: Just checking for any error without specific type
// assert!(result.is_err());
<span class="boring">}</span></code></pre></pre>
<h5 id="testing-different-ruby-exception-types"><a class="header" href="#testing-different-ruby-exception-types">Testing Different Ruby Exception Types</a></h5>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Testing for ArgumentError
fn test_argument_error() -&gt; Result&lt;(), Error&gt; {
    let ruby = Ruby::get()?;
    let calc = Calculator::new();

    // Function that raises ArgumentError on negative input
    let result = Calculator::sqrt(&amp;ruby, &amp;calc, -1.0);
    assert!(result.is_err());

    let err = result.unwrap_err();
    assert!(err.is_kind_of(ruby, ruby.exception_arg_error()));
    assert!(err.message().unwrap().contains("must be positive"));

    Ok(())
}

// Testing for RangeError
fn test_range_error() -&gt; Result&lt;(), Error&gt; {
    let ruby = Ruby::get()?;
    let calc = Calculator::new();

    // Function that raises RangeError on large values
    let result = Calculator::factorial(&amp;ruby, &amp;calc, 100);
    assert!(result.is_err());

    let err = result.unwrap_err();
    assert!(err.is_kind_of(ruby, ruby.exception_range_error()));

    Ok(())
}

// Testing for TypeError
fn test_type_error() -&gt; Result&lt;(), Error&gt; {
    let ruby = Ruby::get()?;

    // Use eval to create a type error situation
    let result: Result&lt;i64, Error&gt; = ruby.eval("'string' + 5");
    assert!(result.is_err());

    let err = result.unwrap_err();
    assert!(err.is_kind_of(ruby, ruby.exception_type_error()));

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h5 id="testing-ruby-exceptions-using-eval"><a class="header" href="#testing-ruby-exceptions-using-eval">Testing Ruby Exceptions Using eval</a></h5>
<p>You can also test how Ruby exceptions are raised and handled using <code>eval</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ruby_test]
fn test_ruby_exceptions_with_eval() -&gt; Result&lt;(), Error&gt; {
    let ruby = Ruby::get()?;

    // Set up our extension
    let module = ruby.define_module("MyModule")?;
    let calc_class = module.define_class("Calculator", ruby.class_object())?;
    calc_class.define_singleton_method("new", function!(Calculator::new, 0))?;
    calc_class.define_method("divide", method!(Calculator::divide, 2))?;

    // Test division by zero from Ruby code
    let result: Result&lt;f64, Error&gt; = ruby.eval("MyModule::Calculator.new.divide(10, 0)");
    assert!(result.is_err());

    let err = result.unwrap_err();
    assert!(err.is_kind_of(ruby, ruby.exception_zero_div_error()));

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h5 id="verifying-custom-exception-types"><a class="header" href="#verifying-custom-exception-types">Verifying Custom Exception Types</a></h5>
<p>For custom exception classes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ruby_test]
fn test_custom_exception() -&gt; Result&lt;(), Error&gt; {
    let ruby = Ruby::get()?;

    // Create a custom exception class
    let module = ruby.define_module("MyModule")?;
    let custom_error = module.define_class("CustomError", ruby.exception_standard_error())?;

    // Define a method that raises our custom error
    let obj = ruby.eval::&lt;Value&gt;("Object.new")?;
    obj.define_singleton_method(ruby, "raise_custom",
        function!(|ruby: &amp;Ruby| -&gt; Result&lt;(), Error&gt; {
            Err(Error::new(
                ruby.class_path_to_value("MyModule::CustomError"),
                "Custom error message"
            ))
        }, 0)
    )?;

    // Call the method and verify the exception
    let result: Result&lt;(), Error&gt; = ruby.eval("Object.new.raise_custom");
    assert!(result.is_err());

    let err = result.unwrap_err();
    assert!(err.is_kind_of(ruby, custom_error));
    assert!(err.message().unwrap().contains("Custom error"));

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h4 id="pattern-proper-memory-management"><a class="header" href="#pattern-proper-memory-management">Pattern: Proper Memory Management</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ GOOD: Test with GC stress to catch memory issues
#[ruby_test(gc_stress)]
fn test_memory_management() {
    // Test code here will run with GC stress enabled
}

// ✅ GOOD: Ensure objects used in raw C API are protected
unsafe {
    let rb_str = rb_utf8_str_new_cstr("hello\0".as_ptr() as _);
    let rb_str = rb_gc_guard!(rb_str);  // Protected from GC
}

// ❌ BAD: Using raw pointers without protection
// unsafe {
//     let rb_str = rb_utf8_str_new_cstr("hello\0".as_ptr() as _);
//     // rb_str could be collected here if GC runs
// }
<span class="boring">}</span></code></pre></pre>
<h4 id="pattern-version-specific-testing"><a class="header" href="#pattern-version-specific-testing">Pattern: Version-Specific Testing</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ GOOD: Conditional tests based on Ruby version
#[ruby_test]
fn test_features() {
    #[cfg(ruby_gte_3_0)]
    {
        // Test Ruby 3.0+ specific features
    }

    #[cfg(not(ruby_gte_3_0))]
    {
        // Test for older Ruby versions
    }
}

// ❌ BAD: Runtime checks for version
// if ruby_version() &gt;= (3, 0, 0) {
//     // Test Ruby 3.0+ specific features
// }
<span class="boring">}</span></code></pre></pre>
<h3 id="testing-best-practices"><a class="header" href="#testing-best-practices">Testing Best Practices</a></h3>
<div class="warning">
<p>Failing to follow these practices can result in segmentation faults, memory leaks, and other serious issues that may
only appear in production environments with specific data or Ruby versions.</p>
</div>
<ol>
<li><strong>Use <code>#[ruby_test]</code> for most tests</strong>: This macro handles Ruby VM setup automatically.</li>
<li><strong>Consider Magnus for cleaner tests</strong>: Magnus offers a much more ergonomic API than raw rb-sys.</li>
<li><strong>Enable <code>gc_stress</code> for memory management tests</strong>: This helps catch GC-related bugs early.</li>
<li><strong>Always protect raw Ruby pointers</strong>: Use <code>rb_gc_guard!</code> when you need to use raw pointers.</li>
<li><strong>Catch exceptions properly</strong>: Don't let Ruby exceptions crash your tests.</li>
<li><strong>Use conditional compilation for version-specific tests</strong>: Leverage the version flags from rb-sys-env.</li>
<li><strong>Test edge cases</strong>: Nil values, empty strings, large numbers, etc.</li>
<li><strong>Use helper macros</strong>: Convert between Ruby and Rust types using provided helpers.</li>
</ol>
<div class="tip">
<p><strong>Code Example: Testing With Best Practices</strong></p>
<pre><pre class="playground"><code class="language-rust hidelines=#"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use magnus::{class, eval, function, method, prelude::*, Error, Ruby, Value};
</span><span class="boring">use rb_sys_test_helpers::ruby_test;
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">// Define a struct with interior mutability
</span><span class="boring">struct Counter {
</span><span class="boring">    count: i64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[magnus::wrap(class = "MyExtension::Counter")]
</span><span class="boring">struct MutCounter(RefCell&lt;Counter&gt;);
</span><span class="boring">
</span><span class="boring">impl MutCounter {
</span><span class="boring">    fn new(initial: i64) -&gt; Self {
</span><span class="boring">        Self(RefCell::new(Counter { count: initial }))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn count(&amp;self) -&gt; i64 {
</span><span class="boring">        self.0.borrow().count
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn increment(&amp;self) -&gt; i64 {
</span><span class="boring">        let mut counter = self.0.borrow_mut();
</span><span class="boring">        counter.count += 1;
</span><span class="boring">        counter.count
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // Method that uses Ruby VM to potentially raise exceptions
</span><span class="boring">    fn add_checked(ruby: &amp;Ruby, rb_self: &amp;Self, val: i64) -&gt; Result&lt;i64, Error&gt; {
</span><span class="boring">        // ✅ GOOD: Complete borrow before starting a new one
</span><span class="boring">        let current = rb_self.0.borrow().count;
</span><span class="boring">
</span><span class="boring">        if let Some(sum) = current.checked_add(val) {
</span><span class="boring">            rb_self.0.borrow_mut().count = sum;
</span><span class="boring">            Ok(sum)
</span><span class="boring">        } else {
</span><span class="boring">            Err(Error::new(
</span><span class="boring">                ruby.exception_range_error(),
</span><span class="boring">                "Addition would overflow"
</span><span class="boring">            ))
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Comprehensive test suite following best practices
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    // ✅ GOOD: Basic functionality test
</span><span class="boring">    #[ruby_test]
</span><span class="boring">    fn test_counter_basic() {
</span><span class="boring">        let counter = MutCounter::new(0);
</span><span class="boring">        assert_eq!(counter.count(), 0);
</span><span class="boring">        assert_eq!(counter.increment(), 1);
</span><span class="boring">        assert_eq!(counter.increment(), 2);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // ✅ GOOD: Test with Ruby exceptions
</span><span class="boring">    #[ruby_test]
</span><span class="boring">    fn test_counter_overflow() {
</span><span class="boring">        let ruby = Ruby::get().unwrap();
</span><span class="boring">        let counter = MutCounter::new(i64::MAX);
</span><span class="boring">
</span><span class="boring">        // Test method that might raise Ruby exception
</span><span class="boring">        let result = MutCounter::add_checked(&amp;ruby, &amp;counter, 1);
</span><span class="boring">        assert!(result.is_err());
</span><span class="boring">
</span><span class="boring">        // ✅ GOOD: Check specific exception type
</span><span class="boring">        let err = result.unwrap_err();
</span><span class="boring">        assert!(err.is_kind_of(ruby, ruby.exception_range_error()));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // ✅ GOOD: GC stress testing to catch memory issues
</span><span class="boring">    #[ruby_test(gc_stress)]
</span><span class="boring">    fn test_with_gc_stress() {
</span><span class="boring">        let ruby = Ruby::get().unwrap();
</span><span class="boring">        let counter = MutCounter::new(0);
</span><span class="boring">
</span><span class="boring">        // Register Ruby class for testing from Ruby
</span><span class="boring">        let class = ruby.define_class("Counter", ruby.class_object()).unwrap();
</span><span class="boring">        class.define_singleton_method("new", function!(MutCounter::new, 1)).unwrap();
</span><span class="boring">        class.define_method("increment", method!(MutCounter::increment, 0)).unwrap();
</span><span class="boring">
</span><span class="boring">        // Access from Ruby (with GC stress active)
</span><span class="boring">        let result: i64 = ruby.eval(
</span><span class="boring">            "counter = Counter.new(5); counter.increment; counter.increment"
</span><span class="boring">        ).unwrap();
</span><span class="boring">
</span><span class="boring">        assert_eq!(result, 7);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    // ✅ GOOD: Version-specific tests
</span><span class="boring">    #[ruby_test]
</span><span class="boring">    fn test_version_specific() {
</span><span class="boring">        #[cfg(ruby_gte_3_0)]
</span><span class="boring">        {
</span><span class="boring">            // Test Ruby 3.0+ specific features
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        #[cfg(all(ruby_gte_2_7, ruby_lt_3_0))]
</span><span class="boring">        {
</span><span class="boring">            // Test Ruby 2.7 specific features
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>This example illustrates proper handling of RefCell borrowing, Ruby exceptions, GC stress testing, and version-specific
tests.</p>
</div>
<h3 id="example-complete-test-module"><a class="header" href="#example-complete-test-module">Example: Complete Test Module</a></h3>
<p>Here's a complete end-to-end example based on the rusty_calculator extension. This includes the project structure,
required files, and comprehensive test module:</p>
<h4 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h4>
<p>First, ensure your project has the correct file structure:</p>
<pre><code>my_extension/
├── Cargo.toml
├── build.rs
├── src/
│   └── lib.rs
</code></pre>
<h4 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h4>
<pre><code class="language-toml">[package]
name = "my_extension"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
magnus = "0.6"
rb-sys = "0.9"

[dev-dependencies]
rb-sys-env = "0.1"
rb-sys-test-helpers = "0.2"
</code></pre>
<h4 id="buildrs"><a class="header" href="#buildrs">build.rs</a></h4>
<pre><pre class="playground"><code class="language-rust">use std::error::Error;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // Activate rb-sys-env to set up Ruby environment for both builds and tests
    let _ = rb_sys_env::activate()?;

    Ok(())
}</code></pre></pre>
<h4 id="librs"><a class="header" href="#librs">lib.rs</a></h4>
<p>This example includes a calculator class with a method that can potentially raise a Ruby exception:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;
use magnus::{function, method, prelude::*, wrap, Error, Ruby};

// Calculator struct with memory
struct Calculator {
    memory: f64,
}

#[wrap(class = "MyExtension::Calculator")]
struct MutCalculator(RefCell&lt;Calculator&gt;);

impl MutCalculator {
    // Constructor
    fn new() -&gt; Self {
        Self(RefCell::new(Calculator { memory: 0.0 }))
    }

    // Basic arithmetic that returns a Result which can generate Ruby exceptions
    fn divide(ruby: &amp;Ruby, _rb_self: &amp;Self, a: f64, b: f64) -&gt; Result&lt;f64, Error&gt; {
        if b == 0.0 {
            return Err(Error::new(
                ruby.exception_zero_div_error(),
                "Division by zero"
            ));
        }
        Ok(a / b)
    }

    // Regular instance method
    fn add(&amp;self, a: f64, b: f64) -&gt; f64 {
        a + b
    }

    // Memory operations using RefCell
    fn store(&amp;self, value: f64) -&gt; f64 {
        self.0.borrow_mut().memory = value;
        value
    }

    fn recall(&amp;self) -&gt; f64 {
        self.0.borrow().memory
    }
}

// Module initialization
#[magnus::init]
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let module = ruby.define_module("MyExtension")?;

    // Set up the Calculator class
    let calc_class = module.define_class("Calculator", ruby.class_object())?;
    calc_class.define_singleton_method("new", function!(MutCalculator::new, 0))?;
    calc_class.define_method("divide", method!(MutCalculator::divide, 2))?;
    calc_class.define_method("add", method!(MutCalculator::add, 2))?;
    calc_class.define_method("store", method!(MutCalculator::store, 1))?;
    calc_class.define_method("recall", method!(MutCalculator::recall, 0))?;

    Ok(())
}

// Complete test module
#[cfg(test)]
mod tests {
    use super::*;
    use rb_sys_test_helpers::ruby_test;

    // Basic functionality test
    #[ruby_test]
    fn test_calculator_basic_operations() {
        let calc = MutCalculator::new();

        // Test regular instance method
        assert_eq!(calc.add(2.0, 3.0), 5.0);

        // Test memory operations
        assert_eq!(calc.store(42.0), 42.0);
        assert_eq!(calc.recall(), 42.0);
    }

    // Test method that raises Ruby exceptions
    #[ruby_test]
    fn test_calculator_divide() {
        let ruby = Ruby::get().unwrap();
        let calc = MutCalculator::new();

        // Test normal division - note the function syntax for methods
        // that take ruby and rb_self parameters
        let result = MutCalculator::divide(&amp;ruby, &amp;calc, 10.0, 2.0);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 5.0);

        // Test division by zero
        let result = MutCalculator::divide(&amp;ruby, &amp;calc, 10.0, 0.0);
        assert!(result.is_err());

        // Verify specific exception type
        let err = result.unwrap_err();
        assert!(err.is_kind_of(ruby, ruby.exception_zero_div_error()));
        assert!(err.message().unwrap().contains("Division by zero"));
    }

    // Test with GC stress for memory issues
    #[ruby_test(gc_stress)]
    fn test_calculator_with_gc_stress() {
        let calc = MutCalculator::new();

        // Store and recall with GC stress active
        for i in 0..100 {
            calc.store(i as f64);
            assert_eq!(calc.recall(), i as f64);
        }

        // No segfaults or panics means test passed
    }

    // Test for Ruby integration using eval
    #[ruby_test]
    fn test_ruby_integration() {
        let ruby = Ruby::get().unwrap();

        // Define the calculator class - this simulates what init() does
        let module = ruby.define_module("MyExtension").unwrap();
        let calc_class = module.define_class("Calculator", ruby.class_object()).unwrap();
        calc_class.define_singleton_method("new", function!(MutCalculator::new, 0)).unwrap();
        calc_class.define_method("add", method!(MutCalculator::add, 2)).unwrap();

        // Call methods via Ruby's eval
        let result: f64 = ruby.eval("MyExtension::Calculator.new.add(2, 3)").unwrap();
        assert_eq!(result, 5.0);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This complete example demonstrates:</p>
<ol>
<li>Proper project setup with required dependencies</li>
<li>A realistic implementation with potential error conditions</li>
<li>Testing various method types (regular instance methods and methods with Ruby state)</li>
<li>Testing Ruby exceptions with proper type checking</li>
<li>Memory safety testing with GC stress</li>
<li>Ruby integration testing via eval</li>
</ol>
<p>You can adapt this template to your own extension, adding the specific functionality your project requires.</p>
<pre><code>
## Integration Testing Ruby API

&lt;div class="tip"&gt;

Integration tests verify that your extension works correctly when called from Ruby code. Testing both in Rust and Ruby provides the most complete coverage.

&lt;/div&gt;

Integration tests verify that your Ruby extension's API works correctly when called from Ruby code. These tests are typically written in Ruby and run using Ruby's test frameworks.

### Setting Up Ruby Tests

Most Ruby gems use Minitest or RSpec for testing. Here's how to set up integration tests with Minitest (which bundler creates by default):

```ruby,hidelines=#
# test/test_my_extension.rb
require "test_helper"

class TestMyExtension &lt; Minitest::Test
  def setup
    # Set up test fixtures
    @calculator = MyExtension::Calculator.new
  end

  def test_basic_addition
    assert_equal 5, @calculator.add(2, 3)
  end

  def test_division_by_zero
    error = assert_raises(ZeroDivisionError) do
      @calculator.divide(10, 0)
    end
    assert_match /division by zero/i, error.message
  end

  def test_nil_handling
    # Test that nil values are properly handled
    assert_nil @calculator.process(nil)
  end

# # Test memory management
# def test_gc_safety
#   # Create many objects and force garbage collection
#   1000.times do |i|
#     obj = MyExtension::Calculator.new
#     obj.add(i, i)
#
#     # Force garbage collection periodically
#     GC.start if i % 100 == 0
#   end
#
#   # If we reach here without segfaults, the test passes
#   assert true
# end
#
# # Test edge cases
# def test_edge_cases
#   # Test with extreme values
#   max = (2**60)
#   assert_equal max * 2, @calculator.multiply(max, 2)
#
#   # Test with different types
#   assert_raises(TypeError) do
#     @calculator.add("string", 1)
#   end
# end
end
</code></pre>
<div class="note">
<p>Click the eye icon (<i class="fa fa-eye"></i>) to see additional tests for memory management and edge cases.</p>
</div>
<h3 id="testing-error-handling"><a class="header" href="#testing-error-handling">Testing Error Handling</a></h3>
<p>It's particularly important to test how your extension handles error conditions:</p>
<pre><code class="language-ruby">def test_error_propagation
  # Test that Rust errors properly convert to Ruby exceptions
  error = assert_raises(RangeError) do
    @calculator.factorial(100) # Too large, should raise RangeError
  end
  assert_match /too large/i, error.message
end

def test_invalid_arguments
  # Test type validation
  error = assert_raises(TypeError) do
    @calculator.add("string", 3) # Should raise TypeError
  end
  assert_match /expected numeric/i, error.message
end
</code></pre>
<h3 id="testing-memory-management"><a class="header" href="#testing-memory-management">Testing Memory Management</a></h3>
<p>Test memory management by creating objects and forcing garbage collection:</p>
<pre><code class="language-ruby">def test_gc_safety
  # Create many objects and force garbage collection
  1000.times do |i|
    obj = MyExtension::Point.new(i, i)

    # Force garbage collection periodically
    GC.start if i % 100 == 0
  end

  # If we reach here without segfaults or leaks, the test passes
  assert true
end

def test_object_references
  # Test that nested objects maintain correct references
  parent = MyExtension::Node.new("parent")
  child = MyExtension::Node.new("child")

  # Create relationship
  parent.add_child(child)

  # Force garbage collection
  GC.start

  # Both objects should still be valid
  assert_equal "parent", parent.name
  assert_equal "child", parent.children.first.name
end
</code></pre>
<h2 id="common-testing-patterns"><a class="header" href="#common-testing-patterns">Common Testing Patterns</a></h2>
<p>When testing Ruby extensions written in Rust, several patterns emerge that can help ensure correctness and stability.</p>
<h3 id="testing-type-conversions"><a class="header" href="#testing-type-conversions">Testing Type Conversions</a></h3>
<p>Type conversions between Rust and Ruby are common sources of bugs:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ruby_test]
fn test_type_conversions() {
    let ruby = Ruby::get().unwrap();

    // Test Ruby to Rust conversions
    let rb_str = RString::new(ruby, "test");
    let rb_int = Integer::from_i64(42);
    let rb_array = RArray::from_iter(ruby, vec![1, 2, 3]);

    // Convert to Rust types
    let rust_str: String = rb_str.to_string().unwrap();
    let rust_int: i64 = rb_int.to_i64().unwrap();
    let rust_vec: Vec&lt;i64&gt; = rb_array.to_vec().unwrap();

    // Verify conversions
    assert_eq!(rust_str, "test");
    assert_eq!(rust_int, 42);
    assert_eq!(rust_vec, vec![1, 2, 3]);

    // Test Rust to Ruby conversions
    let rust_str = "reverse";
    let rb_str = RString::new(ruby, rust_str);
    assert_eq!(rb_str.to_string().unwrap(), rust_str);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="method-invocation-syntax-in-tests"><a class="header" href="#method-invocation-syntax-in-tests">Method Invocation Syntax in Tests</a></h3>
<p>When testing Rust methods exposed to Ruby, it's important to understand the different invocation patterns based on the
method's signature:</p>
<h4 id="regular-instance-methods"><a class="header" href="#regular-instance-methods">Regular Instance Methods</a></h4>
<p>For methods that only take <code>&amp;self</code> and don't interact with the Ruby VM:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Method definition
fn count(&amp;self) -&gt; isize {
    self.0.borrow().count
}

// In tests - use instance method syntax
#[ruby_test]
fn test_count() {
    let counter = MutCounter::new(0);
    assert_eq!(counter.count(), 0);
}
<span class="boring">}</span></code></pre></pre>
<h4 id="methods-with-ruby-state"><a class="header" href="#methods-with-ruby-state">Methods with Ruby State</a></h4>
<p>For methods that require the Ruby interpreter (to raise exceptions or interact with Ruby objects):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Method definition
fn divide(ruby: &amp;Ruby, _rb_self: &amp;Self, a: f64, b: f64) -&gt; Result&lt;f64, Error&gt; {
    if b == 0.0 {
        return Err(Error::new(
            ruby.exception_zero_div_error(),
            "Division by zero"
        ));
    }
    Ok(a / b)
}

// In tests - use associated function syntax with explicit self parameter
#[ruby_test]
fn test_divide() {
    let ruby = Ruby::get().unwrap();
    let calc = MutCalculator::new();

    // CORRECT: Associated function syntax with all parameters
    let result = MutCalculator::divide(&amp;ruby, &amp;calc, 6.0, 2.0);
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 3.0);

    // INCORRECT: This will not compile
    // let result = calc.divide(&amp;ruby, 6.0, 2.0);
}
<span class="boring">}</span></code></pre></pre>
<p>The key difference is that when a method takes <code>rb_self: &amp;Self</code> as a parameter (as many methods do that interact with
Ruby), it's not a true instance method from Rust's perspective. In tests, you must call these using the associated
function syntax, passing in the Ruby interpreter and the self reference explicitly.</p>
<h3 id="testing-refcell-borrowing"><a class="header" href="#testing-refcell-borrowing">Testing RefCell Borrowing</a></h3>
<p>For extensions that use <code>RefCell</code> for interior mutability, test these patterns thoroughly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ruby_test]
fn test_refcell_borrowing() {
    let ruby = Ruby::get().unwrap();
    let counter = MutCounter::new(0);

    // Test regular instance methods
    assert_eq!(counter.count(), 0);
    assert_eq!(counter.increment(), 1);
    assert_eq!(counter.increment(), 2);

    // Test methods that use checked operations with the Ruby VM
    // Note the use of associated function syntax here
    let result = MutCounter::add_checked(&amp;ruby, &amp;counter, 10);
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 13);
    assert_eq!(counter.count(), 13);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="gc-stress-testing"><a class="header" href="#gc-stress-testing">GC Stress Testing</a></h3>
<p>Testing with Ruby's garbage collector is essential to ensure your extension doesn't leak memory or access deallocated
objects. The <code>#[ruby_test(gc_stress)]</code> option helps identify these issues early by running the garbage collector more
frequently.</p>
<h4 id="basic-gc-stress-testing"><a class="header" href="#basic-gc-stress-testing">Basic GC Stress Testing</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ruby_test(gc_stress)]
fn test_gc_integration() {
    let ruby = Ruby::get().unwrap();

    // Create objects that should be properly managed
    for i in 0..100 {
        let obj = SomeObject::new(i);
        // obj goes out of scope here, should be collected
    }

    // Force garbage collection explicitly
    ruby.gc_start();

    // No panics or segfaults means the test passes
}
<span class="boring">}</span></code></pre></pre>
<h4 id="testing-with-typeddata-and-mark-methods"><a class="header" href="#testing-with-typeddata-and-mark-methods">Testing with TypedData and Mark Methods</a></h4>
<p>For custom classes that hold Ruby object references, test the <code>mark</code> method implementation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{gc::Marker, TypedData, DataTypeFunctions, Value};

// A struct that holds references to Ruby objects
#[derive(TypedData)]
#[magnus(class = "MyExtension::Container", free_immediately, mark)]
struct Container {
    item: Value,
    metadata: Value,
}

impl DataTypeFunctions for Container {
    fn mark(&amp;self, marker: &amp;Marker) {
        marker.mark(self.item);
        marker.mark(self.metadata);
    }
}

impl Container {
    fn new(item: Value, metadata: Value) -&gt; Self {
        Self { item, metadata }
    }

    fn item(&amp;self) -&gt; Value {
        self.item
    }
}

// Test with GC stress
#[ruby_test(gc_stress)]
fn test_container_mark_method() {
    let ruby = Ruby::get().unwrap();

    // Create Ruby strings
    let item = RString::new(ruby, "Test Item");
    let metadata = RString::new(ruby, "Item Description");

    // Create our container
    let container = Container::new(item.as_value(), metadata.as_value());

    // Force garbage collection
    ruby.gc_start();

    // The items should still be accessible and not garbage collected
    let retrieved_item = container.item();
    let item_str: String = RString::from_value(retrieved_item).unwrap().to_string().unwrap();

    assert_eq!(item_str, "Test Item");
}
<span class="boring">}</span></code></pre></pre>
<h4 id="testing-object-references-after-gc"><a class="header" href="#testing-object-references-after-gc">Testing Object References After GC</a></h4>
<p>This test ensures objects referenced by your extension aren't prematurely collected:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ruby_test(gc_stress)]
fn test_object_references_survive_gc() {
    let ruby = Ruby::get().unwrap();

    // Create a struct holding references to other objects
    #[derive(TypedData)]
    #[magnus(class = "Node", free_immediately, mark)]
    struct Node {
        value: Value,
        children: Vec&lt;Value&gt;,
    }

    impl DataTypeFunctions for Node {
        fn mark(&amp;self, marker: &amp;Marker) {
            marker.mark(self.value);
            for child in &amp;self.children {
                marker.mark(*child);
            }
        }
    }

    impl Node {
        fn new(value: Value) -&gt; Self {
            Self { value, children: Vec::new() }
        }

        fn add_child(&amp;mut self, child: Value) {
            self.children.push(child);
        }

        fn child_values(&amp;self, ruby: &amp;Ruby) -&gt; Result&lt;Vec&lt;String&gt;, Error&gt; {
            let mut result = Vec::new();
            for child in &amp;self.children {
                let str = RString::from_value(*child)?;
                result.push(str.to_string()?);
            }
            Ok(result)
        }
    }

    // Create the parent node
    let parent_value = RString::new(ruby, "Parent");
    let mut parent = Node::new(parent_value.as_value());

    // Add many child nodes
    for i in 0..20 {
        let child = RString::new(ruby, format!("Child {}", i));
        parent.add_child(child.as_value());
    }

    // Run garbage collection multiple times
    for _ in 0..5 {
        ruby.gc_start();
    }

    // Verify all children are still accessible
    let child_values = parent.child_values(ruby).unwrap();
    assert_eq!(child_values.len(), 20);
    assert_eq!(child_values[0], "Child 0");
    assert_eq!(child_values[19], "Child 19");
}
<span class="boring">}</span></code></pre></pre>
<h4 id="testing-memory-safety-with-raw-pointers"><a class="header" href="#testing-memory-safety-with-raw-pointers">Testing Memory Safety with Raw Pointers</a></h4>
<p>If your extension uses raw C API functions, test with gc_stress and use <code>rb_gc_guard!</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rb_sys::*;

#[ruby_test(gc_stress)]
fn test_raw_pointer_safety() {
    unsafe {
        // Create Ruby values
        let rb_ary = rb_ary_new();

        // IMPORTANT: Protect from GC
        let rb_ary = rb_gc_guard!(rb_ary);

        // Add items to the array
        for i in 0..10 {
            let rb_str = rb_utf8_str_new_cstr(format!("item {}\0", i).as_ptr() as _);

            // IMPORTANT: Protect each string from GC
            let rb_str = rb_gc_guard!(rb_str);

            rb_ary_push(rb_ary, rb_str);
        }

        // Force GC
        rb_gc();

        // Array should still have 10 elements
        assert_eq!(rb_ary_len(rb_ary), 10);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="test-helpers-and-utilities"><a class="header" href="#test-helpers-and-utilities">Test Helpers and Utilities</a></h2>
<p>rb-sys-test-helpers provides various utilities to make testing easier.</p>
<h3 id="value-conversion-helpers"><a class="header" href="#value-conversion-helpers">Value Conversion Helpers</a></h3>
<p>These macros help with common conversions when testing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rb_sys_test_helpers::{rstring_to_string, rarray_to_vec};

#[ruby_test]
fn test_with_conversion_helpers() {
    unsafe {
        // Create Ruby objects
        let rb_str = rb_utf8_str_new_cstr("hello\0".as_ptr() as _);
        let rb_ary = rb_ary_new();
        rb_ary_push(rb_ary, rb_utf8_str_new_cstr("one\0".as_ptr() as _));
        rb_ary_push(rb_ary, rb_utf8_str_new_cstr("two\0".as_ptr() as _));

        // Convert to Rust using helpers
        let rust_str = rstring_to_string!(rb_str);
        let rust_vec = rarray_to_vec!(rb_ary, String);

        // Verify conversions
        assert_eq!(rust_str, "hello");
        assert_eq!(rust_vec, vec!["one".to_string(), "two".to_string()]);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="exception-handling-helpers"><a class="header" href="#exception-handling-helpers">Exception Handling Helpers</a></h3>
<p>The <code>protect</code> function simplifies handling Ruby exceptions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rb_sys_test_helpers::protect;

#[ruby_test]
fn test_exception_handling() {
    // Try an operation that might raise an exception
    let result = unsafe {
        protect(|| {
            // Ruby operation that might raise
            rb_sys::rb_funcall(
                rb_sys::rb_cObject,
                rb_sys::rb_intern("nonexistent_method\0".as_ptr() as _),
                0
            )
        })
    };

    // Verify we got an exception
    assert!(result.is_err());
    let error = result.unwrap_err();
    assert!(error.message().unwrap().contains("undefined method"));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="ci-testing-workflow"><a class="header" href="#ci-testing-workflow">CI Testing Workflow</a></h2>
<div class="warning">
<p>CI testing is essential for extensions that will be distributed as gems. Without it, you risk publishing binaries that
crash on specific Ruby versions or platforms.</p>
</div>
<p>Setting up continuous integration (CI) testing is crucial for Ruby extension gems. This section covers best practices
for testing your extensions in CI environments.</p>
<h3 id="basic-github-actions-setup"><a class="header" href="#basic-github-actions-setup">Basic GitHub Actions Setup</a></h3>
<p>A simple GitHub Actions workflow for a Rust Ruby extension typically includes:</p>
<ol>
<li>Setting up Ruby and Rust environments</li>
<li>Running compilation</li>
<li>Executing tests</li>
<li>Linting the code</li>
</ol>
<pre><code class="language-yaml hidelines=#"><span class="boring"> .github/workflows/test.yml
</span>name: Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest]
        ruby: ['3.0', '3.1', '3.2']

    steps:
    - uses: actions/checkout@v3

<span class="boring">     Use the setup-ruby-and-rust action from oxidize-rb
</span>    - name: Set up Ruby and Rust
      uses: oxidize-rb/actions/setup-ruby-and-rust@v1
      with:
        ruby-version: ${{ matrix.ruby }}
        bundler-cache: true
        cargo-cache: true

<span class="boring">     Run tests
</span>    - name: Compile and test
      run: |
        bundle exec rake compile
        bundle exec rake test

<span class="boring">     Run Rust tests
</span>    - name: Run Rust tests
      run: cargo test --workspace

<span class="boring"> # Windows testing job
</span><span class="boring"> windows:
</span><span class="boring">   runs-on: windows-latest
</span><span class="boring">   strategy:
</span><span class="boring">     matrix:
</span><span class="boring">       ruby: ['3.1']
</span><span class="boring">   steps:
</span><span class="boring">   - uses: actions/checkout@v3
</span><span class="boring">   - name: Set up Ruby and Rust (Windows)
</span><span class="boring">     uses: oxidize-rb/actions/setup-ruby-and-rust@v1
</span><span class="boring">     with:
</span><span class="boring">       ruby-version: ${{ matrix.ruby }}
</span><span class="boring">       bundler-cache: true
</span><span class="boring">       cargo-cache: true
</span><span class="boring">   - name: Run tests
</span><span class="boring">     run: |
</span><span class="boring">       bundle exec rake compile
</span><span class="boring">       bundle exec rake test
</span></code></pre>
<div class="note">
<p>Click the eye icon (<i class="fa fa-eye"></i>) to see a Windows-specific job configuration.</p>
<p>The <a href="https://github.com/oxidize-rb/actions">oxidize-rb/actions</a> repository provides specialized GitHub Actions for Ruby
extensions written in Rust, making setup much simpler.</p>
</div>
<h3 id="memory-testing-with-ruby_memcheck"><a class="header" href="#memory-testing-with-ruby_memcheck">Memory Testing with ruby_memcheck</a></h3>
<div class="tip">
<p>Memory leaks can be particularly difficult to detect in Ruby extensions. Tools like ruby_memcheck help catch these
issues early.</p>
</div>
<p>The <a href="https://github.com/Shopify/ruby_memcheck">ruby_memcheck</a> gem provides a powerful way to detect memory leaks in Ruby
extensions. It uses Valgrind under the hood but filters out false positives that are common when running Valgrind on
Ruby code.</p>
<p>To use ruby_memcheck, add it to your test workflow:</p>
<pre><code class="language-ruby hidelines=#"><span class="boring"> Add to your Gemfile
</span>gem 'ruby_memcheck', group: :development

<span class="boring"> In your Rakefile:
</span>require 'ruby_memcheck'

test_config = lambda do |t|
  t.libs &lt;&lt; "test"
  t.test_files = FileList["test/**/*_test.rb"]
end

namespace :test do
  RubyMemcheck::TestTask.new(valgrind: test_config)
end

<span class="boring"> # Advanced configuration
</span><span class="boring"> RubyMemcheck.config do |config|
</span><span class="boring">   # Adjust valgrind options
</span><span class="boring">   config.valgrind_options += ["--leak-check=full", "--show-leak-kinds=all"]
</span><span class="boring">
</span><span class="boring">   # Specify custom suppression files
</span><span class="boring">   config.valgrind_suppression_files &lt;&lt; "my_suppressions.supp"
</span><span class="boring">
</span><span class="boring">   # Skip specific Ruby functions
</span><span class="boring">   config.skipped_ruby_functions &lt;&lt; /my_custom_allocator/
</span><span class="boring"> end
</span></code></pre>
<p>To run memory tests:</p>
<pre><code class="language-bash"># Install valgrind first if needed
# sudo apt-get install valgrind  # On Debian/Ubuntu

# Run the tests with memory checking
bundle exec rake test:valgrind
</code></pre>
<div class="note">
<p>Click the eye icon (<i class="fa fa-eye"></i>) to see advanced configuration options for ruby_memcheck.</p>
<p>For more detailed instructions and configuration options, refer to the
<a href="https://github.com/Shopify/ruby_memcheck">ruby_memcheck documentation</a>.</p>
</div>
<h3 id="cross-platform-testing-with-rb-sys-dock"><a class="header" href="#cross-platform-testing-with-rb-sys-dock">Cross-Platform Testing with rb-sys-dock</a></h3>
<p>For testing across different platforms, <a href="https://github.com/oxidize-rb/rb-sys-dock">rb-sys-dock</a> provides Docker images
pre-configured for cross-platform compilation and testing of Rust Ruby extensions.</p>
<h3 id="best-practices-for-ci-testing"><a class="header" href="#best-practices-for-ci-testing">Best Practices for CI Testing</a></h3>
<div class="warning">
<p>Without thorough CI testing across all supported platforms and Ruby versions, your extension may work perfectly in your
development environment but crash for users with different setups.</p>
</div>
<ol>
<li><strong>Test Matrix</strong>: Test against multiple Ruby versions, Rust versions, and platforms</li>
<li><strong>Memory Testing</strong>: Include memory leak detection with ruby_memcheck</li>
<li><strong>Linting</strong>: Validate code formatting and catch Rust warnings</li>
<li><strong>Cross-Platform</strong>: Test on all platforms you aim to support</li>
<li><strong>Documentation Verification</strong>: Test code examples in documentation</li>
</ol>
<div class="tip">
<p>The <a href="https://github.com/oxidize-rb/actions">oxidize-rb/actions</a> repository provides ready-to-use GitHub Actions for:</p>
<ul>
<li>Setting up Ruby and Rust environments</li>
<li>Building native gems</li>
<li>Cross-compiling for multiple platforms</li>
<li>Running tests and linting checks</li>
</ul>
<p>Using these specialized actions will save you time and ensure your tests follow best practices.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging--troubleshooting"><a class="header" href="#debugging--troubleshooting">Debugging &amp; Troubleshooting</a></h1>
<p>This chapter covers techniques for debugging Rust-based Ruby extensions, common error patterns, and approaches to
solving the most frequent issues.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>To debug Rust extensions, you can use either LLDB or GDB. First, you will need to compile with the <code>dev</code> Cargo profile,
so debug symbols are available.</p>
<p>To do that you can run: <code>RB_SYS_CARGO_PROFILE=dev rake compile</code>. Alternatively, you can add a helper Rake task to make
this easier:</p>
<pre><code class="language-ruby"># Rakefile

desc "Compile the extension with debug symbols"
task "compile:debug" do
  ENV["RB_SYS_CARGO_PROFILE"] = "dev"
  Rake::Task["compile"].invoke
end
</code></pre>
<blockquote>
<p><strong>💡 Tip:</strong> <a href="https://join.slack.com/t/oxidize-rb/shared_invite/zt-16zv5tqte-Vi7WfzxCesdo2TqF_RYBCw">Join the Slack channel</a> to ask questions and get help from the community!</p>
</blockquote>
<h2 id="common-errors-and-solutions"><a class="header" href="#common-errors-and-solutions">Common Errors and Solutions</a></h2>
<h3 id="compilation-errors"><a class="header" href="#compilation-errors">Compilation Errors</a></h3>
<h4 id="missing-ruby-headers"><a class="header" href="#missing-ruby-headers">Missing Ruby Headers</a></h4>
<p><strong>Error:</strong></p>
<pre><code>fatal error: ruby.h: No such file or directory
#include &lt;ruby.h&gt;
         ^~~~~~~~
compilation terminated.
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Ensure Ruby development headers are installed</li>
<li>Check that <code>rb_sys_env::activate()</code> is being called in your <code>build.rs</code></li>
<li>Verify that your Ruby installation is accessible to your build environment</li>
</ul>
<h4 id="incompatible-ruby-version"><a class="header" href="#incompatible-ruby-version">Incompatible Ruby Version</a></h4>
<p><strong>Error:</strong></p>
<pre><code>error: failed to run custom build command for `rb-sys v0.9.78`
</code></pre>
<p>With details mentioning Ruby version compatibility issues.</p>
<p><strong>Solution:</strong></p>
<ul>
<li>Ensure your rb-sys version is compatible with your Ruby version</li>
<li>Update rb-sys to the latest version</li>
<li>Check your build environment's Ruby version with <code>ruby -v</code></li>
</ul>
<h4 id="linking-errors"><a class="header" href="#linking-errors">Linking Errors</a></h4>
<p><strong>Error:</strong></p>
<pre><code>error: linking with `cc` failed: exit status: 1
... undefined reference to `rb_define_module` ...
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Ensure proper linking configuration in <code>build.rs</code></li>
<li>Make sure you've called <code>rb_sys_env::activate()</code></li>
<li>Verify that your Ruby installation is correctly detected</li>
</ul>
<h3 id="runtime-errors"><a class="header" href="#runtime-errors">Runtime Errors</a></h3>
<h4 id="segmentation-faults"><a class="header" href="#segmentation-faults">Segmentation Faults</a></h4>
<p>Segmentation faults typically occur when accessing memory improperly:</p>
<p><strong>Common Causes:</strong></p>
<ol>
<li>Accessing Ruby objects after they've been garbage collected</li>
<li>Not protecting Ruby values from garbage collection during C API calls</li>
<li>Incorrect use of raw pointers</li>
</ol>
<p><strong>Solutions:</strong></p>
<ul>
<li>Use <code>TypedData</code> and implement the <code>mark</code> method to protect Ruby objects</li>
<li>Use <code>rb_gc_guard!</code> macro when working with raw C API</li>
<li>Prefer the higher-level Magnus API over raw rb-sys</li>
</ul>
<h4 id="already-borrowed-borrowmuterror"><a class="header" href="#already-borrowed-borrowmuterror">Already Borrowed: BorrowMutError</a></h4>
<p>When using <code>RefCell</code> for interior mutability:</p>
<p><strong>Error:</strong></p>
<pre><code>thread '&lt;unnamed&gt;' panicked at 'already borrowed: BorrowMutError', ...
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Complete all immutable borrows before attempting mutable borrows</li>
<li>Copy required data out of immutable borrows before borrowing mutably</li>
<li>See the <a href="memory-management.html#refcell-and-interior-mutability">RefCell and Interior Mutability</a> section in the Memory
Management chapter</li>
</ul>
<h4 id="method-argument-mismatch"><a class="header" href="#method-argument-mismatch">Method Argument Mismatch</a></h4>
<p><strong>Error:</strong></p>
<pre><code>ArgumentError: wrong number of arguments (given 2, expected 1)
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Check method definitions in your Rust code</li>
<li>Ensure <code>function!</code> and <code>method!</code> macros have the correct arity</li>
<li>Verify Ruby method calls match the defined signatures</li>
</ul>
<h4 id="type-conversion-failures"><a class="header" href="#type-conversion-failures">Type Conversion Failures</a></h4>
<p><strong>Error:</strong></p>
<pre><code>TypeError: no implicit conversion of Integer into String
</code></pre>
<p><strong>Solution:</strong></p>
<ul>
<li>Add proper type checking and conversions in Rust</li>
<li>Use <code>try_convert</code> and handle conversion errors gracefully</li>
<li>Add explicit type annotations to clarify intent</li>
</ul>
<h2 id="debugging-techniques"><a class="header" href="#debugging-techniques">Debugging Techniques</a></h2>
<h3 id="using-backtraces"><a class="header" href="#using-backtraces">Using Backtraces</a></h3>
<p>Ruby's built-in backtraces can help identify where problems originate:</p>
<pre><code class="language-ruby">begin
  # Code that might raise an exception
  MyExtension.problematic_method
rescue =&gt; e
  puts e.message
  puts e.backtrace
end
</code></pre>
<p>You can enhance backtraces with the <code>backtrace</code> gem:</p>
<pre><code class="language-ruby">require 'backtrace'
Backtrace.enable_ruby_source_inspect!

begin
  MyExtension.problematic_method
rescue =&gt; e
  puts Backtrace.for(e)
end
</code></pre>
<h3 id="vscode--lldb"><a class="header" href="#vscode--lldb">VSCode + LLDB</a></h3>
<p>The <a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">code-lldb</a> extension for VSCode is a great
way to debug Rust code. Here is an example configuration file:</p>
<pre><code class="language-json">// .vscode/launch.json
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "lldb",
      "request": "launch",
      "name": "Debug",
      "preLaunchTask": {
        "task": "compile:debug",
        "type": "rake"
      },
      "program": "~/.asdf/installs/ruby/3.1.1/bin/ruby",
      "args": ["-Ilib", "test/test_helper.rb"],
      "cwd": "${workspaceFolder}",
      "sourceLanguages": ["rust"]
    }
  ]
}
</code></pre>
<h3 id="debugging-the-ruby-c-api"><a class="header" href="#debugging-the-ruby-c-api">Debugging the Ruby C API</a></h3>
<p>With this basic setup, you can set breakpoints and interactively debug your Rust code. However, if Ruby is not built
with debug symbols, any calls into the Ruby C API become a black box. Luckily, it's straight-forward to fix this.</p>
<h4 id="compiling-ruby-with-debug-symbols-and-source-code"><a class="header" href="#compiling-ruby-with-debug-symbols-and-source-code">Compiling Ruby with debug symbols and source code</a></h4>
<h5 id="using-chruby-or-ruby-build"><a class="header" href="#using-chruby-or-ruby-build">Using <a href="https://github.com/postmodern/chruby"><code>chruby</code></a> or <a href="https://github.com/rbenv/ruby-build"><code>ruby-build</code></a></a></h5>
<ol>
<li>
<p>First, compile Ruby like so:</p>
<pre><code class="language-sh">$ RUBY_CFLAGS="-Og -ggdb" ruby-build --keep 3.1.2 /opt/rubies/3.1.2-debug
</code></pre>
</li>
<li>
<p>Make sure your <code>.vscode/launch.json</code> file is configured to use <code>/opt/rubies/3.1.2-debug/bin/ruby</code>.</p>
</li>
</ol>
<h5 id="using-rbenv"><a class="header" href="#using-rbenv">Using <a href="https://github.com/rbenv/rbenv"><code>rbenv</code></a></a></h5>
<ol>
<li>
<p>First, compile Ruby like so:</p>
<pre><code class="language-sh">$ RUBY_CFLAGS="-Og -ggdb" rbenv install --keep 3.1.2
</code></pre>
</li>
<li>
<p>Make sure your <code>.vscode/launch.json</code> file is configured to use <code>$RBENV_ROOT/versions/3.1.2/bin/ruby</code>.</p>
</li>
</ol>
<h3 id="lldb-from-the-command-line"><a class="header" href="#lldb-from-the-command-line">LLDB from the Command Line</a></h3>
<p>LLDB is an excellent tool for debugging Rust extensions from the command line:</p>
<ol>
<li>
<p>Compile with debug symbols:</p>
<pre><code class="language-bash">RUSTFLAGS="-g" bundle exec rake compile
</code></pre>
</li>
<li>
<p>Run Ruby with LLDB:</p>
<pre><code class="language-bash">lldb -- ruby -I lib -e 'require "my_extension"; MyExtension.method_to_debug'
</code></pre>
</li>
<li>
<p>Set breakpoints and run:</p>
<pre><code>(lldb) breakpoint set --name rb_my_method
(lldb) run
</code></pre>
</li>
<li>
<p>Common LLDB commands:</p>
<ul>
<li><code>bt</code> - Display backtrace</li>
<li><code>frame variable</code> - Show local variables</li>
<li><code>p expression</code> - Evaluate expression</li>
<li><code>n</code> - Step over</li>
<li><code>s</code> - Step into</li>
<li><code>c</code> - Continue</li>
</ul>
</li>
</ol>
<h3 id="gdb-for-linux"><a class="header" href="#gdb-for-linux">GDB for Linux</a></h3>
<p>GDB offers similar capabilities to LLDB on Linux systems:</p>
<ol>
<li>
<p>Compile with debug symbols:</p>
<pre><code class="language-bash">RUSTFLAGS="-g" bundle exec rake compile
</code></pre>
</li>
<li>
<p>Run Ruby with GDB:</p>
<pre><code class="language-bash">gdb --args ruby -I lib -e 'require "my_extension"; MyExtension.method_to_debug'
</code></pre>
</li>
<li>
<p>Set breakpoints and run:</p>
<pre><code>(gdb) break rb_my_method
(gdb) run
</code></pre>
</li>
<li>
<p>Common GDB commands:</p>
<ul>
<li><code>bt</code> - Display backtrace</li>
<li><code>info locals</code> - Show local variables</li>
<li><code>p expression</code> - Evaluate expression</li>
<li><code>n</code> - Step over</li>
<li><code>s</code> - Step into</li>
<li><code>c</code> - Continue</li>
</ul>
</li>
</ol>
<h3 id="rust-debugging-statements"><a class="header" href="#rust-debugging-statements">Rust Debugging Statements</a></h3>
<p>Strategic use of Rust's debug facilities can help identify issues:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Debug prints only included in debug builds
#[cfg(debug_assertions)]
println!("Debug: counter value = {}", counter);

// More structured logging
use log::{debug, error, info};

fn some_function() -&gt; Result&lt;(), Error&gt; {
    debug!("Entering some_function");

    if let Err(e) = fallible_operation() {
        error!("Operation failed: {}", e);
        return Err(e.into());
    }

    info!("Operation succeeded");
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>To enable logging output, add a logger like <code>env_logger</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    env_logger::init();
    // Rest of initialization...
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>And set the log level when running Ruby:</p>
<pre><code class="language-bash">RUST_LOG=debug ruby -I lib -e 'require "my_extension"'
</code></pre>
<h2 id="memory-leak-detection"><a class="header" href="#memory-leak-detection">Memory Leak Detection</a></h2>
<h3 id="using-ruby_memcheck"><a class="header" href="#using-ruby_memcheck">Using ruby_memcheck</a></h3>
<p>The <a href="https://github.com/Shopify/ruby_memcheck">ruby_memcheck</a> gem helps identify memory leaks in Ruby extensions by
filtering out Ruby's internal memory management noise when running Valgrind.</p>
<ol>
<li>
<p>Install dependencies:</p>
<pre><code class="language-bash">gem install ruby_memcheck
# On Debian/Ubuntu
apt-get install valgrind
</code></pre>
</li>
<li>
<p>Set up in your Rakefile:</p>
<pre><code class="language-ruby">require 'ruby_memcheck'

test_config = lambda do |t|
  t.libs &lt;&lt; "test"
  t.test_files = FileList["test/**/*_test.rb"]
end

namespace :test do
  RubyMemcheck::TestTask.new(valgrind: :compile, &amp;test_config)
end
</code></pre>
</li>
<li>
<p>Run memory leak detection:</p>
<pre><code class="language-bash">bundle exec rake test:valgrind
</code></pre>
</li>
</ol>
<p>For more detailed instructions and configuration options, refer to the
<a href="https://github.com/Shopify/ruby_memcheck">ruby_memcheck documentation</a>.</p>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<ol>
<li><strong>Add Meaningful Error Messages</strong>: Make your error messages descriptive and helpful</li>
<li><strong>Test Edge Cases</strong>: Thoroughly test edge cases like nil values, empty strings, etc.</li>
<li><strong>Maintain a Test Suite</strong>: Comprehensive tests catch issues early</li>
<li><strong>Use Memory Safety Features</strong>: Leverage Rust's safety features rather than bypassing them</li>
<li><strong>Provide Debugging Symbols</strong>: Always include debug symbol builds for better debugging</li>
<li><strong>Document Troubleshooting</strong>: Add a troubleshooting section to your extension's documentation</li>
<li><strong>Log Appropriately</strong>: Include contextual information in log messages</li>
</ol>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<ul>
<li>Build your extension with <code>RB_SYS_CARGO_PROFILE=dev</code> and practice setting breakpoints.</li>
<li>Explore GDB as an alternative to LLDB for low-level debugging.</li>
<li>See the Memory Management &amp; Safety chapter for GC-related troubleshooting.</li>
<li>If you're still stuck, <a href="https://join.slack.com/t/oxidize-rb/shared_invite/zt-16zv5tqte-Vi7WfzxCesdo2TqF_RYBCw">join the Slack channel</a> to ask questions and get help from the community!</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting-guide"><a class="header" href="#troubleshooting-guide">Troubleshooting Guide</a></h1>
<p>This chapter provides solutions to common issues encountered when developing Ruby extensions with rb-sys and magnus.</p>
<h2 id="getting-started-issues"><a class="header" href="#getting-started-issues">Getting Started Issues</a></h2>
<h3 id="installation-problems"><a class="header" href="#installation-problems">Installation Problems</a></h3>
<h4 id="missing-libclang"><a class="header" href="#missing-libclang">Missing libclang</a></h4>
<p><strong>Problem</strong>: Build fails with errors related to missing libclang:</p>
<pre><code>error: failed to run custom build command for `bindgen v0.64.0`
...
could not find libclang: "couldn't find any valid shared libraries matching: ['libclang.so', ...]"
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Add libclang to your Gemfile:</p>
<pre><code class="language-ruby">gem "libclang", "~&gt; 14.0"
</code></pre>
</li>
<li>
<p>On Linux, install libclang through your package manager:</p>
<pre><code class="language-bash"># Debian/Ubuntu
apt-get install libclang-dev

# Fedora/RHEL
dnf install clang-devel
</code></pre>
</li>
<li>
<p>On macOS:</p>
<pre><code class="language-bash">brew install llvm
export LLVM_CONFIG=$(brew --prefix llvm)/bin/llvm-config
</code></pre>
</li>
</ol>
<h4 id="ruby-headers-not-found"><a class="header" href="#ruby-headers-not-found">Ruby Headers Not Found</a></h4>
<p><strong>Problem</strong>: Build fails with error about missing Ruby headers:</p>
<pre><code>error: failed to run custom build command for `rb-sys v0.9.78`
...
fatal error: ruby.h: No such file or directory
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Ensure you have Ruby development headers installed:</p>
<pre><code class="language-bash"># Debian/Ubuntu
apt-get install ruby-dev

# Fedora/RHEL
dnf install ruby-devel
</code></pre>
</li>
<li>
<p>If using rbenv/rvm/asdf, make sure you've installed the development headers:</p>
<pre><code class="language-bash"># For rbenv
RUBY_CONFIGURE_OPTS=--enable-shared rbenv install 3.0.0

# For rvm
rvm install 3.0.0 --with-openssl-dir=$(brew --prefix openssl)
</code></pre>
</li>
<li>
<p>Check your build.rs file includes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _ = rb_sys_env::activate()?;
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h2 id="compilation-issues"><a class="header" href="#compilation-issues">Compilation Issues</a></h2>
<h3 id="cargo-build-errors"><a class="header" href="#cargo-build-errors">Cargo Build Errors</a></h3>
<h4 id="version-compatibility"><a class="header" href="#version-compatibility">Version Compatibility</a></h4>
<p><strong>Problem</strong>: Build fails with version incompatibility errors:</p>
<pre><code>error: failed to select a version for the requirement `rb-sys = "^0.9.80"`
</code></pre>
<p><strong>Solution</strong>:</p>
<ol>
<li>
<p>Check your magnus and rb-sys versions are compatible:</p>
<pre><code class="language-toml"># Cargo.toml
[dependencies]
magnus = "0.7"     # Check latest compatible version
rb-sys = "0.9.80"  # Check latest version
</code></pre>
</li>
<li>
<p>Update rb-sys in your Gemfile:</p>
<pre><code class="language-ruby">gem 'rb_sys', '~&gt; 0.9.80'
</code></pre>
</li>
</ol>
<h4 id="linking-issues"><a class="header" href="#linking-issues">Linking Issues</a></h4>
<p><strong>Problem</strong>: Build fails with undefined references:</p>
<pre><code>error: linking with `cc` failed: exit status: 1
...
undefined reference to `rb_define_module`
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Ensure your build.rs is correctly set up:</p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let _ = rb_sys_env::activate()?;
    Ok(())
}</code></pre></pre>
</li>
<li>
<p>Verify Ruby version compatibility with rb-sys version</p>
</li>
<li>
<p>Ensure you have Ruby development headers installed</p>
</li>
</ol>
<h4 id="build-script-errors"><a class="header" href="#build-script-errors">Build Script Errors</a></h4>
<p><strong>Problem</strong>: Build script execution fails:</p>
<pre><code>error: failed to run custom build command for `rb-sys v0.9.78`
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Check permissions and environment variables:</p>
<pre><code class="language-bash"># Set necessary environment variables
export RUBY_ROOT=$(rbenv prefix)
export PATH=$RUBY_ROOT/bin:$PATH
</code></pre>
</li>
<li>
<p>If using Docker, ensure the build environment has Ruby installed and configured</p>
</li>
</ol>
<h2 id="runtime-issues"><a class="header" href="#runtime-issues">Runtime Issues</a></h2>
<h3 id="ruby-object-management"><a class="header" href="#ruby-object-management">Ruby Object Management</a></h3>
<h4 id="segmentation-faults-1"><a class="header" href="#segmentation-faults-1">Segmentation Faults</a></h4>
<p><strong>Problem</strong>: Ruby process crashes with a segmentation fault:</p>
<pre><code>[BUG] Segmentation fault
ruby 3.0.0p0 (2020-12-25 revision 95aff21468) [x86_64-linux]
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Ensure Ruby objects are correctly protected from garbage collection:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Using Magnus (preferred)
let obj = RObject::new(ruby, ruby.class_object())?;

// With raw rb-sys
unsafe {
    let obj = rb_sys::rb_obj_alloc(rb_sys::rb_cObject);
    rb_sys::rb_gc_register_mark_object(obj);
    // Use obj...
    rb_sys::rb_gc_unregister_mark_object(obj);
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Check all pointers are valid before dereferencing</p>
</li>
<li>
<p>Use TypedData with proper mark implementation</p>
</li>
</ol>
<h4 id="borrowmuterror-panics"><a class="header" href="#borrowmuterror-panics">BorrowMutError Panics</a></h4>
<p><strong>Problem</strong>: Your extension panics with a "already borrowed" error when using RefCell:</p>
<pre><code>thread '&lt;unnamed&gt;' panicked at 'already borrowed: BorrowMutError'
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Fix borrow order - always complete immutable borrows before mutable borrows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WRONG - causes BorrowMutError
if self.0.borrow().value &gt; 10 {
    self.0.borrow_mut().value = 0; // Error: still borrowed from the if condition
}

// RIGHT - copy values then borrow mutably
let current = self.0.borrow().value; // Complete this borrow
if current &gt; 10 {
    self.0.borrow_mut().value = 0; // Now safe to borrow mutably
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Consider restructuring your data to avoid nested borrows</p>
</li>
<li>
<p>Use separate methods for reading and writing</p>
</li>
</ol>
<h3 id="rubyrust-type-conversion-issues"><a class="header" href="#rubyrust-type-conversion-issues">Ruby/Rust Type Conversion Issues</a></h3>
<h4 id="unexpected-nil-values"><a class="header" href="#unexpected-nil-values">Unexpected Nil Values</a></h4>
<p><strong>Problem</strong>: Your extension crashes when encountering nil:</p>
<pre><code>TypeError: no implicit conversion of nil into String
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Always check for nil before conversion:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process_string(val: Value) -&gt; Result&lt;String, Error&gt; {
    if val.is_nil() {
        // Handle nil case
        return Ok("default".to_string());
    }

    let string = RString::try_convert(val)?;
    Ok(string.to_string()?)
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Use Option for conversions that might return nil:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let maybe_string: Option&lt;String&gt; = val.try_convert()?;
match maybe_string {
    Some(s) =&gt; process_string(s),
    None =&gt; handle_nil_case(),
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h4 id="type-errors"><a class="header" href="#type-errors">Type Errors</a></h4>
<p><strong>Problem</strong>: Function fails with type mismatch errors:</p>
<pre><code>TypeError: wrong argument type Integer (expected String)
</code></pre>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Add explicit type checking before conversion:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn process_value(ruby: &amp;Ruby, val: Value) -&gt; Result&lt;(), Error&gt; {
    if !val.is_kind_of(ruby, ruby.class_object::&lt;RString&gt;()?) {
        return Err(Error::new(
            ruby.exception_type_error(),
            format!("Expected String, got {}", val.class().name())
        ));
    }

    let string = RString::try_convert(val)?;
    // Process string...
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Use try_convert with proper error handling:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match RString::try_convert(val) {
    Ok(string) =&gt; {
        // Process string...
        Ok(())
    },
    Err(_) =&gt; {
        Err(Error::new(
            ruby.exception_type_error(),
            "Expected String argument"
        ))
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h2 id="memory-and-performance-issues"><a class="header" href="#memory-and-performance-issues">Memory and Performance Issues</a></h2>
<h3 id="memory-leaks"><a class="header" href="#memory-leaks">Memory Leaks</a></h3>
<p><strong>Problem</strong>: Your extension gradually consumes more memory over time.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Ensure Ruby objects are properly released when using raw rb-sys:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe {
    // Register the object to protect it from GC
    rb_sys::rb_gc_register_mark_object(obj);

    // Use the object...

    // Unregister when done (important!)
    rb_sys::rb_gc_unregister_mark_object(obj);
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Implement proper mark methods for TypedData:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(TypedData)]
#[magnus(class = "MyClass", free_immediately, mark)]
struct MyObject {
    references: Vec&lt;Value&gt;,
}

impl DataTypeFunctions for MyObject {
    fn mark(&amp;self, marker: &amp;Marker) {
        for reference in &amp;self.references {
            marker.mark(*reference);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Use ruby_memcheck to detect leaks (see <a href="debugging.html">Debugging chapter</a>)</p>
</li>
</ol>
<h3 id="global-vm-lock-gvl-issues"><a class="header" href="#global-vm-lock-gvl-issues">Global VM Lock (GVL) Issues</a></h3>
<p><strong>Problem</strong>: CPU-intensive operations block the Ruby VM.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Release the GVL during CPU-intensive work:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use rb_sys::rb_thread_call_without_gvl;
use std::{ffi::c_void, ptr::null_mut};

pub fn nogvl&lt;F, R&gt;(func: F) -&gt; R
where
    F: FnOnce() -&gt; R,
    R: Send + 'static,
{
    struct CallbackData&lt;F, R&gt; {
        func: Option&lt;F&gt;,
        result: Option&lt;R&gt;,
    }

    extern "C" fn callback&lt;F, R&gt;(data: *mut c_void) -&gt; *mut c_void
    where
        F: FnOnce() -&gt; R,
        R: Send + 'static,
    {
        let data = unsafe { &amp;mut *(data as *mut CallbackData&lt;F, R&gt;) };
        if let Some(func) = data.func.take() {
            data.result = Some(func());
        }
        null_mut()
    }

    let mut data = CallbackData {
        func: Some(func),
        result: None,
    };

    unsafe {
        rb_thread_call_without_gvl(
            Some(callback::&lt;F, R&gt;),
            &amp;mut data as *mut _ as *mut c_void,
            None,
            null_mut(),
        );
    }

    data.result.unwrap()
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Only release the GVL for operations that don't interact with Ruby objects:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Safe to run without GVL - pure computation
let result = nogvl(|| {
    compute_intensive_function(input_data)
});

// NOT safe to run without GVL - interacts with Ruby
// let result = nogvl(|| {
//     ruby_object.some_method() // WRONG - will crash
// });
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h2 id="cross-platform-issues"><a class="header" href="#cross-platform-issues">Cross-Platform Issues</a></h2>
<h3 id="ruby-head-compatibility-issues"><a class="header" href="#ruby-head-compatibility-issues">Ruby-Head Compatibility Issues</a></h3>
<p><strong>Problem</strong>: Gems don't work with <code>ruby-head</code> or development versions of Ruby.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Always publish a source gem alongside platform-specific gems:</p>
<pre><code class="language-ruby"># In your release workflow, build both platform-specific and source gems
# The source gem allows ruby-head users to compile against their exact version
bundle exec rake build  # For source gem
bundle exec rake native # For platform-specific gems
</code></pre>
</li>
<li>
<p>For users, install the gem with compilation enabled:</p>
<pre><code class="language-bash">gem install my_gem --platform=ruby
</code></pre>
</li>
<li>
<p>For gem maintainers, update your CI to test against ruby-head:</p>
<pre><code class="language-yaml"># .github/workflows/test.yml
strategy:
  matrix:
    ruby: ["3.1", "3.2", "3.3", "head"]
</code></pre>
</li>
</ol>
<h3 id="platform-specific-build-problems"><a class="header" href="#platform-specific-build-problems">Platform-Specific Build Problems</a></h3>
<h4 id="windows-issues"><a class="header" href="#windows-issues">Windows Issues</a></h4>
<p><strong>Problem</strong>: Build fails on Windows with linking errors.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Ensure you have the correct toolchain installed:</p>
<pre><code class="language-bash">rustup target add x86_64-pc-windows-msvc
</code></pre>
</li>
<li>
<p>Add platform-specific configuration in Cargo.toml:</p>
<pre><code class="language-toml">[target.'cfg(windows)'.dependencies]
winapi = { version = "0.3", features = ["everything"] }
</code></pre>
</li>
<li>
<p>Use conditional compilation for platform-specific code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(windows)]
fn platform_specific() {
    // Windows-specific code
}

#[cfg(unix)]
fn platform_specific() {
    // Unix-specific code
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h4 id="macos-issues"><a class="header" href="#macos-issues">macOS Issues</a></h4>
<p><strong>Problem</strong>: Build fails on macOS with architecture or linking issues.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Specify architecture when needed:</p>
<pre><code class="language-bash">RUBY_CONFIGURE_OPTS="--with-arch=x86_64,arm64" rbenv install 3.0.0
</code></pre>
</li>
<li>
<p>Fix linking for universal binaries:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// build.rs
#[cfg(target_os = "macos")]
{
    println!("cargo:rustc-link-arg=-arch");
    println!("cargo:rustc-link-arg=arm64");
    println!("cargo:rustc-link-arg=-arch");
    println!("cargo:rustc-link-arg=x86_64");
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h3 id="cargotoml-configuration-issues"><a class="header" href="#cargotoml-configuration-issues">Cargo.toml Configuration Issues</a></h3>
<h4 id="feature-flag-problems"><a class="header" href="#feature-flag-problems">Feature Flag Problems</a></h4>
<p><strong>Problem</strong>: Build fails because of conflicting or missing feature flags.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Check for feature flag issues in dependencies:</p>
<pre><code class="language-toml">[dependencies]
magnus = { version = "0.7", features = ["rb-sys"] }
rb-sys = { version = "0.9.80", features = ["stable-api"] }
</code></pre>
</li>
<li>
<p>Use debug prints in build.rs to check feature detection:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("cargo:warning=Ruby version: {}", rb_sys_env::ruby_major_version());

    #[cfg(feature = "some-feature")]
    println!("cargo:warning=some-feature is enabled");
}</code></pre></pre>
</li>
</ol>
<h2 id="ruby-integration-issues"><a class="header" href="#ruby-integration-issues">Ruby Integration Issues</a></h2>
<h3 id="method-definition-problems"><a class="header" href="#method-definition-problems">Method Definition Problems</a></h3>
<p><strong>Problem</strong>: Ruby method definitions don't work as expected.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Check method arity and macro usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For instance methods (that use &amp;self)
class.define_method("instance_method", method!(MyClass::instance_method, 1))?;

// For class/module methods (no &amp;self)
class.define_singleton_method("class_method", function!(class_method, 1))?;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Verify method signatures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Instance method
fn instance_method(&amp;self, arg: Value) -&gt; Result&lt;Value, Error&gt; {
    // Method implementation...
}

// Class method
fn class_method(arg: Value) -&gt; Result&lt;Value, Error&gt; {
    // Method implementation...
}

// Method with ruby
fn method_with_ruby(ruby: &amp;Ruby, arg: Value) -&gt; Result&lt;Value, Error&gt; {
    // Method implementation...
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h3 id="moduleclass-hierarchy-issues"><a class="header" href="#moduleclass-hierarchy-issues">Module/Class Hierarchy Issues</a></h3>
<p><strong>Problem</strong>: Ruby modules or classes aren't defined correctly.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Check the correct nesting of defines:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define a module and a nested class
let module = ruby.define_module("MyModule")?;
let class = module.define_class("MyClass", ruby.class_object())?;

// Define a nested module
let nested = module.define_module("Nested")?;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Verify class inheritance:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get the correct superclass
let superclass = ruby.class_object::&lt;RObject&gt;()?;

// Define a class with the superclass
let class = ruby.define_class("MyClass", superclass)?;
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h2 id="debugging-ruby-exceptions"><a class="header" href="#debugging-ruby-exceptions">Debugging Ruby Exceptions</a></h2>
<h3 id="custom-exception-handling"><a class="header" href="#custom-exception-handling">Custom Exception Handling</a></h3>
<p><strong>Problem</strong>: Ruby exceptions aren't properly caught or raised.</p>
<p><strong>Solutions</strong>:</p>
<ol>
<li>
<p>Define and use custom exception classes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let module = ruby.define_module("MyModule")?;

    // Define custom exceptions
    let std_error = ruby.exception_standard_error();
    let custom_error = module.define_class("CustomError", std_error)?;

    Ok(())
}

fn raise_custom_error(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    Err(Error::new(
        ruby.class_path_to_value("MyModule::CustomError"),
        "Something went wrong"
    ))
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Catch specific exception types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_exceptions(ruby: &amp;Ruby, val: Value) -&gt; Result&lt;Value, Error&gt; {
    let result = val.funcall(ruby, "may_raise", ());

    match result {
        Ok(v) =&gt; Ok(v),
        Err(e) if e.is_kind_of(ruby, ruby.exception_zero_div_error()) =&gt; {
            // Handle division by zero
            Ok(ruby.integer_from_i64(0))
        },
        Err(e) =&gt; Err(e), // Re-raise other exceptions
    }
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h2 id="additional-resources"><a class="header" href="#additional-resources">Additional Resources</a></h2>
<ul>
<li><strong>Official Documentation</strong>: <a href="https://github.com/oxidize-rb/rb-sys">rb-sys</a> and
<a href="https://github.com/matsadler/magnus">magnus</a></li>
<li><strong>Examples</strong>: Check the <a href="https://github.com/oxidize-rb/rb-sys/tree/main/examples">examples directory</a> in rb-sys</li>
<li><strong>Community Support</strong>:
<a href="https://join.slack.com/t/oxidize-rb/shared_invite/zt-16zv5tqte-Vi7WfzxCesdo2TqF_RYBCw">Join the Slack channel</a></li>
<li><strong>Further Reading</strong>: See the <a href="debugging.html">Debugging chapter</a> for more detailed debugging techniques</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rb-sys-crate-features"><a class="header" href="#rb-sys-crate-features">rb-sys Crate Features</a></h1>
<p>The <code>rb-sys</code> crate provides battle-tested Rust bindings for the Ruby C API. It uses the
<a href="https://github.com/rust-lang/rust-bindgen"><code>rust-bindgen</code></a> crate to generate bindings from the <code>ruby.h</code> header.</p>
<h2 id="usage-notice"><a class="header" href="#usage-notice">Usage Notice</a></h2>
<p>This is a very low-level library. If you are looking to write a gem in Rust, you should probably use the
<a href="https://github.com/matsadler/magnus">Magnus</a> crate with the <code>rb-sys-interop</code> feature, which provides a higher-level,
more ergonomic API.</p>
<p>If you need raw/unsafe bindings to libruby, then this crate is for you!</p>
<h2 id="writing-a-ruby-gem"><a class="header" href="#writing-a-ruby-gem">Writing a Ruby Gem</a></h2>
<p>Ruby gems require boilerplate to be defined to be usable from Ruby. <code>rb-sys</code> makes this process painless by doing the
work for you. Simply enable the <code>gem</code> feature:</p>
<pre><code class="language-toml">[dependencies]
rb-sys = "0.9"
</code></pre>
<p>Under the hood, this ensures the crate does not link libruby (unless on Windows) and defines a <code>ruby_abi_version</code>
function for Ruby 3.2+.</p>
<h2 id="embedding-libruby-in-your-rust-app"><a class="header" href="#embedding-libruby-in-your-rust-app">Embedding libruby in Your Rust App</a></h2>
<p><strong>IMPORTANT</strong>: If you are authoring a Ruby gem, you do not need to enable this feature.</p>
<p>If you need to link libruby (i.e., you are initializing a Ruby VM in your Rust code), you can enable the <code>link-ruby</code>
feature:</p>
<pre><code class="language-toml">[dependencies]
rb-sys = { version = "0.9", features = ["link-ruby"] }
</code></pre>
<h2 id="static-libruby"><a class="header" href="#static-libruby">Static libruby</a></h2>
<p>You can also force static linking of libruby:</p>
<pre><code class="language-toml">[dependencies]
rb-sys = { version = "0.9", features = ["ruby-static"] }
</code></pre>
<p>Alternatively, you can set the <code>RUBY_STATIC=true</code> environment variable.</p>
<h2 id="available-features"><a class="header" href="#available-features">Available Features</a></h2>
<p>The <code>rb-sys</code> crate provides several features that can be enabled in your <code>Cargo.toml</code>:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Description</th></tr></thead><tbody>
<tr><td><code>global-allocator</code></td><td>Report Rust memory allocations to the Ruby GC (<em>recommended</em>)</td></tr>
<tr><td><code>ruby-static</code></td><td>Link the static version of libruby</td></tr>
<tr><td><code>link-ruby</code></td><td>Link libruby (typically used for embedding, not for extensions)</td></tr>
<tr><td><code>bindgen-rbimpls</code></td><td>Include the Ruby impl types in bindings</td></tr>
<tr><td><code>bindgen-deprecated-types</code></td><td>Include deprecated Ruby methods in bindings</td></tr>
<tr><td><code>gem</code></td><td>Set up the crate for use in a Ruby gem (default feature)</td></tr>
<tr><td><code>stable-api</code></td><td>Use the stable API (C level) if available for your Ruby version</td></tr>
</tbody></table>
</div>
<h2 id="example-cargotoml"><a class="header" href="#example-cargotoml">Example Cargo.toml</a></h2>
<pre><code class="language-toml">[dependencies]
rb-sys = { version = "0.9", features = ["global-allocator", "stable-api"] }
</code></pre>
<h2 id="ruby-version-compatibility"><a class="header" href="#ruby-version-compatibility">Ruby Version Compatibility</a></h2>
<p><code>rb-sys</code> is compatible with Ruby 2.6 and later. The crate detects the Ruby version at compile time and adapts the
bindings accordingly.</p>
<p>For Ruby 3.2 and later, <code>rb-sys</code> provides a <code>ruby_abi_version</code> function that is required for native extensions.</p>
<h2 id="integration-with-magnus"><a class="header" href="#integration-with-magnus">Integration with Magnus</a></h2>
<p>If you're building a Ruby extension, it's recommended to use the <a href="https://github.com/matsadler/magnus">Magnus</a> crate on
top of <code>rb-sys</code>. Magnus provides a high-level, safe API for interacting with Ruby:</p>
<pre><code class="language-toml">[dependencies]
magnus = { version = "0.7", features = ["rb-sys"] }
rb-sys = "0.9"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rb_sys-gem-configuration"><a class="header" href="#rb_sys-gem-configuration">rb_sys Gem Configuration</a></h1>
<p>The <code>rb_sys</code> gem makes it easy to build native Ruby extensions in Rust. It interoperates with existing Ruby native
extension toolchains (i.e., <code>rake-compiler</code>) to make testing, building, and cross-compilation of gems easy.</p>
<h2 id="rbsysextensiontask"><a class="header" href="#rbsysextensiontask">RbSys::ExtensionTask</a></h2>
<p>This gem provides a <code>RbSys::ExtensionTask</code> class that can be used to build a Ruby extension in Rust. It's a thin wrapper
around <code>Rake::ExtensionTask</code> that provides sane defaults for building Rust extensions.</p>
<pre><code class="language-ruby"># Rakefile

require "rb_sys/extensiontask"

GEMSPEC = Gem::Specification.load("my_gem.gemspec")

RbSys::ExtensionTask.new("my-crate-name", GEMSPEC) do |ext|
  ext.lib_dir = "lib/my_gem"

  # If you want to use `rb-sys-dock` for cross-compilation:
  ext.cross_compile = true
end
</code></pre>
<h2 id="create_rust_makefile"><a class="header" href="#create_rust_makefile">create_rust_makefile</a></h2>
<p>The gem provides a simple helper to build a Ruby-compatible Makefile for your Rust extension:</p>
<pre><code class="language-ruby"># ext/rust_reverse/extconf.rb

# We need to require mkmf *first* since `rake-compiler` injects code here for cross compilation
require "mkmf"
require "rb_sys/mkmf"

create_rust_makefile("rust_reverse") do |r|
  # Create debug builds in dev. Make sure that release gems are compiled with
  # `RB_SYS_CARGO_PROFILE=release` (optional)
  r.profile = ENV.fetch("RB_SYS_CARGO_PROFILE", :dev).to_sym

  # Can be overridden with `RB_SYS_CARGO_FEATURES` env var (optional)
  r.features = ["test-feature"]

  # You can add whatever env vars you want to the env hash (optional)
  r.env = {"FOO" =&gt; "BAR"}

  # If your Cargo.toml is in a different directory, you can specify it here (optional)
  r.ext_dir = "."

  # Extra flags to pass to the $RUSTFLAGS environment variable (optional)
  r.extra_rustflags = ["--cfg=some_nested_config_var_for_crate"]

  # Force a rust toolchain to be installed via rustup (optional)
  # You can also set the env var `RB_SYS_FORCE_INSTALL_RUST_TOOLCHAIN=true`
  r.force_install_rust_toolchain = "stable"

  # Clean up the target/ dir after `gem install` to reduce bloat (optional)
  r.clean_after_install = false # default: true if invoked by rubygems

  # Auto-install Rust toolchain if not present on "gem install" (optional)
  r.auto_install_rust_toolchain = false # default: true if invoked by rubygems
end
</code></pre>
<h2 id="environment-variables-1"><a class="header" href="#environment-variables-1">Environment Variables</a></h2>
<p>The <code>rb_sys</code> gem respects several environment variables that can modify its behavior:</p>
<div class="table-wrapper"><table><thead><tr><th>Environment Variable</th><th>Description</th></tr></thead><tbody>
<tr><td><code>RB_SYS_CARGO_PROFILE</code></td><td>Set the Cargo profile (i.e., <code>release</code> or <code>dev</code>)</td></tr>
<tr><td><code>RB_SYS_CARGO_FEATURES</code></td><td>Comma-separated list of Cargo features to enable</td></tr>
<tr><td><code>RB_SYS_FORCE_INSTALL_RUST_TOOLCHAIN</code></td><td>Force installation of a Rust toolchain</td></tr>
<tr><td><code>RUBY_STATIC</code></td><td>Force static linking of libruby if set to <code>true</code></td></tr>
<tr><td><code>LIBCLANG_PATH</code></td><td>Path to libclang if it can't be found automatically</td></tr>
</tbody></table>
</div>
<h2 id="tips-and-tricks"><a class="header" href="#tips-and-tricks">Tips and Tricks</a></h2>
<ul>
<li>
<p>When using <code>rake-compiler</code> to build your gem, you can use the <code>RB_SYS_CARGO_PROFILE</code> environment variable to set the
Cargo profile (i.e., <code>release</code> or <code>dev</code>).</p>
</li>
<li>
<p>You can pass Cargo arguments to <code>rake-compiler</code> like so: <code>rake compile -- --verbose</code></p>
</li>
<li>
<p>It's possible to force an installation of a Rust toolchain by setting the <code>RB_SYS_FORCE_INSTALL_RUST_TOOLCHAIN</code>
environment variable. This will install <a href="https://rustup.rs/">rustup</a> and <a href="https://crates.io/">cargo</a> in the build
directory, so the end user does not have to have Rust pre-installed. Ideally, this should be a last resort, as it's
better to already have the toolchain installed on your system.</p>
</li>
</ul>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="libclang-issues"><a class="header" href="#libclang-issues">Libclang Issues</a></h3>
<p>If you see an error like this:</p>
<pre><code>thread 'main' panicked at 'Unable to find libclang: "couldn't find any valid shared libraries matching: \['libclang.so', 'libclang-*.so', 'libclang.so.*', 'libclang-*.so.*'\], set the `LIBCLANG_PATH` environment variable to a path where one of these files can be found (invalid: \[\])"'
</code></pre>
<p>This means that bindgen is having issues finding a usable version of libclang. An easy way to fix this is to install the
<a href="https://github.com/oxidize-rb/libclang-rb"><code>libclang</code> gem</a>, which will install a pre-built version of libclang for you.
<code>rb_sys</code> will automatically detect this gem and use it.</p>
<pre><code class="language-ruby"># Gemfile
gem "libclang", "~&gt; 14.0.6"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rb-sys-test-helpers"><a class="header" href="#rb-sys-test-helpers">rb-sys-test-helpers</a></h1>
<p>The <code>rb-sys-test-helpers</code> crate provides utilities for testing Ruby extensions from Rust. It makes it easy to run tests
with a valid Ruby VM.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>Add this to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dev-dependencies]
rb-sys-env = { version = "0.1" }
rb-sys-test-helpers = { version = "0.2" }
</code></pre>
<p>Then, in your crate's <code>build.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">pub fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let _ = rb_sys_env::activate()?;

    Ok(())
}</code></pre></pre>
<p>Then, you can use the <code>ruby_test</code> attribute macro in your tests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use rb_sys_test_helpers::ruby_test;
    use rb_sys::{rb_num2fix, rb_int2big, FIXNUM_P};

    #[ruby_test]
    fn test_something() {
        // Your test code here will have a valid Ruby VM (hint: this works with
        // the `magnus` crate, too!)
        //
        // ...

        let int = unsafe { rb_num2fix(1) };
        let big = unsafe { rb_int2big(9999999) };

        assert!(FIXNUM_P(int));
        assert!(!FIXNUM_P(big));
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<p>The <code>ruby_test</code> macro sets up a Ruby VM before running your test and tears it down afterward. This allows you to
interact with Ruby from your Rust code during tests without having to set up the VM yourself.</p>
<p>The test helpers are compatible with both <code>rb-sys</code> for low-level C API access and <code>magnus</code> for higher-level Ruby
interactions.</p>
<h2 id="common-testing-patterns-1"><a class="header" href="#common-testing-patterns-1">Common Testing Patterns</a></h2>
<h3 id="testing-value-conversions"><a class="header" href="#testing-value-conversions">Testing Value Conversions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ruby_test]
fn test_value_conversion() {
    use rb_sys::{rb_cObject, rb_funcall, rb_str_new_cstr, rb_iv_set};
    use std::ffi::CString;

    unsafe {
        let obj = rb_cObject;
        let name = CString::new("test").unwrap();
        let value = rb_str_new_cstr(name.as_ptr());

        rb_iv_set(obj, b"@name\0".as_ptr() as *const _, value);

        let result = rb_funcall(obj, b"instance_variable_get\0".as_ptr() as *const _, 1,
                                rb_str_new_cstr(b"@name\0".as_ptr() as *const _));

        assert_eq!(value, result);
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="testing-with-magnus"><a class="header" href="#testing-with-magnus">Testing with Magnus</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ruby_test]
fn test_with_magnus() {
    use magnus::{Ruby, RString, Value};

    let ruby = unsafe { Ruby::get().unwrap() };
    let string = RString::new(ruby, "Hello, world!").unwrap();

    assert_eq!(string.to_string().unwrap(), "Hello, world!");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-multiple-ruby-versions"><a class="header" href="#testing-multiple-ruby-versions">Testing Multiple Ruby Versions</a></h2>
<p>To test against multiple Ruby versions, you can use environment variables and CI configuration:</p>
<pre><code class="language-yaml"># .github/workflows/test.yml
jobs:
  test:
    strategy:
      matrix:
        ruby: ["2.7", "3.0", "3.1", "3.2", "3.3"]
    steps:
      - uses: actions/checkout@v4
      - uses: oxidize-rb/actions/setup-ruby-and-rust@v1
        with:
          ruby-version: ${{ matrix.ruby }}
      - run: cargo test
</code></pre>
<p>Your tests will run against each Ruby version in the matrix, helping you ensure compatibility.</p>
<h2 id="integration-with-other-test-frameworks"><a class="header" href="#integration-with-other-test-frameworks">Integration with Other Test Frameworks</a></h2>
<p>The <code>ruby_test</code> attribute works with common Rust test frameworks like <code>proptest</code> and <code>quickcheck</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[ruby_test]
fn test_with_proptest() {
    use proptest::prelude::*;

    proptest!(|(s in "[a-zA-Z0-9]*")| {
        let ruby = unsafe { Ruby::get().unwrap() };
        let ruby_string = RString::new(ruby, &amp;s).unwrap();
        assert_eq!(ruby_string.to_string().unwrap(), s);
    });
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="community-and-support"><a class="header" href="#community-and-support">Community and Support</a></h1>
<p>The rb-sys project is maintained by the Oxidize Ruby community, a group of developers passionate about integrating Rust
and Ruby. We're committed to helping you succeed with your Rust-powered Ruby extensions.</p>
<h2 id="getting-help-1"><a class="header" href="#getting-help-1">Getting Help</a></h2>
<p>If you encounter issues or have questions about using rb-sys, there are several ways to get help:</p>
<h3 id="join-our-slack-community"><a class="header" href="#join-our-slack-community">Join Our Slack Community</a></h3>
<p>The Oxidize Ruby community has an active Slack workspace where you can ask questions, share your projects, and get help
from community members and maintainers.</p>
<ul>
<li><a href="https://join.slack.com/t/oxidize-rb/shared_invite/zt-16zv5tqte-Vi7WfzxCesdo2TqF_RYBCw">Join the Oxidize Ruby Slack</a></li>
<li>Post your question in the <code>#general</code> channel</li>
</ul>
<h3 id="github-issues"><a class="header" href="#github-issues">GitHub Issues</a></h3>
<p>If you think you've found a bug or want to request a new feature, please open an issue on GitHub:</p>
<ul>
<li><a href="https://github.com/oxidize-rb/rb-sys/issues">Open an issue on the rb-sys repository</a></li>
</ul>
<h3 id="real-world-examples-3"><a class="header" href="#real-world-examples-3">Real-World Examples</a></h3>
<p>Looking at real-world examples can be a great way to learn how to use rb-sys effectively:</p>
<ul>
<li><a href="https://github.com/oxidize-rb/oxi-test">oxi-test</a> - The canonical example of how to use rb-sys</li>
<li><a href="https://github.com/bytecodealliance/wasmtime-rb">wasmtime-rb</a> - WebAssembly runtime for Ruby</li>
<li><a href="https://github.com/yoshoku/lz4-ruby">lz4-ruby</a> - LZ4 compression library</li>
<li><a href="https://github.com/oxidize-rb/blake3-ruby">blake3-ruby</a> - BLAKE3 cryptographic hash function</li>
</ul>
<h2 id="contributing-to-rb-sys"><a class="header" href="#contributing-to-rb-sys">Contributing to rb-sys</a></h2>
<p>We welcome contributions from the community! Whether it's improving documentation, fixing bugs, or adding new features,
your contributions are valuable.</p>
<p>See the <a href="../../CONTRIBUTING.html">Contributing Guide</a> for detailed information about setting up a development environment
and making contributions.</p>
<h2 id="resources"><a class="header" href="#resources">Resources</a></h2>
<h3 id="documentation"><a class="header" href="#documentation">Documentation</a></h3>
<ul>
<li><a href="https://oxidize-rb.github.io/rb-sys/">Ruby on Rust Book</a> - This comprehensive guide</li>
<li><a href="https://docs.rs/rb-sys/">rb-sys API Docs</a> - Rust API documentation</li>
<li><a href="https://github.com/matsadler/magnus">Magnus Documentation</a> - Higher-level Ruby/Rust bindings built on rb-sys</li>
</ul>
<h3 id="tools"><a class="header" href="#tools">Tools</a></h3>
<ul>
<li><a href="https://github.com/oxidize-rb/rb-sys-dock">rb-sys-dock</a> - Docker-based cross-compilation tooling</li>
<li><a href="https://github.com/oxidize-rb/actions">GitHub Actions</a> - CI actions for testing and cross-compiling</li>
<li><a href="https://oxidize-rb.github.io/rb-sys/debugging.html">VSCode Debugging Guide</a> - How to set up debugging for Rust
extensions</li>
</ul>
<h3 id="blog-posts-and-talks"><a class="header" href="#blog-posts-and-talks">Blog Posts and Talks</a></h3>
<ul>
<li><a href="https://github.com/ianks/2022-09-09-ruby-on-rust-intro">Ruby on Rust - Intro</a> - Introduction to Ruby and Rust
integration</li>
<li><a href="https://oxidize-rb.github.io/rb-sys/cross-platform.html">Cross-compiling Ruby C Extensions</a> - How to compile for
multiple platforms</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-rb-sys-1"><a class="header" href="#contributing-to-rb-sys-1">Contributing to rb-sys</a></h1>

                    </main>

                    <nav class="nav-wrapper" style="margin-bottom: 0;" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                    
                    <div class="footer-note" style="margin: 3rem 0 0 0; padding: 2rem; font-size: 1.1rem; color: #555; border-top: 1px solid #ddd; display: flex; justify-content: center; align-items: center; font-family: inherit;">
                        <div style="max-width: 800px; text-align: center; line-height: 1.6;">
                            This documentation was created with assistance from an LLM.<br>
                            If you spot any issues, please <a href="https://github.com/oxidize-rb/rb-sys/issues" style="color: #3184a8; text-decoration: none; font-weight: bold;">submit a fix or report it</a>.<br>
                            We appreciate your help in improving these docs!
                        </div>
                    </div>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/js/custom.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
