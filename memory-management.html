<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ruby on Rust: Memory Management &amp; Safety</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A comprehensive guide to building Ruby extensions with Rust using rb-sys">
        <meta name="keywords" content="ruby, rust, ffi, bindings, rb-sys, ruby on rust">
        <meta name="author" content="">
        
        <!-- Open Graph / Facebook -->
        <meta property="og:type" content="website">
        <meta property="og:url" content="">
        <meta property="og:title" content="Ruby on Rust: Memory Management &amp; Safety">
        <meta property="og:description" content="A comprehensive guide to building Ruby extensions with Rust using rb-sys">
        
        <!-- Twitter -->
        <meta property="twitter:card" content="summary_large_image">
        <meta property="twitter:url" content="">
        <meta property="twitter:title" content="Ruby on Rust: Memory Management &amp; Safety">
        <meta property="twitter:description" content="A comprehensive guide to building Ruby extensions with Rust using rb-sys">
        
        <!-- Canonical URL -->
        <link rel="canonical" href="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/css/custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Ruby on Rust Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/oxidize-rb/rb-sys" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="memory-management--safety"><a class="header" href="#memory-management--safety">Memory Management &amp; Safety</a></h1>
<p>One of the most important aspects of writing Ruby extensions is proper memory management. This chapter covers how Ruby's
garbage collector interacts with Rust objects and how to ensure your extensions don't leak memory or cause segmentation
faults.</p>
<div class="warning">
<p>Improper memory management is the leading cause of crashes and security vulnerabilities in native extensions. Rust's
safety guarantees help prevent many common issues, but you still need to carefully manage the boundary between Ruby and
Rust memory.</p>
</div>
<h2 id="rubys-garbage-collection-system"><a class="header" href="#rubys-garbage-collection-system">Ruby's Garbage Collection System</a></h2>
<p>Ruby uses a mark-and-sweep garbage collector to manage memory. Understanding how it works is essential for writing safe
extensions:</p>
<ol>
<li><strong>Marking Phase</strong>: Ruby traverses all visible objects, marking them as "in use"</li>
<li><strong>Sweeping Phase</strong>: Objects that weren't marked are considered garbage and freed</li>
</ol>
<div class="note">
<p>When you create Rust objects that reference Ruby objects, you need to tell Ruby's GC about these references to prevent
premature garbage collection. The <code>TypedData</code> trait and <code>mark</code> method provide the mechanism to do this.</p>
</div>
<h2 id="typeddata-and-datatypefunctions"><a class="header" href="#typeddata-and-datatypefunctions">TypedData and DataTypeFunctions</a></h2>
<p>Magnus provides a <code>TypedData</code> trait and <code>DataTypeFunctions</code> trait for managing Ruby objects that wrap Rust structs. This
is the recommended way to handle complex objects in Rust.</p>
<h3 id="basic-typeddata-example"><a class="header" href="#basic-typeddata-example">Basic TypedData Example</a></h3>
<p>Here's how to define a simple Ruby object that wraps a Rust struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{prelude::*, Error, Ruby, TypedData, DataTypeFunctions};

// Define your Rust struct
#[derive(TypedData)]
#[magnus(class = "MyExtension::Counter", free_immediately)]
struct Counter {
    count: i64,
}

// Implement required functions
impl DataTypeFunctions for Counter {}

// Implement methods for your struct
impl Counter {
    fn new(initial_value: i64) -&gt; Self {
        Counter { count: initial_value }
    }

    fn increment(&amp;mut self, amount: i64) -&gt; i64 {
        self.count += amount;
        self.count
    }

    fn value(&amp;self) -&gt; i64 {
        self.count
    }
}

// Register with Ruby
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let class = ruby.define_class("Counter", ruby.class_object())?;

    class.define_singleton_method("new", function!(|initial: i64| {
        Ok(class.wrap(Counter::new(initial)))
    }, 1))?;

    class.define_method("increment", method!(Counter::increment, 1))?;
    class.define_method("value", method!(Counter::value, 0))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="implementing-gc-marking"><a class="header" href="#implementing-gc-marking">Implementing GC Marking</a></h3>
<p>When your Rust struct holds references to Ruby objects, you need to implement the <code>mark</code> method to tell Ruby's GC about
those references. Here's a simple example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{
    prelude::*, Error, Ruby, Value, TypedData, DataTypeFunctions,
    gc::Marker, typed_data::Obj
};

// A struct that holds references to Ruby objects
#[derive(TypedData)]
#[magnus(class = "MyExtension::Person", free_immediately, mark)]
struct Person {
    // Reference to a Ruby string (their name)
    name: Value,
    // Reference to Ruby array (their hobbies)
    hobbies: Value,
    // Optional reference to another Person (their friend)
    friend: Option&lt;Obj&lt;Person&gt;&gt;,
}

// Implement DataTypeFunctions with mark method
impl DataTypeFunctions for Person {
    // This is called during GC mark phase
    fn mark(&amp;self, marker: &amp;Marker) {
        // Mark the Ruby objects we reference
        marker.mark(self.name);
        marker.mark(self.hobbies);

        // If we have a friend, mark them too
        if let Some(ref friend) = self.friend {
            marker.mark(*friend);
        }
    }
}

impl Person {
    fn new(name: Value, hobbies: Value) -&gt; Self {
        Self {
            name,
            hobbies,
            friend: None,
        }
    }

    fn add_friend(&amp;mut self, friend: Obj&lt;Person&gt;) {
        self.friend = Some(friend);
    }

    fn name(&amp;self) -&gt; Value {
        self.name
    }

    fn hobbies(&amp;self) -&gt; Value {
        self.hobbies
    }

    fn friend(&amp;self) -&gt; Option&lt;Obj&lt;Person&gt;&gt; {
        self.friend.clone()
    }
}

// Register with Ruby
fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let class = ruby.define_class("Person", ruby.class_object())?;

    class.define_singleton_method("new", function!(|name: Value, hobbies: Value| {
        Ok(class.wrap(Person::new(name, hobbies)))
    }, 2))?;

    class.define_method("name", method!(Person::name, 0))?;
    class.define_method("hobbies", method!(Person::hobbies, 0))?;
    class.define_method("friend", method!(Person::friend, 0))?;
    class.define_method("add_friend", method!(Person::add_friend, 1))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>In this example:</p>
<ol>
<li>The <code>Person</code> struct holds references to Ruby objects (<code>name</code> and <code>hobbies</code>) and another wrapped Rust object
(<code>friend</code>)</li>
<li>We implement the <code>mark</code> method to tell Ruby's GC about all these references</li>
<li>During garbage collection, Ruby will know not to collect these objects as long as the <code>Person</code> is alive</li>
</ol>
<h2 id="a-real-world-example-trap-from-wasmtime-rb"><a class="header" href="#a-real-world-example-trap-from-wasmtime-rb">A Real-World Example: Trap from wasmtime-rb</a></h2>
<p>Here's a slightly simplified version of a real-world example from the wasmtime-rb project:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{
    prelude::*, method, Error, Ruby, TypedData, DataTypeFunctions,
    typed_data::Obj, Symbol
};

// A struct representing a WebAssembly trap (error)
#[derive(TypedData)]
#[magnus(class = "Wasmtime::Trap", size, free_immediately)]
pub struct Trap {
    trap: wasmtime::Trap,
    wasm_backtrace: Option&lt;wasmtime::WasmBacktrace&gt;,
}

// No references to Ruby objects, so mark is empty
impl DataTypeFunctions for Trap {}

impl Trap {
    pub fn new(trap: wasmtime::Trap, wasm_backtrace: Option&lt;wasmtime::WasmBacktrace&gt;) -&gt; Self {
        Self {
            trap,
            wasm_backtrace,
        }
    }

    // Return a text description of the trap error
    pub fn message(&amp;self) -&gt; String {
        self.trap.to_string()
    }

    // Return the wasm backtrace if available
    pub fn wasm_backtrace_message(&amp;self) -&gt; Option&lt;String&gt; {
        self.wasm_backtrace.as_ref().map(|bt| format!("{bt}"))
    }

    // Return the trap code as a Ruby symbol
    pub fn code(&amp;self) -&gt; Result&lt;Option&lt;Symbol&gt;, Error&gt; {
        match self.trap {
            wasmtime::Trap::StackOverflow =&gt; Ok(Some(Symbol::new("STACK_OVERFLOW"))),
            wasmtime::Trap::MemoryOutOfBounds =&gt; Ok(Some(Symbol::new("MEMORY_OUT_OF_BOUNDS"))),
            // More cases...
            _ =&gt; Ok(Some(Symbol::new("UNKNOWN"))),
        }
    }

    // Custom inspect method
    pub fn inspect(rb_self: Obj&lt;Self&gt;) -&gt; Result&lt;String, Error&gt; {
        Ok(format!(
            "#&lt;Wasmtime::Trap:0x{:016x} @trap_code={}&gt;",
            rb_self.as_raw(),
            rb_self.code()?.map_or("nil".to_string(), |s| s.to_string())
        ))
    }
}

// Register with Ruby
pub fn init(ruby: &amp;Ruby) -&gt; Result&lt;(), Error&gt; {
    let class = ruby.define_class("Trap", ruby.class_object())?;

    class.define_method("message", method!(Trap::message, 0))?;
    class.define_method("wasm_backtrace_message", method!(Trap::wasm_backtrace_message, 0))?;
    class.define_method("code", method!(Trap::code, 0))?;
    class.define_method("inspect", method!(Trap::inspect, 0))?;

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>This example shows:</p>
<ol>
<li>A Rust struct that wraps WebAssembly-specific types</li>
<li>Methods that convert Rust values to Ruby-friendly types</li>
<li>A simple implementation of <code>DataTypeFunctions</code> (since there are no Ruby object references to mark)</li>
</ol>
<h2 id="more-complex-example-memory-references"><a class="header" href="#more-complex-example-memory-references">More Complex Example: Memory References</a></h2>
<p>Let's look at a more complex scenario involving memory management:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use magnus::{
    prelude::*, gc::Marker, Error, Ruby, TypedData, DataTypeFunctions,
    typed_data::Obj, value::Opaque, RString
};

// Represents WebAssembly memory
#[derive(TypedData)]
#[magnus(class = "Wasmtime::Memory", free_immediately, mark)]
struct Memory {
    // Reference to a store (context) object
    store: StoreContext,
    // The actual WebAssembly memory
    memory: WasmMemory,
}

impl DataTypeFunctions for Memory {
    fn mark(&amp;self, marker: &amp;Marker) {
        // Mark the store so it stays alive
        self.store.mark(marker);
    }
}

// A guard that ensures memory access is safe
struct MemoryGuard {
    // Reference to Memory object
    memory: Opaque&lt;Obj&lt;Memory&gt;&gt;,
    // Size when created, to detect resizing
    original_size: u64,
}

impl MemoryGuard {
    fn new(memory: Obj&lt;Memory&gt;) -&gt; Result&lt;Self, Error&gt; {
        let original_size = memory.size()?;

        Ok(Self {
            memory: memory.into(),
            original_size,
        })
    }

    fn get(&amp;self) -&gt; Result&lt;&amp;Memory, Error&gt; {
        let ruby = Ruby::get().unwrap();
        let mem = ruby.get_inner_ref(&amp;self.memory);

        // Check that memory size hasn't changed
        if mem.size()? != self.original_size {
            return Err(Error::new(
                magnus::exception::runtime_error(),
                "memory was resized, reference is no longer valid"
            ));
        }

        Ok(mem)
    }

    fn mark(&amp;self, marker: &amp;Marker) {
        marker.mark(self.memory);
    }
}

// A slice of WebAssembly memory
#[derive(TypedData)]
#[magnus(class = "Wasmtime::MemorySlice", free_immediately, mark)]
struct MemorySlice {
    guard: MemoryGuard,
    offset: usize,
    size: usize,
}

impl DataTypeFunctions for MemorySlice {
    fn mark(&amp;self, marker: &amp;Marker) {
        // Mark the memory guard, which marks the memory object
        self.guard.mark(marker);
    }
}

impl MemorySlice {
    fn new(memory: Obj&lt;Memory&gt;, offset: usize, size: usize) -&gt; Result&lt;Self, Error&gt; {
        let guard = MemoryGuard::new(memory)?;

        // Validate the slice is in bounds
        let mem = guard.get()?;
        if offset + size &gt; mem.data_size()? {
            return Err(Error::new(
                magnus::exception::range_error(),
                "memory slice out of bounds"
            ));
        }

        Ok(Self {
            guard,
            offset,
            size,
        })
    }

    // Read the slice as a Ruby string (efficiently, without copying)
    fn to_str(&amp;self) -&gt; Result&lt;RString, Error&gt; {
        let ruby = unsafe { Ruby::get_unchecked() };
        let mem = self.guard.get()?;
        let data = mem.data()?;

        // Extract the relevant slice
        let slice = &amp;data[self.offset..self.offset + self.size];

        // Create a Ruby string directly from the slice (zero-copy)
        Ok(ruby.str_from_slice(slice))
    }

    // Read the slice as a UTF-8 string (with validation)
    fn to_utf8_str(&amp;self) -&gt; Result&lt;RString, Error&gt; {
        let ruby = unsafe { Ruby::get_unchecked() };
        let mem = self.guard.get()?;
        let data = mem.data()?;

        // Extract the relevant slice
        let slice = &amp;data[self.offset..self.offset + self.size];

        // Validate UTF-8 and create a Ruby string
        match std::str::from_utf8(slice) {
            Ok(s) =&gt; Ok(RString::new(s)),
            Err(e) =&gt; Err(Error::new(
                magnus::exception::encoding_error(),
                format!("invalid UTF-8: {}", e)
            ))
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This more advanced example demonstrates:</p>
<ol>
<li><strong>Guarded Resource Access</strong>: The <code>MemoryGuard</code> ensures memory operations are safe by checking for resizing</li>
<li><strong>Proper GC Integration</strong>: Both structs implement marking to ensure referenced objects aren't collected</li>
<li><strong>Efficient String Creation</strong>: Using <code>str_from_slice</code> to create strings directly from memory without extra copying</li>
<li><strong>Error Handling</strong>: All operations that might fail return meaningful errors</li>
<li><strong>Resource Validation</strong>: The code validates bounds before accessing memory</li>
</ol>
<h2 id="common-memory-management-pitfalls"><a class="header" href="#common-memory-management-pitfalls">Common Memory Management Pitfalls</a></h2>
<div class="warning">
<p>These pitfalls can lead to crashes, memory leaks, or undefined behavior in your Ruby extensions. Understanding and
avoiding them is crucial for writing reliable code.</p>
</div>
<h3 id="1-forgetting-to-mark-references"><a class="header" href="#1-forgetting-to-mark-references">1. Forgetting to Mark References</a></h3>
<p>If your Rust struct holds Ruby objects but doesn't implement marking, those objects might be collected while still in
use:</p>
<pre><pre class="playground"><code class="language-rust hidelines=#"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use magnus::{gc::Marker, DataTypeFunctions, Value};
</span><span class="boring">
</span>// BAD: No marking implementation
struct BadExample {
    ruby_object: Value,  // This reference won't be marked by GC
}

<span class="boring">impl DataTypeFunctions for BadExample {
</span><span class="boring">    // Missing mark implementation!
</span><span class="boring">}
</span><span class="boring">
</span>// GOOD: Proper marking
struct GoodExample {
    ruby_object: Value,
}

impl DataTypeFunctions for GoodExample {
    fn mark(&amp;self, marker: &amp;Marker) {
        marker.mark(self.ruby_object);
    }
}

<span class="boring">// A more complex example with multiple references
</span><span class="boring">struct ComplexExample {
</span><span class="boring">    ruby_strings: Vec&lt;Value&gt;,
</span><span class="boring">    ruby_hash: Value,
</span><span class="boring">    ruby_object: Value,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl DataTypeFunctions for ComplexExample {
</span><span class="boring">    fn mark(&amp;self, marker: &amp;Marker) {
</span><span class="boring">        // Mark each string in the vector
</span><span class="boring">        for string in &amp;self.ruby_strings {
</span><span class="boring">            marker.mark(*string);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Mark the hash and object
</span><span class="boring">        marker.mark(self.ruby_hash);
</span><span class="boring">        marker.mark(self.ruby_object);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="tip">
<p>Click the eye icon (<i class="fa fa-eye"></i>) to see an additional example of marking multiple references in a more
complex struct.</p>
</div>
<h3 id="2-creating-cyclic-references"><a class="header" href="#2-creating-cyclic-references">2. Creating Cyclic References</a></h3>
<p>Cyclic references (A references B, which references A) can lead to memory leaks. Consider using weak references or
redesigning your object graph.</p>
<h3 id="3-inefficient-string-creation"><a class="header" href="#3-inefficient-string-creation">3. Inefficient String Creation</a></h3>
<div class="note">
<p>String handling is often a performance bottleneck in Ruby extensions. Using the right APIs can significantly improve
performance.</p>
</div>
<p>Creating strings inefficiently can significantly impact performance:</p>
<pre><pre class="playground"><code class="language-rust hidelines=#"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use magnus::{Error, RString, Ruby};
</span><span class="boring">
</span>// BAD: Creates unnecessary temporary Rust String
fn inefficient_string(data: &amp;[u8]) -&gt; Result&lt;RString, Error&gt; {
    let temp_string = String::from_utf8(data.to_vec())?; // Unnecessary allocation
    Ok(RString::new(&amp;temp_string))  // Another copy
}

// GOOD: Direct creation from slice
fn efficient_string(ruby: &amp;Ruby, data: &amp;[u8]) -&gt; RString {
    ruby.str_from_slice(data)  // No extra copies
}

<span class="boring">// ALSO GOOD: Creating from string slice when UTF-8 is confirmed
</span><span class="boring">fn from_str(ruby: &amp;Ruby, s: &amp;str) -&gt; RString {
</span><span class="boring">    RString::new(s)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// ALSO GOOD: Creating binary string with capacity then filling
</span><span class="boring">fn build_string(ruby: &amp;Ruby, size: usize) -&gt; RString {
</span><span class="boring">    let mut string = RString::with_capacity(size);
</span><span class="boring">    // Fill the string directly...
</span><span class="boring">    string
</span><span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div class="tip">
<p>Both memory usage and performance are significantly improved by avoiding unnecessary allocations and copies. The eye
icon (<i class="fa fa-eye"></i>) reveals additional efficient string handling examples.</p>
</div>
<h3 id="4-not-handling-exceptions-properly"><a class="header" href="#4-not-handling-exceptions-properly">4. Not Handling Exceptions Properly</a></h3>
<p>Ruby exceptions can disrupt the normal flow of your code. Ensure resources are cleaned up even when exceptions occur.</p>
<h2 id="refcell-and-interior-mutability"><a class="header" href="#refcell-and-interior-mutability">RefCell and Interior Mutability</a></h2>
<p>When creating Ruby objects with Rust, you'll often need to use interior mutability patterns. The most common approach is
using <code>RefCell</code> to allow your Ruby objects to be mutated even when users hold immutable references to them.</p>
<h3 id="understanding-refcell-and-borrowing"><a class="header" href="#understanding-refcell-and-borrowing">Understanding RefCell and Borrowing</a></h3>
<p>Rust's <code>RefCell</code> allows mutable access to data through shared references, but enforces Rust's borrowing rules at
runtime. This is perfect for Ruby extension objects, where Ruby owns the object and we interact with it via method
calls.</p>
<p>A common pattern is to wrap your Rust struct in a <code>RefCell</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cell::RefCell;
use magnus::{prelude::*, Error, Ruby};

struct Counter {
    count: i64,
}

#[magnus::wrap(class = "MyExtension::Counter")]
struct MutCounter(RefCell&lt;Counter&gt;);

impl MutCounter {
    fn new(initial: i64) -&gt; Self {
        Self(RefCell::new(Counter { count: initial }))
    }

    fn count(&amp;self) -&gt; i64 {
        self.0.borrow().count
    }

    fn increment(&amp;self) -&gt; i64 {
        let mut counter = self.0.borrow_mut();
        counter.count += 1;
        counter.count
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="the-borrowmuterror-problem"><a class="header" href="#the-borrowmuterror-problem">The BorrowMutError Problem</a></h3>
<p>A common mistake when using <code>RefCell</code> is trying to borrow mutably when you already have an active immutable borrow. This
leads to a <code>BorrowMutError</code> panic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD - will panic with "already borrowed: BorrowMutError"
fn buggy_add(&amp;self, val: i64) -&gt; Result&lt;i64, Error&gt; {
    // First borrow is still active when we try to borrow_mut below
    if let Some(sum) = self.0.borrow().count.checked_add(val) {
        self.0.borrow_mut().count = sum; // ERROR - already borrowed above
        Ok(sum)
    } else {
        Err(Error::new(
            ruby.exception_range_error(),
            "result too large"
        ))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The problem is that the <code>borrow()</code> in the <code>if</code> condition is still active when we try to use <code>borrow_mut()</code> in the body.
Rust's borrow checker would catch this at compile time for normal references, but <code>RefCell</code> defers this check to
runtime, resulting in a panic.</p>
<h3 id="the-solution-complete-borrows-before-mutating"><a class="header" href="#the-solution-complete-borrows-before-mutating">The Solution: Complete Borrows Before Mutating</a></h3>
<p>The solution is to complete all immutable borrows before starting mutable ones:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GOOD - copy the value first to complete the borrow
fn safe_add(&amp;self, val: i64) -&gt; Result&lt;i64, Error&gt; {
    // Get the current count, completing this borrow
    let current_count = self.0.borrow().count;

    // Now we can safely borrow mutably
    if let Some(sum) = current_count.checked_add(val) {
        self.0.borrow_mut().count = sum; // Safe now
        Ok(sum)
    } else {
        Err(Error::new(
            ruby.exception_range_error(),
            "result too large"
        ))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>By copying <code>count</code> to a local variable, we complete the immutable borrow before starting the mutable one, avoiding the
runtime panic.</p>
<h3 id="complex-example-with-multiple-operations"><a class="header" href="#complex-example-with-multiple-operations">Complex Example with Multiple Operations</a></h3>
<p>When working with more complex data structures:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Game {
    players: Vec&lt;String&gt;,
    current_player: usize,
    score: i64,
}

#[magnus::wrap(class = "MyGame")]
struct MutGame(RefCell&lt;Game&gt;);

impl MutGame {
    fn new() -&gt; Self {
        Self(RefCell::new(Game {
            players: Vec::new(),
            current_player: 0,
            score: 0,
        }))
    }

    // INCORRECT: Multiple borrows that will cause issues
    fn buggy_next_player_scores(&amp;self, points: i64) -&gt; Result&lt;String, Error&gt; {
        let game = self.0.borrow();
        if game.players.is_empty() {
            return Err(Error::new(
                magnus::exception::runtime_error(),
                "No players in game"
            ));
        }

        // This would panic - we're still borrowing game
        let mut game_mut = self.0.borrow_mut();
        game_mut.score += points;
        let player = game_mut.current_player;
        game_mut.current_player = (player + 1) % game_mut.players.len();

        Ok(format!("{} scored {} points! New total: {}",
            game_mut.players[player], points, game_mut.score))
    }

    // CORRECT: Copy all needed data before releasing the borrow
    fn safe_next_player_scores(&amp;self, points: i64) -&gt; Result&lt;String, Error&gt; {
        // Read all the data we need first
        let player_name: String;
        let new_player_index: usize;
        let new_score: i64;

        {
            // Create a block scope to ensure the borrow is dropped
            let game = self.0.borrow();
            if game.players.is_empty() {
                return Err(Error::new(
                    magnus::exception::runtime_error(),
                    "No players in game"
                ));
            }

            player_name = game.players[game.current_player].clone();
            new_player_index = (game.current_player + 1) % game.players.len();
            new_score = game.score + points;
        } // borrow is dropped here

        // Now we can borrow mutably
        let mut game = self.0.borrow_mut();
        game.score = new_score;
        game.current_player = new_player_index;

        Ok(format!("{} scored {} points! New total: {}",
            player_name, points, new_score))
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="using-temporary-variables-instead-of-block-scopes"><a class="header" href="#using-temporary-variables-instead-of-block-scopes">Using Temporary Variables Instead of Block Scopes</a></h3>
<p>If you prefer, you can use temporary variables instead of block scopes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_player(&amp;self, player: String) -&gt; Result&lt;usize, Error&gt; {
    // Get the current number of players first
    let player_count = self.0.borrow().players.len();

    // Now we can mutate
    let mut game = self.0.borrow_mut();
    game.players.push(player);

    Ok(player_count + 1) // Return new count
}
<span class="boring">}</span></code></pre></pre>
<h3 id="refcell-best-practices"><a class="header" href="#refcell-best-practices">RefCell Best Practices</a></h3>
<ol>
<li>
<p><strong>Complete All Borrows</strong>: Always complete immutable borrows before starting mutable borrows.</p>
</li>
<li>
<p><strong>Use Block Scopes or Variables</strong>: Either use block scopes to limit borrow lifetimes or copy needed values to local
variables.</p>
</li>
<li>
<p><strong>Minimize Borrow Scope</strong>: Keep the scope of borrows as small as possible.</p>
</li>
<li>
<p><strong>Clone When Necessary</strong>: If you need to keep references to data while mutating other parts, clone the data you need
to keep.</p>
</li>
<li>
<p><strong>Consider Data Design</strong>: Structure your data to minimize the need for complex borrowing patterns.</p>
</li>
<li>
<p><strong>Error When Conflicting</strong>: If you can't resolve a borrowing conflict cleanly, make the operation an error rather
than trying to force it.</p>
</li>
</ol>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li><strong>Use TypedData and DataTypeFunctions</strong>: They provide a safe framework for memory management</li>
<li><strong>Always Implement Mark Methods</strong>: Mark all Ruby objects your struct references</li>
<li><strong>Validate Assumptions</strong>: Check that resources are valid before using them</li>
<li><strong>Use Zero-Copy APIs</strong>: Leverage APIs like <code>str_from_slice</code> to avoid unnecessary copying</li>
<li><strong>Use Guards for Changing Data</strong>: Validate assumptions before accessing data that might change</li>
<li><strong>Test Thoroughly with GC Stress</strong>: Run tests with <code>GC.stress = true</code> to expose memory issues</li>
<li><strong>Handle RefCell Borrowing Carefully</strong>: Complete all immutable borrows before starting mutable ones to avoid runtime
panics</li>
</ol>
<p>By following these practices, you can write Ruby extensions in Rust that are both memory-safe and efficient.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>In the next chapter, we'll explore performance optimization techniques that leverage Rust's strengths while maintaining
memory safety.</p>

                    </main>

                    <nav class="nav-wrapper" style="margin-bottom: 0;" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="error-handling.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="build-process.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                    
                    <div class="footer-note" style="margin: 3rem 0 0 0; padding: 2rem; font-size: 1.1rem; color: #555; border-top: 1px solid #ddd; display: flex; justify-content: center; align-items: center; font-family: inherit;">
                        <div style="max-width: 800px; text-align: center; line-height: 1.6;">
                            This documentation was created with assistance from an LLM.<br>
                            If you spot any issues, please <a href="https://github.com/oxidize-rb/rb-sys/issues" style="color: #3184a8; text-decoration: none; font-weight: bold;">submit a fix or report it</a>.<br>
                            We appreciate your help in improving these docs!
                        </div>
                    </div>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="error-handling.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="build-process.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/js/custom.js"></script>


    </div>
    </body>
</html>
